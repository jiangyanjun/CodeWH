<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="Language" content="zh-CN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../images/kebue.ico">
    <link rel="icon" href="../../images/kebue.ico">
    <meta name="description" content=JavaScript>
    <meta name="keywords" content=JavaScript>
    <title>JavaScript</title>

    <link href="../../template/scripts/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="../../template/styles/custom.css" rel="stylesheet" />

</head>
<body id="pageBody">
    <div id="divBoxed" class="container">
        <div class="transparent-bg" style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;z-index: -1;zoom: 1;"></div>
        <div class="divPanel notop nobottom">
            <div class="row-fluid">
                <div class="span12">
                    <div id="divLogo">
                        <a href="../../../Home/Index" id="divSiteTitle">科布尔 kebue</a><br />
                        <a href="../../../Home/Index" id="divTagLine">开发者用代码改变世界从科布尔开始</a>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="divMenuRight" class="pull-right">
                        <div class="navbar">
                            <button type="button" class="btn btn-navbar-highlight btn-large btn-primary" data-toggle="collapse" data-target=".nav-collapse">
                                NAVIGATION <span class="icon-chevron-down icon-white"></span>
                            </button>
                            <div class="nav-collapse collapse">
                                <ul class="nav nav-pills ddmenu">
                                    <li class="dropdown glyphicon glyphicon-arrow-left"><a href='javascript:window.history.back()'>后退</a></li>
                                    <li class="dropdown active"><a href="http://www.kebue.com/">Home</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="contentInnerSeparator"></div>
                </div>
            </div>
        </div>
        <div class="contentArea">
            <div class="divPanel notop page-content">
                <div class="breadcrumbs">
                    <a href="../../../Home/Index">Home</a> &nbsp;/&nbsp; <span>JavaScript</span>
                </div><br /><hr />
                <div class="row-fluid">
                    <div class="span12" id="Article-type">
                        <ul>
                            <li><span>1</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/ABA7E445-0BFF-4456-8809-BD8308163628.html' title='本章内容：简介定义注释引入文件变量运算符算术运算符比较运算符逻辑运算符数据类型数字字符串布尔类型数组Math语句条件语句（if、switch）循环语句（for、for in、while、do-while）label语句异常处理函数定义函数3种方式函数参数（arguments）作用域与作用链闭包面向对象（特性，构造模式，原型模式prototype）prototype 验证方法（isPrototypeOf、hasOwnProperty、in）其它序列化转义eval正则表达式时间处理简介定义　　javascript是一门动态弱类型的解释型编程语言，增强页面动态效果，实现页面与用户之间的实时动态的交互。　　javascript是由三部分组成：ECMAScript、DOM、BOMECMAScript由ECMA-262定义，提供核心语言功能（ECMA是欧洲计算机制造商协会）DOM(Document Object Model)文档对象模型，提供访问和操作网页内容的方法和接口BOM(Browser Object Model)浏览器对象模型，提供与浏览器交互的方法和接口注释JavaScript中代码注释：单行 //多行 /* */引入文件1. 引入外部文件1scripttypetext/javascript src=JS文件/script2. 存放在HTML的head或body中123scripttypetext/javascriptJs代码内容/script　HTML的head中HTML的body代码块底部(推荐)3. 为什么要放在body代码块底部？HTML代码从上到下执行，先加载CSS，避免html出现无样式状态；将JavaScript代码块放在body最后，可以让网页尽快的呈现给用户，减少浏览者的等待时间，避免因为JS代码块阻塞网页的呈现。变量需要注意的是：局部变量必须以var 开头申明，如果不写 var 则为全局变量12345678910111213scripttype=text/javascript// 全局变量name = nick;function func(){// 局部变量var age = 18;// 全局变量gender = man}/script　　运算符1. 算术运算符一元算术  + 一元加，数值不会产生影响对非数值应用一元加运算时，会调用Number()转型函数对这个值进行转换  - 一元减，转换为负数~  ++ 递增1通过Number()转型为数字，再加1，再重新赋值给操作数值  -- 递减1~二元算术  + 加法  - 减法  * 乘法  / 除法  % 取模1如果其中一个操作数是对象，则对象会转换为原始值：日期对象通过toString()方法执行转换，其他对象通过valueOf()方法执行转换。如果结果还不是原始值，则再使用toString()方法转换2在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换成字符串，进行字符串拼接3两个操作数都将转换成数字或NaN，进行加法操作2. 比较运算符 === 严格运算符比较过程没有任何类型转换 !== 严格运算符===的结果取反 == 相等运算符如果两个操作值不是同一类型，相等运算符会尝试进行一些类型转换，然后再进行比较 != 不相等运算符==的结果取反  大于运算符 = 大于等于运算符  小于运算符 = 小于等于运算符1如果两个值类型不同则返回false2如果两个值类型相同，值相同，则返回true，否则返回false3如果两个值引用同一个对象，则返回true，否则，返回false
console.log([]===[]);//falseconsole.log({}==={});//falsevara={};
b=a;
console.log(a===b);//true对象类型和原始类型比较：1对象类型会先使用valueOf()转换成原始值，如果结果还不是原始值，则再使用toString()方法转换，再进行比较（日期类只允许使用toString()方法转换为字符串）2在对象转换为原始值之后，如果两个操作数都是字符串，则进行字符串的比较3在对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都将通过Number()转型函数转换成数字进行数值比较

注：如果一个值是null，另一个值是undefined，则返回true;
console.log(null==undefined);//true如果一个值是null，另一个值是0，则返回tfalse;
console.log(null==0);//false空字符串或空格字符串会转成0
console.log(null==[]);//falseconsole.log(null==);//falseconsole.log([]==);//false，相当于==console.log([]==);//true，相当于==console.log(0==);//true数字和字符串比较：1如果操作值是对象，则这个对象将先使用valueOf()转换成原始值，如果结果还不是原始值，则再使用toString()方法转换2在对象转换为原始值之后，如果两个操作数都是字符串，则按照unicode字符的索引顺序对两个字符串进行比较3在对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都转换成数字进行比较
console.log(Ba);//falseconsole.log(ba);//trueconsole.log(92);//true3. 逻辑运算符  ! 非（两个!!表示Boolean()转型函数）返回一个布尔值  与两个操作都为true时返回true，否则返回false（返回值不一定是布尔值），可以多个连用（......）  || 或两个操作都是false时返回false，否则返回true（返回值不一定是布尔值），可以多个连用（..||..||..）1234567891011//七个假值：console.log(!!undefined);//falseconsole.log(!!null);//falseconsole.log(!!0);//falseconsole.log(!!-0);//falseconsole.log(!!NaN);//falseconsole.log(!!);//falseconsole.log(!!false);//falseconsole.log(!!{});//trueconsole.log(!![]);//true1取代if语句//前面条件成立则运行后面操作(a==b)dosomething();2用于回调函数//若没有给参数a传值，则a默认为undefined假值，所以不执行a()。functionfn(a){
aa();
}1变量设置为默认值//如果没有向参数a传入任何参数，则将该参数设置为空对象functionfunc(a){
a=a||{};
}　　数据类型特殊值：null　　　　　表示一个空对象指针，常用来描述空值；undefined　　表示变量未定义。1、数字（Number）JavaScript中不区分整数和浮点数，所有数字均用浮点数值表示。转换：parseInt(..)  将某值转换成整数，不成功则NaNparseFloat(..)将某值转换成浮点数，不成功则NaN特殊值：NaN，非数字。可以使用 isNaN(num) 来判断。Infinity，无穷大。可以使用 isFinite(num) 来判断。Number对数字的支持Number.MAX_VALUE最大数值Number.MIN_VALUE最小数值Number.NaN非数字Number.NEGATIVE_INFINITY负无穷大Number.POSITIVE_INFINITY正无穷大Number.toExponential( )返回四舍五入的科学计数法，加参数为保留几位Number.toFixed( )小数点后面的数字四舍五入，加参数为保留几位Number.toPrecision( )四舍五入，自动调用toFixed()或toExponential()Number.toLocaleString( )把数字转换成本地格式的字符串Number.toString( )将数字转换成字符串Number.valueOf( )返回原始数值2、字符串（String）String.length字符串的长度String.trim()移除空白String.trimLeft()移除左侧空白String.trimRight()移除右侧空白String.concat(value, ...)拼接String.slice(start, end)切片String.split( )分割String.search( )从头开始匹配，返回匹配成功的第一个位置(g无效)String.match( )全局搜索，如果正则中有g表示找到全部，否则只找到第一个String.replace( )替换，正则中有g则替换所有，否则只替换第一个匹配项；$数字：匹配的第n个组内容；$：当前匹配的内容；$`：位于匹配子串左侧的文本；$：位于匹配子串右侧的文本$$：直接量$符号String.charAt( )返回字符串中的第n个字符String.charCodeAt( )返回字符串中的第n个字符的代码String.fromCharCode( )从字符编码创建—个字符串String.indexOf( )查找子字符串位置String.lastIndexOf( )查找子字符串位置String.localeCompare( )用本地特定的顺序来比较两个字符串String.substr( )抽取一个子串String.substring( )返回字符串的一个子串String.toLocaleLowerCase( )把字符串转换小写(针对地区，在不知道程序在哪个语言环境中运行时用)String.toLocaleUpperCase( )将字符串转换成大写(针对地区)String.toLowerCase( )小写String.toUpperCase( )大写String.toString( )返回原始字符串值String.toString()返回原始字符串值String.valueOf( )返回原始字符串值\0空字节
\n换行
\t制表
\b空格
\r回车
\f进纸
\\斜杠
\单引号
\双引号3、布尔类型（Boolean）true（真）和false（假）toString()返回Boolean的字符串值(true或false)toLocaleString()返回Boolean的字符串值(true或false)valueOf()返回Boolean的原始布尔值(true或false)4、数组（Array）12varname = Array(nick,jenny);varname = [nick,jenny];　　Array.length数组的大小Array.push()尾部添加元素Array.pop()删除并返回数组的最后一个元素Array.unshift()在数组头部插入一个元素Array.shift( )在数组头部移除一个元素Array.slice( )切片Array.reverse( )反转Array.join( )将数组元素连接起来以构建一个字符串Array.concat( )拼接Array.sort( )排序Array对数组的内部支持Array.splice( start, deleteCount, value, ...)插入、删除或替换数组的元素obj.splice(n,0,val) 指定位置插入元素obj.splice(n,1,val) 指定位置替换元素obj.splice(n,1)  指定位置删除元素Array.toLocaleString( )把数组转换成局部字符串Array.toString( )将数组转换成一个字符串5. MathMath对象是一个静态对象，而不是构造函数。实际上，Math只是一个由Javascript设置的对象命名空间，用于存储数学函数。作用是执行普通的算数任务。常量

Math.E
常量e，自然对数的底数。

Math.LN10
10的自然对数。

Math.LN2
2的自然对数。

Math.LOG10E
以10为底的e的对数。

Math.LOG2E
以2为底的e的对数。

Math.PI
常量figs/U03C0.gif。Math.SQRT1_2
2的平方根除以1。

Math.SQRT2
2的平方根。

静态函数

Math.abs()
计算绝对值。

Math.acos()
计算反余弦值。

Math.asin()
计算反正弦值。

Math.atan()
计算反正切值。

Math.atan2()
计算从X轴到一个点的角度。

Math.ceil()
对一个数上舍入。

Math.cos()
计算余弦值。

Math.exp()
计算e的指数。

Math.floor()
对一个数下舍人。

Math.log()
计算自然对数。

Math.max()
返回两个数中较大的一个。

Math.min()
返回两个数中较小的一个。

Math.pow()
计算xy。

Math.random()
计算一个随机数。

Math.round()
舍入为最接近的整数。

Math.sin()
计算正弦值。

Math.sqrt()
计算平方根。

Math.tan()
计算正切值。语句1、条件语句JavaScript中支持两个条件语句，分别是：if 和 switch。if 语句：123456789//if语句if(条件){}else if(条件){}else{}Switch 语句：123456789101112//switch语句，name等于nick是执行第一个case,等于第二个执行第二个case,其它执行default.switch(name){case nick:age = 18;break;case jenny:age = 21;break;default :age = 0;}　　2、循环语句JavaScript中支持四种循环语句，分别是：for、for in、while、do-whilefor 循环：123456var names = [nick, jenny];for(var i=0;inames.length;i++){console.log(i); //索引console.log(names[i]);}for in 循环：123456var names = [nick, jenny];for(var index in names){console.log(index);console.log(names[index]);}while 循环：　1234while(条件){// break;// continue;}do-while 循环：123456//循环的代码至少执行一次，结果为1var num = 0;do {num++;}while (num10);　　3. label语句label 语句可以理解为跳出任意循环//输出结果为95

scriptvarnum=0;for(vari=0;i10;i++){for(varj=0;j10;j++){if(i==5j==5){break;
}
num++;
}
}
console.log(num);/script//输出结果为55//i和j都循环为到5时，跳出了两层循环

scriptvarnum=0;
outPoint:for(vari=0;i10;i++){for(varj=0;j10;j++){if(i==5j==5){breakoutPoint;
}
num++;
}
}
console.log(num);/script4. 异常处理主动跑出异常 throw Error(xxxx)12345678910try{//这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行}catch(e) {// 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。//e是一个局部变量，用来指向Error对象或者其他抛出的对象}finally {//无论上述代码怎么，finally代码块始终会执行}函数Function函数定义的三种方式：1234567891011121314// 普通函数functionfunc(arg){returntrue;}// 匿名函数varfunc =function(arg){returnnick;}// 自执行函数(function(arg){console.log(arg);})(nick)　　函数参数：函数传参的个数可以小于实际需传参的个数，没传参的默认为undefined参数传多默认不起作用123456functionman(name,age) {console.log(name,age);}man(nick,18);//nick 18man(nick);//nick undefinedman(nick,18,19);//nick 18arguments 可接收所有参数，返回一个数组123456functionman() {console.log(arguments);}man(nick,18);//[nick, 18]man(nick);//[nick]man(nick,18,19);//[nick, 18, 19]　　函数的作用域与作用域链：JavaScript中没有块级作用域123456789101112varname =nick;(functionMain(){console.log(name);//undefinedif(1){varname =jenny;}console.log(name);//jenny})();console.log(name);//nick//输出结果第一个为undefined//声明需提前（Hoisting），在JavaScript引擎“预编译”时进行，函数在被执行之前，会将其中的变量全部声明，而不赋值作用域链每个构造函数都有一个内部对象指针，指向原型对象，而原型对象也包含一个指向构造函数的指针。如此层层递进，形成作用域链条12345678910111213141516varname =nick;functionMain() {functionF1(){varname =jenny;console.log(name);//jenny}functionF2() {console.log(name);//nick}F1();F2();}Main();// 从内到外的优先级寻找// F2() 的作用域链为 F2()--Main()　　闭包：闭包就是能够读取其他函数内部变量的函数。1234567891011121314151617functionf1(){　　　　varn=1;　　　　Add=function(){n++;};　　　　functionf2(){　　　　　console.log(n);　　　　}　　　　returnf2;　　 }　　varresult=f1();　　result();//1　　Add();　　result();//2//result就是闭包f2函数//函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除闭包使函数中的变量都被保存在内存中，内存消耗大，所以少用闭包，否则会造成网页的性能低，在IE中可能导致内存泄露。所以在退出函数之前，将不使用的局部变量全部删除。面向对象面向对象的三大特性:　　封装：隐藏代码实现的细节，实现代码的模块化　　继承：扩展已经存在的代码模块，实现代码重用	　　多态：接口的不同实现方式，实现接口重用关键字：  this 代指此时的对象  new 创建对象时必须使用构造函数模式：1234567891011functionFoo (name,age) {this.Name = name;this.age = age;this.Func =function() {returnthis.Name +this.age}}varobj =newFoo(nick,18);varret = obj.Func();console.log(ret);varobj2 =newFoo(jenny,21);上述模式把同样的函数封装到了不同对象，造成了内存浪费。原型模式（prototype）：123456789101112131415161718192021functionFoo(name,age) {this.Name = name;this.Age = age;}Foo.prototype = {GetInfo:function() {varstr = is good;returnthis.Name + str;},Func:function() {returnthis.Name +this.Age;}};varobj =newFoo(nick,18);console.log(obj.Name);//nickconsole.log(obj.Age);//18varret = obj.GetInfo();console.log(ret);//nick is goodvarret2 = obj.Func();console.log(ret2);//nick18varobj2 =newFoo(nick,18);所有的构造函数的prototype属性都指向另一个对象（同一块内存地址），这个对象的所有属性和方法，都会被构造函数的实例继承。Prototype模式的验证方法1.isPrototypeOf()用来判断一个对象是否存在于另一个对象的原型链中1234Foo.prototype.isPrototypeOf(obj)trueFoo.prototype.isPrototypeOf(obj2)true　　2. hasOwnProperty()用来判断某一个对象(不包括原型链)是否具有指定属性。1234obj.hasOwnProperty(Name)trueobj.hasOwnProperty(Age)true　　3.in运算符判断某个实例是否具有某个属性1234NameinobjtrueAgeinobjtrue　　其它　1、序列化JSON.stringify(obj)  序列化JSON.parse(str)    反序列化2、转义decodeURI( )          URl中未转义的字符decodeURIComponent( )  URI组件中的未转义字符encodeURI( )          URI中的转义字符encodeURIComponent( )  转义URI组件中的字符escape( )             对字符串转义unescape( )           给转义字符串解码URIError             由URl的编码和解码方法抛出3、evalJavaScript中的eval既可以运行代码也可以获取返回值12a = eval(1+1);console.log(a);//2eval()EvalError  执行字符串中的JavaScript代码4、正则表达式123varp = /nick/g;console.log(p.test(nickjennynick));// trueconsole.log(p.exec(nickjennynick));// [nick, index: 0, input: nickjennynick]JavaScript中支持正则表达式，其主要提供了两个功能：test(string)   用于检测正则是否匹配exec(string)  用于获取正则匹配的内容匹配模式：　　g:表示全局(global)模式，匹配所有字符串，不会匹配到第一项时停止　　i:表示不区分大小写(case-insensitive)模式　　m:表示多行(multiline)模式，到达一行文本末尾时还会继续查找下一行中是否存在匹配的项括号分组：12console.log(/(n)(i)ck/.exec(nickjenny));// console.log(/(n)(i)ck/.exec(nickjenny))console.log(/(n)(i)ck{2}/.exec(nickkjenny));// [nickk, n, i, index: 0, input: nickkjenny]元字符名称匹配对象
.点号单个任意字符(除回车\r、换行\n、行分隔符\u2028和段分隔符\u2029外)
[]字符组列出的单个任意字符
[^]排除型字符组未列出的单个任意字符?问号匹配0次或1次*星号匹配0交或多次+加号匹配1次或多次
{min,max}区间量词匹配至少min次，最多max次^脱字符行的起始位置
$美元符行的结束位置|竖线分隔两边的任意一个表达式
()括号限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本
\1,\2...反向引用匹配之前的第一、第二...组括号内的表达式匹配的文本\d数字，等同于[0-9]
\D非数字，等同于[^0-9]
\s空白字符
\S非空白字符
\w字母、数字、下划线，等同于[0-9A-Za-z_](汉字不属于\w)
\W非字母、数字、下划线，等同于[^0-9A-Za-z_]5、时间处理时间操作中有两种时间：时间统一时间本地时间（东8区）Date操作日期和时间的对象
Date.getDate()返回一个月中的某一天
Date.getDay()返回一周中的某一天
Date.getFullYear()返回Date对象的年份字段
Date.getHours()返回Date对象的小时字段
Date.getMilliseconds()返回Date对象的毫秒字段
Date.getMinutes()返回Date对象的分钟字段
Date.getMonth()返回Date对象的月份字段
Date.getSeconds()返回Date对象的秒字段
Date.getTime()返回Date对象的毫秒表示
Date.getTimezoneOffset()判断与GMT的时间差
Date.getUTCDate()返回该天是一个月的哪一天(世界时)
Date.getUTCDay()返回该天是星期几(世界时)
Date.getUTCFullYear()返回年份(世界时)
Date.getUTCHours()返回Date对象的小时字段(世界时)
Date.getUTCMilliseconds()返回Date对象的毫秒字段(世界时)
Date.getUTCMinutes()返回Date对象的分钟字段(世界时)
Date.getUTCMonth()返回Date对象的月份(世界时)
Date.getUTCSeconds()返回Date对象的秒字段(世界时)
Date.getYear()返回Date对象的年份字段(世界时)
Date.parse()解析日期/时间字符串Date.setDate()设置一个月的某一天
Date.setFullYear()设置年份，也可以设置月份和天
Date.setHours()设置Date对象的小时字段、分钟字段、秒字段和毫秒字段
Date.setMilliseconds()设置Date对象的毫秒字段
Date.setMinutes()设置Date对象的分钟字段和秒字段
Date.setMonth()设置Date对象的月份字段和天字段
Date.setSeconds()设置Date对象的秒字段和毫秒字段
Date.setTime()以毫秒设置Date对象
Date.setUTCDate()设置一个月中的某一天(世界时)
Date.setUTCFullYear()设置年份、月份和天(世界时)
Date.setUTCHours()设置Date对象的小时字段、分钟字段、秒字段和毫秒字段(世界时)
Date.setUTCMilliseconds()设置Date对象的毫秒字段(世界时)
Date.setUTCMinutes()设置Date对象的分钟字段和秒字段(世界时)
Date.setUTCMonth()设置Date对象的月份字段和天数字段(世界时)
Date.setUTCSeconds()设置Date对象的秒字段和毫秒字段(世界时)
Date.setYear()设置Date对象的年份字段
Date.toDateString()返回Date对象日期部分作为字符串
Date.toGMTString()将Date转换为世界时字符串
Date.toLocaleDateString()回Date对象的日期部分作为本地已格式化的字符串
Date.toLocaleString()将Date转换为本地已格式化的字符串
Date.toLocaleTimeString()返回Date对象的时间部分作为本地已格式化的字符串
Date.toString()将Date转换为字符串
Date.toTimeString()返回Date对象日期部分作为字符串
Date.toUTCString()将Date转换为字符串(世界时)
Date.UTC()将Date规范转换成毫秒数
Date.valueOf()将Date转换成毫秒表示'>史上最全、JavaScript基础篇</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>16-7-11 上午 12:00:00</span></li><li><span>2</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/0530C20B-5252-4E4A-9B69-EE48992FEBAC.html' title='!DOCTYPE html PUBLIC -//W3C//DTD XHTML 1.0 Transitional//EN http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtdhtml xmlns=http://www.w3.org/1999/xhtml  head    meta http-equiv=Content-Type content=text/html; charset=utf-8 /    titlejQuery页内查找关键词/title    meta name=keywords content=jQuery查找关键字,jQuery页内查找关键词 /    meta name=description content=本文介绍通过jQuery插件查找关键字，并高亮显示。当用户输入关键字点击“页内查找”按钮或按回车键时，jQuery通过正则匹配匹配关键字，将页面定位滚动到第一个匹配的位置，并显示相关信息。 /    link rel=stylesheet type=text/css href=http://www.sucaihuo.com/jquery/css/common.css /    style type=text/css      .demo{ font-size:14px}      .demo p{line-height:22px}      .demo p strong{color:#f30}      .highlight { background: yellow; color: red; }      .prelight { background: blue; color: white; }      #tip { background: #FFFFCC; border: 1px solid #999; width: 200px; text-align: center; display: none; font-size: 12px; }      #search_box { background: white; opacity: 0.8; text-align:right }      #search_button { background: #0f79be; margin-top: 6px; border-radius: 2px; border: 0px; width: 100px; line-height: 24px; color: white; }      #search_input { font-size: 14px; height: 20px; width:200px;border:1px solid #ccc;padding:2px 5px}    /style  /head  body    div class=container      h2 class=titlea href=http://www.sucaihuo.com/js/12.htmljQuery页内查找关键词/a/h2      div class=demo        div id=search_box          input id=search_input type=text size=10 name=search_input /　          input id=search_button type=button value=页内查找 /        /div        div id=content          p　　strong8：00 起售车站/strongbr /　　安阳、白城、北京西、成都东、大庆、大庆西、东莞、东莞东、惠州、金华南、缙云、九江、兰州、丽水、临汾、南充、齐齐哈尔、青田、日照、山海关、汕头、松原、温州、乌兰浩特、乌鲁木齐、武昌、武义、西安、永康、运城。/p          p　　strong9：00 起售车站/strongbr /　　阿克苏、宝鸡、北京北、茶陵、长兴南、成都、大同、德清西、海宁、苏州、无锡、南京、库尔勒、奎屯、昆明、拉萨、漠河、那曲、讷河、宁波、萍乡、上虞、绍兴、沈阳北、宜昌、宜昌东、宜春、余姚、湛江、郑州。/p          p　　strong9：30 起售车站/strongbr /　　深圳。/p          p　　strong10：00 起售车站/strongbr /　　阿拉山口、北京、北屯市、贵阳、哈密、哈密南、和田、霍尔果斯、喀什、柳园、南昌、库尔维特、青岛、青岛北、沈阳、伊宁。/p          p　　strong10：30 起售车站/strongbr /　　深圳东、深圳西。/p          p　　strong11：00/14：00起售车站（C、D字头列车11：00，G字头列车14：00）/strongbr /　　安亭北、安阳东、鞍山西、鳌江、鲅鱼圈、蚌埠南、宝华山、宝鸡南、保定东、北滘、北京南、碧江、滨海、滨海北、博鳌、沧州西、苍南、昌图西、长春西、长沙南、长兴、常州北、潮汕、潮阳、郴州西、赤壁北、滁州、丹徒、丹阳北、德惠西、德清、德州东、定远、定州东、东升、都江堰、防城港北、肥东、奉化、扶余北、福安、福鼎、福清、福州南、盖州西、高碑店东、高邑西、公主岭南、巩义南、古镇、光明城、广州南、哈尔滨西、海城西、海口东、海宁西、邯郸东、涵江、汉川、合肥北城、贺胜桥东、鹤壁东、横沟桥东、衡山西、衡阳东、红安西、红光镇、鲘门、湖州、虎门、花桥、华山北、淮南东、惠东、惠山、惠州南、济南西、嘉善南、嘉兴南、江门、江宁、角美、金山北、金寨、晋江、句容西、军粮城北、开原西、葵潭、昆山南、廊坊、乐清、耒阳西、离堆公园、溧水、溧阳、连江、临海、灵宝西、陵水、龙嘉、龙山镇、陆丰、滦河、罗源、洛阳龙门、漯河西、美兰、汨罗东、庙山、明港东、明珠、南湖东、南京南、南靖、南朗、南头、南翔北、宁德、宁海、彭州、郫县西、莆田、普安、普宁、普湾、戚墅堰、岐山、前山、青城山、清远、庆盛、琼海、曲阜东、泉州、饶平、容桂、瑞安、三门峡南、三门县、山坡东、汕尾、上海虹桥、上海西、上虞北、韶关、绍兴北、绅坊、深圳北、深圳坪山、渑池南、石龙、双城北、顺德、顺德学院、四平东、松江南、苏州北、苏州新区、苏州园区、宿州东、台州、太姥山、泰安、汤逊湖、唐家湾、滕州东、天津南、铁岭西、桐乡、土地堂东、瓦房店西、瓦屋山、万宁、渭南北、温岭、温州南、文昌、乌龙泉南、无锡东、无锡新区、武清、西安北、犀浦、霞浦、厦门北、仙林、咸宁北、咸宁东、咸宁南、咸阳秦都、小榄、孝感北、新会、新乡东、信阳东、邢台东、徐州东、许昌东、亚龙湾、雁荡山、阳澄湖、杨陵南、宜兴、英德西、迎宾路、营口东、永嘉、余杭、余姚北、岳阳东、云霄、枣庄、漳浦、樟木头、诏安、镇江南、正定机场、郑州东、枝江北、纸坊东、中山、中山北、株洲西、珠海、珠海北、驻马店西、庄桥、涿州东。/p          p　　strong12：00 起售车站/strongbr /　　广州。/p          p　　strong12：30 起售车站/strongbr /　　阿克陶、阿图什、巴楚、博乐、布列开、福海、格尔木、广元、汉口、和静、乌克兰、精河、精河南、克拉玛依、库车、轮台、玛纳斯湖、绵阳、墨玉、尼勒克、皮山、沙湾县、莎车、鄯善、石河子、疏勒、天津、吐鲁番、乌西、五五、新和、焉耆、叶城、伊宁东、英吉沙、泽普。/p          p　　strong13：00 起售车站/strongbr /　　安庆、安庆西、亳州、长春、长治北、巢湖、敦煌、阜南、阜阳、哈尔滨、汉中、合肥、淮南、黄梅、霍邱、济南、济南东、嘉峪关、六安、庐江、全椒、三堂集、石家庄、石家庄北、舒城、水家湖、宿松、太湖、太原、天柱山、桐城、乌海西、武汉、厦门、厦门高崎、叶集、重庆北。/p          p　　strong13：30 起售车站/strongbr /　　坂田、常平、潮州、春湾、大埔、丰顺、佛山、高州、广州北、广州东、和平、河源、华城、惠州西、揭阳、乐昌、雷州、龙川、茂名东、梅州、坪石、三水、韶关东、新兴县、信宜、兴宁、徐闻、阳春、英德、源潭、湛江西、肇庆。/p          p　　strong14：30 起售车站/strongbr /　　杭州、杭州东、江山、金华西、兰溪、龙游、衢州、义乌、诸暨。/p          p　　strong15：00 起售车站/strongbr /　　滨江、长沙、常德、达州、大理、德州、赣州、广水、哈尔滨东、海湾、邯郸、吉安、吉林、集宁南、嘉善、井冈山、昆山、丽江、芦潮港、麻城、内江、南宁、商丘、上海、上海南、十堰、松江、苏州、威海、无锡、西宁西、香坊、信阳、延安、昭通。/p          p　　strong16：00起售车站/strongbr /　　安康、佳木斯、罗平、威舍、新乡、银川、赤峰、大连、砀山、德令哈、东海县、福州、海石湾、密西西河、呼和浩特、呼和浩特东、黄口、湟源、潢川、乐都、连云港、连云港东、柳州、六盘水、洛阳、牡丹江、邳州、平安驿、平顶山、秦皇岛、唐山、通辽、夏邑县、新沂、徐州、烟台、榆林、虞城县、张家界、重庆、周口、驻马店、遵义。/p          p　　strong17：00 起售车站/strongbr /　　鞍山、常州、丹东、丹阳、抚顺北、阜新、菏泽、红果、晋城、景德镇、南京、盘锦、曲靖、上饶、神木、绥芬河、襄阳、襄阳东、宣威、鹰潭、镇江、中华门、白山市、包头、包头东、承德、东台、恩施、阜宁、桂林、桂林北、海安县、海拉尔、韩城、怀化、淮安、建湖、江都、姜堰、利川、临沂、龙岩、漯河、满洲里、南通、南阳、攀枝花、蕲春、如皋、邵阳、沭阳、泗洪、泗阳、泰州、通化、图们、西昌、延吉、盐城、扬州、洋河、永州、张家口、张家口南、栟茶、如东。/p          p　　strong18：00 起售车站/strongbr /　　阿城、阿尔山、阿金、阿里河、阿龙山、阿木尔、安达、安广、安化、安家、安口窑、安龙、安陆、安平、安顺、安塘、安图、安溪、昂昂溪、敖力布告、八达岭、八角台、八面城、八面通、八仙筒、巴东、巴林、巴山、巴彦高勒、巴中、霸州、白壁关、白河、白河东、白河县、白涧、白奎堡、白狼、白泉、白沙、白石山、白水江、白音察干、白音胡硕、白音他拉、白银市、白银西、白云鄂博、百色、柏果、蚌埠、宝坻、宝拉格、宝林、宝龙山、宝泉岭、保定、保康、北安、北戴河、北海、北京东、北流、北马圈子、北票南、北台、背荫河、贲红、本溪、本溪湖、笔架山、泊头、勃利、博克图、博山、博兴、布海、蔡家沟、蔡家坡、沧州、苍石、曹县、草海、草河口、草市、册亨、岑溪、查布嘎、察素齐、岔江、柴岗、柴沟堡、柴河、昌乐、昌黎、昌平、昌平北、昌图、长春南、长甸、长葛、长岭子、长山屯、长寿、长寿北、长汀、长汀、钟家村、钟祥、重庆南、周家、周家屯、周水子、朱家沟、朱日和、朱杨溪、株洲、诸城、竹园坝、卓资东、卓资山、涿州、资溪、资阳、资中、淄博、子长、子洲、紫阳、自贡、棕溪、邹城、柞水、广通北、禄丰南、昆阳。/p        /div        div id=tip/div      /div     /div    script type=text/javascript src=http://www.sucaihuo.com/Public/js/other/jquery.js/script    script type=text/javascript      (function($) {        $.fn.fixDiv = function(options) {          var defaultVal = {            top: 10          };          var obj = $.extend(defaultVal, options);          $this = this;          var _top = $this.offset().top;          var _left = $this.offset().left;          $(window).scroll(function() {            var _currentTop = $this.offset().top;            var _scrollTop = $(document).scrollTop();            if (_scrollTop  _top) {              $this.offset({                top: _scrollTop + obj.top,                left: _left              });            } else {              $this.offset({                top: _top,                left: _left              });            }          });          return $this;        };      })(jQuery);      $(function() {        $(#search_box).fixDiv({top: 0});        $(#search_button).click(highlight);//点击search时，执行highlight函数；        $(#search_input).keydown(function(e) {          var key = e.which; //enter提交          if (key == 13)            highlight();        })        var i = 0;        var sCurText;        function highlight() {          clearSelection();//先清空一下上次高亮显示的内容；          var flag = 0;          var bStart = true;          $(#tip).text();          $(#tip).hide();          var searchText = $(#search_input).val();          var _searchTop = $(#search_input).offset().top + 30;          var _searchLeft = $(#search_input).offset().left;          if ($.trim(searchText) == ) {            //alert(123);            showTips(请输入查找车站名, _searchTop, 3, _searchLeft);            return;          }          var searchText = $(#search_input).val();//获取你输入的关键字；          var regExp = new RegExp(searchText, g);//创建正则表达式，g表示全局的，如果不用g，则查找到第一个就不会继续向下查找了；          var content = $(#content).text();          if (!regExp.test(content)) {            showTips(没有找到要查找的车站, _searchTop, 3, _searchLeft);            return;          } else {            if (sCurText != searchText) {              i = 0;              sCurText = searchText;            }          }          $(p).each(function() {            var html = $(this).html();            var newHtml = html.replace(regExp, span class=highlight + searchText + /span);//将找到的关键字替换，加上highlight属性；            $(this).html(newHtml);//更新；            flag = 1;          });          if (flag == 1) {            if ($(.highlight).size()  1) {              var _top = $(.highlight).eq(i).offset().top + $(.highlight).eq(i).height();              var _tip = $(.highlight).eq(i).parent().find(strong).text();              if (_tip == )                _tip = $(.highlight).eq(i).parent().parent().find(strong).text();              var _left = $(.highlight).eq(i).offset().left;              var _tipWidth = $(#tip).width();              if (_left  $(document).width() - _tipWidth) {                _left = _left - _tipWidth;              }              $(#tip).html(_tip).show();              $(#tip).offset({top: _top, left: _left});              $(#search_button).val(查找下一个);            } else {              var _top = $(.highlight).offset().top + $(.highlight).height();              var _tip = $(.highlight).parent().find(strong).text();              var _left = $(.highlight).offset().left;              $(#tip).show();              $(#tip).html(_tip).offset({top: _top, left: _left});            }            $(html, body).animate({scrollTop: _top - 50});            i++;            if (i  $(.highlight).size() - 1) {              i = 0;            }          }        }        function clearSelection() {          $(p).each(function() {            //找到所有highlight属性的元素；            $(this).find(.highlight).each(function() {              $(this).replaceWith($(this).html());//将他们的属性去掉；            });          });        }        //mask        var tipsDiv = div class=tipsClass/div;        $(body).append(tipsDiv);        function showTips(tips, height, time, left) {          var windowWidth = document.documentElement.clientWidth;          $(.tipsClass).text(tips);          $(div.tipsClass).css({            top: height + px,            left: left + px,            position: absolute,            padding: 8px 6px,            background: #000000,            font-size: 14 + px,            font-weight: 900,            margin: 0 auto,            text-align: center,            width: auto,            color: #fff,            border-radius: 2px,            opacity: 0.8,            box-shadow: 0px 0px 10px #000,            -moz-box-shadow: 0px 0px 10px #000,            -webkit-box-shadow: 0px 0px 10px #000          }).show();          setTimeout(function() {            $(div.tipsClass).fadeOut();          }, (time * 1000));        }      })      /**/    /script  /body/html'>jQuery搜索查找关键词高亮显示源码</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>16-7-4 上午 12:00:00</span></li><li><span>3</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/3DC8783E-7BF4-4C38-8CAA-D4A9F3B0A837.html' title='js如何获取给定属性的属性值:在一些实际应用中需要取得给定属性的属性值，下面就简单介绍一下如何实现次效果。代码实例如下:!DOCTYPEhtmlhtmlheadmetacharset=utf-8metaname=authorcontent=http://www.softwhy.com//title蚂蚁部落/titlestyletype=text/css.bottom{  width:100px;  height:100px;  background-color:green;}/stylescripttype=text/javascriptwindow.onload=function(){  alert(document.getElementsByTagName(div)[0].getAttribute(class));  }/script/headbody  divclass=bottom/div/body/html以上代码可以获取div的class属性的属性值。上面的代码中使用了getAttribute()函数，此函数的参数是一个字符串，用来规定要获取值的属性名称。原文地址是:http://www.softwhy.com/forum.php?mod=viewthreadtid=6254更多内容可以参阅:http://www.softwhy.com/javascript/'>js如何获取给定属性的属性值</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>4</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/D10311E1-C1E0-4863-8256-E3EABA2AA270.html' title='显示系统时间--带有秒数span id=localtime/spanscript type=text/javascriptfunction showLocale(objD){var str,colorhead,colorfoot;var yy = objD.getYear();if(yy1900) yy = yy+1900;var MM = objD.getMonth()+1;if(MM10) MM = 0 + MM;var dd = objD.getDate();if(dd10) dd = 0 + dd;var hh = objD.getHours();if(hh10) hh = 0 + hh;var mm = objD.getMinutes();if(mm10) mm = 0 + mm;var ss = objD.getSeconds();if(ss10) ss = 0 + ss;var ww = objD.getDay();if ( ww==0 ) colorhead=font color=\#FF0000\;if ( ww  0  ww  6 ) colorhead=font color=\#373737\;if ( ww==6 ) colorhead=font color=\#008000\;if (ww==0) ww=星期日;if (ww==1) ww=星期一;if (ww==2) ww=星期二;if (ww==3) ww=星期三;if (ww==4) ww=星期四;if (ww==5) ww=星期五;if (ww==6) ww=星期六;colorfoot=/fontstr = colorhead + yy + - + MM + - + dd +   + hh + : + mm + : + ss +   + ww + colorfoot;return(str);}function tick(){var today;today = new Date();document.getElementById(localtime).innerHTML = showLocale(today);window.setTimeout(tick(), 1000);}tick();/script'>显示系统时间--带有秒数</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>5</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/DB429385-46F7-4045-9964-0CEB9B2F46FF.html' title='控制对话框风格的activity的显示大小与位置　　项目开发的需要，因为到现在项目接近完工，用户提出对条件筛选方式进行修改，为做到最小的改动实现用户的需求，各种百度，对于对话框风格大家普遍使用PopupWindow,但由于之前开发设计时使用的是activity对话框方式，所以今天就为大家介绍一下，如何通过activity实现与PopupWindow相同的效果，废话不多讲现在开始干货。　　实现对话框风格的activity，我们需要在AndroidManifest.xml添加一句样式声明：activity  　　android:name=.product.MyselfPayProduct  android:screenOrientation=portrait  android:theme=@android:style/Theme.Dialog　　不过这样的对话框风格往往无法满足我们的需要，显示的效果不那么令人满意，第一点就是如何控制对话框的大小：//窗口对齐屏幕宽度Windowwin=this.getWindow();  win.getDecorView().setPadding(0,0,0,0);  WindowManager.LayoutParamslp=win.getAttributes();  lp.width=WindowManager.LayoutParams.MATCH_PARENT;  lp.height=WindowManager.LayoutParams.WRAP_CONTENT;  lp.gravity=Gravity.TOP;//设置对话框置顶显示win.setAttributes(lp);　　将这个控制语句添加在我们的对话框activity的onClick()方法中，这样我们的对话框就可以宽度与屏幕一样宽了，lp.gravity = Gravity.TOP;//设置对话框置顶显示，android默认对话框居中显示，我们可以通过这句代码设置对话框的显示位置。　到这里是不是已经达到你的满意了呢？下面在给大家介绍一下，如何通过activity实现微信右上角点击加号的显示效果。做这个显示效果，我们需要通过在布局文件中通过android:layout_marginTop=50dp这样来调整对话框的位置，Android默认弹出框效果非常难看，为了达到更好的显示效果，我们这里添加一个显示的动画效果：进入动画：?xmlversion=1.0encoding=utf-8?  setxmlns:android=http://schemas.android.com/apk/res/android    scale  android:fromXScale=1.0  android:interpolator=@android:anim/accelerate_decelerate_interpolator  android:toXScale=1.0  android:fromYScale=0.0  android:toYScale=1.0  android:duration=200  android:pivotX=0  android:pivotY=10%  /    /set退出动画：?xmlversion=1.0encoding=utf-8?  setxmlns:android=http://schemas.android.com/apk/res/android    scale  android:fromXScale=1.0  android:interpolator=@android:anim/accelerate_decelerate_interpolator  android:toXScale=1.0  android:fromYScale=1.0  android:toYScale=0.0  android:duration=200  android:pivotX=0  android:pivotY=10%  /    /set　　android动画文件一般置于res的anim文件夹下，默认该文件夹不存在，需要我们手动添加。　　下面我们需要把我们的动画添加的android的样式文件：style.xmlresources    !--  Baseapplicationtheme,dependentonAPIlevel.Thisthemeisreplaced  byAppBaseThemefromres/values-vXX/styles.xmlonnewerdevices.--  stylename=AppBaseThemeparent=android:Theme.Light  !--  ThemecustomizationsavailableinnewerAPIlevelscangoin  res/values-vXX/styles.xml,whilecustomizationsrelatedto  backward-compatibilitycangohere.--  /style    !--Applicationtheme.--  stylename=AppThemeparent=AppBaseTheme  !--AllcustomizationsthatareNOTspecifictoaparticularAPI-levelcangohere.--    /style    !--没有标题--  stylename=notitleparent=AppBaseTheme  itemname=android:windowNoTitletrue/item  /style    !--类似对话框效果--  stylename=MyDialogTopRight  itemname=android:windowBackground@android:color/transparent/item  itemname=android:windowIsTranslucenttrue/item  itemname=android:windowNoTitletrue/item  itemname=android:windowAnimationStyle@style/Anim_scale/item  /style    stylename=Anim_scaleparent=@android:style/Animation.Activity  itemname=android:activityOpenEnterAnimation@anim/scale_in/item  itemname=android:activityOpenExitAnimation@anim/scale_out/item  itemname=android:activityCloseEnterAnimation@anim/scale_in/item  itemname=android:activityCloseExitAnimation@anim/scale_out/item  /style    /resources　　最后我们需要修改一下我们在AndroidManifest.xml文件中的声明：android:theme=@style/MyDialogTopRight　　到这里我们就完美实现了activity的对话框风格显示。'>控制对话框风格的activity的显示大小与位置</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>6</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/8098B745-6041-412B-80DA-0FDAFF329E41.html' title='Demo . 1//badif(age20){returntrue;  }else{returnfalse;  }//goodreturnage20;这种一看就明白吧，没什么说的。Demo . 2//badfor(vari=0;iarr.length;i++){//dosomething...}//goodfor(vari=0,len=arr.length;ilen;i++){//dosomething...}将数组的长度进行存储，循环时就不用每次去读取一次数组长度，从而提升性能Demo . 3//badif(value!==){//dosomething...}//goodif(value){//dosomething...}js中所有 非空字符 作布尔运算时，都会返回 true，反之返回 false。 （空格 属于非空字符）Demo . 4//badif(value!==0){//dosomething...}//goodif(value){//dosomething...}js中所有 非零 数字作布尔运算时，都会返回 true， 反之返回 false。Demo . 5//badif(user.id===10){if(user.name!==){if(user.email===email){//dosomething...}  }  }//goodif(user.id===10user.name!==user.email===email){//dosomething...}//goodif(user.id!==10)return;if(user.name===)return;if(user.email!==email)return;//dosomething...多层条件嵌套，进行 转换 或 拆分。Demo . 6//badvara=aa;varb=bb;varc=cc;vard;//goodvara=aa,  b=bb,  c=cc,  d;多个变量的定义，写一个 var 即可，遵循的原则：被赋值的在前面，只是进行声明放后面（d 在最后）Demo . 7//badfor(vari=0;i100;i++){  str+=str;  document.getElementById(box).innerHtml=str;  }//goodfor(vari=0;i100;i++){  str+=str;  }  document.getElementById(box).innerHtml=str;尽可能的减少DOM操作，将DOM操作放在循环体之外，数据处理好后，只执行一次DOM操作即可。Demo . 8//bad  functiontest(){vara=b=1;  console.log(a);  }//good  functiontest(){vara=1,  b=1;    console.log(a);  }避免使用 连等号 声明赋值变量。js基础好点的同学都知道，这里存在着一个坑： b 会被声明为全局变量，意思就是在 test() 方法之外b也是可以被访问到的。 全局变量是不推荐使用的，容易污染环境。Demo . 9//badif(age20){  console.log(年龄大于20);  }//good(age20)console.log(年龄大于20);这里的bad并不是说第一种写法不好，其实就可读性来说，第一种比第二种更好。 只是第二种写法更加优雅一点（个人觉得）。 这个句法可能有些同学用的比较少，解释一下：如果第一个条件为 true ,那么就执行后面的语句，第一个条件为false, 后面的语句便不会执行。后面的语句可以是表达式，方法，或变量，常量都可以。 比如 (age  20)  test()。用于赋值时的具体说明，如下图Demo . 10//badif(age20){  value=similar;//dosomething...}//goodif(age20(value=similar)){//dosomething...}这个可以说是Demo9的变体，代码可读性还是第一个比较好，当你采用第二种写法时，请配合注释使用。因为有些人可能会认为你这是书写失误，少写了一个 = ，从而他自行给你补上了（value == similar）。而你实际上是想做赋值操作的。因此你要写上注释说明，你这里不是书写失误，而是要进行赋值。注： 根据博友留言的帮助，此处应用需小心，当你为value赋值为空串 或 0 或 null 等等（也就是说，value作布尔运算返回值为 false）的时候，整个判断表达式会返回 false， 也就不会执行if花括号里面的代码程序。所以当你不确定 value 会被赋值为什么的时候，建议不要这样用。Demo . 11//badif(value===){  value=similar;  }//goodif(!value){  value=similar;  }//goodvalue=value||similar;这个和Demo9的  号运算正好相反，当第一个条件为 false 时，执行后面的语句。因为空字符串作布尔运算是返回 false的，所以可以这样用。Demo . 12//badi=i+1;  i=i-1;//goodi++;  i--;这个没什么好说的。Demo . 13//bad  if(typeofstr===String){    }//good  if(typeofstr===string){    }这里只是帮大家填个坑，不存在好坏。typeof 运算是用来检查数据类型的（常用来检查js中的基础类型），它返回的是一个字符串（并且始终为小写），所以第一个始终为false。 检查js中的引用类型要用 instanceof 运算， 如： var arr = []; if(arr instanceof Array){}, 但 Function 类型比较特别，也可以用 typeof 来进行判断。Demo . 14//(bad)格式化字符串fontSize=font-sizefunctionstringFormat(str){varstrArr=str.split(),  len=strArr.length,  i=0;for(;ilen;i++){if(/^[A-Z]$/.test(strArr[i])){  strArr[i]=-+strArr[i].toLowerCase();  }  }returnstrArr.join();  }//(good)格式化字符串fontSize=font-sizefunctionstringFormat(str){return(str.replace(/([a-z])(A-Z)/g,$1-$2)).toLowerCase();  }两个方法实现同样的功能，但第二个优雅得多，性能上也比第一个要好。当对字符串进行循环操作，如：查找、替换。 首先考虑的应该是使用 正则，不应该是循环遍历。Demo . 15//badfunctionregist(userName,userPwd,userEmail,userPhone){//dosomething...}//goodfunctionregist(user){//dosomething}当一个方法接收的参数过多的时候，可以考虑将其封装成一个json对象， 这样简单得多。Demo . 16vara=1,  b=1;//(bad)输出a等于bif(a==b){  console.log(a等于b);  }//(good)输出a不等于bif(a===b){  console.log(a等于b);  }else{  console.log(a不等于b);  }推荐使用 全等 判断，这样更准确。 字符串和数字并不是全等的。关于比较的一点说明：Demo . 17//badif(age20){  value=aa;  }else{  value=bb;  }//goodvalue=age20?aa:bb;目前只想到这么多，麻烦大家进行补充，感谢！'>JS代码的简单重构与优化（适合新手）</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>7</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/2F2493F4-753B-42F9-B95D-DAF9E7DD4796.html' title='部分面试知识点（web前端工程师）JavaScript的类型转换JavaScript是一种无类型语言，类型转换分为显式转换和隐式转换隐式转换通过运算符进行转换，在一些运算中，Javascript也会进行自动类型转换显式转换通过手动进行类型转换，Javascript提供了以下转型函数：转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)转换为字符串类型：toString(radix)、String(mix)转换为布尔类型：Boolean(mix)JavaScript的原型与继承Js所有的函数都有一个prototype属性，这个属性引用了一个对象，简称原型，javascript中的继承是通过原型链来体现的，访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。B.prototype = new A();，此时B.prototype.constructor就是构造对象A，随后使用B.prototype.constructor = B;将B原型的构造器重新指向B构造函数在进行原型继承后，要进行修正操作。JavaScript的闭包闭包函数类似于Java等OO语言中的getter和setter函数，即因为变量作用域的原因，在函数外部无法读取函数内的局部变量。闭包就是能够读取其他函数内部变量的函数。父对象的所有变量，对子对象都是可见的，反之则不成立。闭包就是将函数内部和函数外部连接起来的一座桥梁。由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。HTTP中Get和Postget是从服务器上获取数据，post是向服务器传送数据。GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用连接。POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。即GET请求的数据会暴露在地址栏中，而POST请求则不会。对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。数据量不能大于2KB对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，理论上，IIS4中最大量为80KB，IIS5中为100KB。POST的安全性比GET的高。在FORM提交的时候，如果不指定Method，则默认为GET。JavaScript事件绑定IE的attachEvent()elemObject.attachEvent(eventName,functionReference);eventName参数的值是表示事件名称的字符串，比如onclick（含on）。functionReference参数是一个不带括号的函数引用W3C DOM 的addEventListener()nodeReference.addEventListener(eventType, listenerReference, captureFlag);用 W3C DOM 规范中的行话来说，addEventListener()方法为指定的结点注册了一个事件，表示该结点希望处理相应的事件。第一个参数是一个声明事件类型的字符串，比如click，mousedown。（不含on）第二个参数可以和早些时候描述过的函数引用同样对待。第三个参数则是一个Boolean值，指明该结点是否以DOM中的捕捉模式来侦听事件。JavaSciprt事件冒泡以及目标元素。事件冒泡: 当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。目标元素: 任何一个事件的目标元素都是最开始的那个元素，并且它在我们的元素对象中以属性的形式出现。使用事件代理的话我们可以把事件处理器添加到一个元素上，等待一个事件从它的子级元素里冒泡上来，并且可以很方便地得知这个事件是从哪个元素开始的。JavaScript图片轮播1.全局变量等定义初始index，图片总数2.自动切换定时器处理设置自动切换时间，自动切换后修改index3.为左右箭头添加事件处理滑入清除定时器，滑出则重置定时器，根据curIndex进行上/下一个图片处理4.为右下角的li 按钮绑定事件处理用css来隐藏img，用siblings而不是先hide全部在fadein，使用siblings来处理这样的情况速度会比较快。简单来讲siblings就是除开当前显示的这个以外的所有统计图片全部fadeOutJavaScript网页前进和后退的代码前进: history.forward();=history.go(1);后退: history.back();=history.go(-1);cookie和session的区别1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。CSS优先级法则1.、 选择器都有一个权值，权值越大越优先，当权值相等时，后出现的样式表设置要优于先出现的样式表设置；2、 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；3、继承的CSS 样式不如后来指定的CSS 样式，在同一组属性设置中标有“!important”规则的优先级最大CSS选择器浏览器兼容性问题javascript兼容性问题1、在标准的事件绑定中绑定事件的方法函数为 addEventListener,而IE使用的是attachEvent2、事件处理中非常有用的event属性获得亦不相同，标准浏览器是作为参数带人，而ie是window.event方式获得，获得目标元素ie为e.srcElement 标准浏览器为e.target3、然后在ie中是不能操作tr的innerHtml4、然后ie日期函数处理与其它浏览器不大一致，比如： var year= new Date().getYear(); 在IE中会获得当前年，但是在firefox中则会获得当前年与1900的差值。5、获得DOM节点的方法有所差异，其获得子节点方法不一致。css兼容性问题1、不同浏览器的标签默认的外补丁和内补丁不同，解决方案：用通配符*来设置各个标签的内外补丁是0。2、div的垂直居中问题 vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字3、margin加倍的问题 设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上 display:inline;Ajax是什么ajax是异步的 JavaScript 和 XML。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。Ajax的交互模型1--启动 获取XMlHttpRequest对象2--open 打开url通道，并设置异步传输3--send 发送数据到服务器4--服务器接受数据并处理，处理完成后返回结果5--客户端接收服务器端返回同步和异步的区别同步：脚本会停留并等待服务器发送回复然后再继续异步：脚本允许页面继续其进程并处理可能的回复Ajax跨域的解决方法如果在A网站中，我们希望使用Ajax来获得B网站中的特定内容，如果A网站与B网站不在同一个域中，那么就出现了跨域访问问题。IE对于跨域访问的处理是，弹出警告框，提醒用户。如果用户将该网站纳入可信任网站，或者调低安全级别，那么这个问题IE就不会在提醒你。FireFox等其它非微软的浏览器遇到跨域访问，则解决方案统一是拒绝访问几个可行的方案：1、Web代理的方式。2、on-Demand方式3、iframe方式。4、用户本地转储方式什么是PHP超级文本预处理语言 Hypertext PreProcessor，是一种用来开发动态网站的服务器端脚本语言。PHP字符串翻转echo strrev($a);PHP支持多继承吗？不支持。PHP中只允许单继承，父类可以被一个子类用关键字“extends”继承。echo(),print(),print_r()的区别echo是PHP语句, print和print_r是函数,语句没有返回值,函数可以有返回值echo输出一个或者多个字符串print()只能打印出简单类型变量的值(如int,string)print_r() 可以打印出复杂类型变量的值(如数组,对象)在PHP中如何定义常量?褂胐efine()来定义常量，比如define(“Newconstant”,30);语句include和require的区别，如何避免多次包含同一文件require是无条件包含，也就是如果一个流程里加入require,无论条件成立与否都会先执行requireinclude有返回值，而require没有(可能因为如此require的速度比include快)包含文件不存在或者语法错误的时候require是致命的,include不是使用require_once() 和include_once()可以避免多次包含同一文件以避免函数重定义，变量重新赋值等问题。返回值和include() 相同。如果文件已被包含，本函数返回 TRUE。HTTP协议1.0及1.1的区别，并简单说下HTTP协议HTTP，超文本传输协议。它定义了浏览器和服务器的通信规则。HTTP协议是基于TCP/IP的TCP协议上，现在万维网使用的是HTTP1.1版本，其特点包括，C/S模式，请求简单(GET/POST/HEAD),灵活(可以传输任何类型的数据HTML、XML、JSON、自定义等)，无连接(每次连接只处理一个请求，从发出请求到收到200状态为止断开连接)，无状态。HTTP协议主要包括，响应消息格式、请求消息格式、状态码知识点。什么是MVC？MVC，即Model（数据层），View（视图层），Controller（控制层）。PHP中的MVC模型是一种有效将代码分成三层的管理办法，Model表示着应用中的数据信息View负责将应用中的数据信息展现出来Controller控制着如何将数据信息读出。Spring MVC工作原理1. 客户端请求提交到DispatcherServlet2. 由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller3. DispatcherServlet将请求提交到Controller4. Controller调用业务逻辑处理后，返回ModelAndView5. DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图6. 视图负责将结果显示到客户端为什么要用Spring1、Spring能很好的与各大框架进行集成2、创建对象时，如果我们不用spring需要用工厂模式来创建，这个spring相当于工厂模式已经帮我们做了创建对象的功能(IOC、依赖注入)。3、在用Hibernate的时候，如果不用spring每次都要写事务的提交代码，有了spring可以通过AOP帮助我们管理事务4、面向切面编程（AOP）在要记录日志的时候添加一条记录后需要在数据里同时添加一条添加成功了或失败的记录，那么就可以用Spring的Aop来处理，虽然不用Aop也能做但是不用Spring的Aop就会写很多重复的代码。Spring中的IOC和AOPIOC依赖注入，即用接口编程，在程序中不出现new关键字，用接口来命名引用，然后通过某种方式把接口的某个实现类的实例注入到引用里，从而实现接口与具体实现类的松耦合。AOP面向方面的编程，即，是一种编程技术，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP的核心构造是方面，它将那些影响多个类的行为封装到可重用的模块中。Spring bean生命周期实例化——填充属性——调用BeanNameAware的setBeanName()方法调用BeanFactoryAware的setBeanFactory()方法调用ApplicationContextAwar的setApplicationContext()方法调用BeanPostprocessore的预初始化方法调用InitialzingBean的afterPropertiesSet()方法调用定制的初始化方法——调用Beanprocessors的后初始化方法——bean可以使用——容器关闭——调用DisposableBean的destroy()方法——调用定制的销毁方法——结束1.BeanFactoyPostProcessor实例化2.Bean实例化，然后通过某些BeanFactoyPostProcessor来进行依赖注入3.BeanPostProcessor的调用.Spring内置的BeanPostProcessor负责调用Bean实现的接口: BeanNameAware, BeanFactoryAware, ApplicationContextAware等等，等这些内置的BeanPostProcessor调用完后才会调用自己配置的BeanPostProcessor4.Bean销毁阶段SSH整合SSH：Struts（表示层）+Hibernate（持久层）+Spring（业务层）Struts是一个表示层框架，主要作用是界面展示，接收请求，分发请求。Hibernate是一个持久层框架，它只负责与关系数据库的操作。Spring是一个业务层框架，是一个整合的框架，能够很好地黏合表示层与持久层。Spring的事务管理事务就是对一系列的数据库操作进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能。数据库连接池开源数据库连接池主要有c3p0、dbcp、proxool三种DBCP是Apache上的一个 java连接池项目，也是 tomcat使用的连接池组件。由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。dbcp没有自动的去回收空闲连接的功能。各种排序算法的比较二叉树1.在二叉树的第I层上至多有2i-1个结点。2.深度为k的二叉树至多有2k-1个结点(k=1)3.在任意一个二叉树中，度为0的结点总是比度为2的结点多一个；4.具有n 个结点的二叉树，其深度至少为[log2n]+1。B树平衡多路查找树1.所有非叶子结点至多拥有两个儿子（Left和Right）；2.所有结点存储一个关键字；3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；4.所有的叶子结点都位于同一层。搜索：从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子Dijkstra算法在无向图G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短值。把顶点集合V分成两组：1.S：已求出的顶点的集合（初始时只含有源点V0）2.V-S=T：尚未确定的顶点集合将T中顶点按递增的次序加入到S中，保证：1.从源点V0到S中其他各顶点的长度都不大于从V0到T中任何顶点的最短路径长度2.每个顶点对应一个距离值'>部分面试知识点（web前端工程师）</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>8</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/E8B94505-8C84-441F-8F2D-ECDB111D2D72.html' title='前置：　　引入jQuery、bootstrap、bootstrapValidator　　问题描述：　　项目中要求所有的表单输入框中都不能输入符号。没有在bootstrap中找到有方法可用，只能自己动手了　　思路：　　使用正则。　　分两种情况，第一种，如果输入框有自身的正则验证则不用去管（一般来说使用正则验证是严格控制输入的）；第二种，如果没有正则则需要添加不能输入的正则。　　需要重载bootstrapValidator初始化函数，根据上面的两种情况修正初始化的设置项。最后要恢复原来的bootstrapValidator函数（这一步是必须的，原来的bootstrapValidator函数有自己的一大堆关联的东东，不能丢失）；　　实现：overwrite==　　　　$.fn.bootstrapValidator=validtor=overwrite.apply(($.type(arguments[])==vtor=.data(=.find().not((!vtor.getOptions($().attr(),,).attr(/^[^]*$/'>jQuery 实现bootstrapValidator下的全局验证</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>9</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/AB319D46-0FD3-4202-8862-271487380F85.html' title='js正则验证url格式function checkURL(URL){var str=URL;//判断URL地址的正则表达式为:http(s)?://([\w-]+\.)+[\w-]+(/[\w- ./?%=]*)?//下面的代码中应用了转义字符\输出一个字符/var Expression=/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%=]*)?/;var objExp=new RegExp(Expression);if(objExp.test(str)==true){return true;}else{return false;}}'>js正则验证url格式</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>10</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/F3E92D09-FB3A-4939-8962-F9174E7A0916.html' title='点击鼠标清除文本框中的内容:一般内容型的网站都有搜索功能，在默认状态下搜索框中都有默认的提示文本，例如“请输入要搜索的关键词”，但当搜索框获得焦点的时候，默认的提示文本内容会被清空，下面就简单介绍以下如何实现此功能，代码实例如下:!!DOCTYPEhtmlhtmlheadmetacharset=utf-8metaname=authorcontent=http://www.softwhy.com//title蚂蚁部落/titlestyletype=text/cssinput{  width:150px;}/stylescripttype=text/javascriptwindow.onload=function(){varsousuo=document.getElementById(sousuo);  sousuo.onfocus=function(){  sousuo.value=;  }  sousuo.onblur=function(){  sousuo.value=请输入要搜索的关键词;  }  }/script/headbodyinputtype=textname=sousuoid=sousuovalue=请输入要搜索的关键词//body/html以上代码实现了我们想要的功能，当文本框获得焦点的时候，提示文本会被清空，当失去焦点的时候，提示文本又会自动添加。下面简单介绍一下如何实现此效果:分别文本框分别绑定focus和blur事件处理函数，规定当文本框获得焦点和失去焦点时对文本value属性的处理情况。'>点击鼠标清除文本框中的内容</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>11</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/FBA9A406-D463-4472-99A0-18D1791F3DDC.html' title='varkeywords=[阿扁推翻,阿宾,阿賓];$(input[type=text]).live(blur,function(){_filter_method($(this));});$(textarea).live(blur,function(){_filter_method($(this));});function_filter_method(obj){//获取文本输入框中的内容 varvalue=$(obj).val();//遍历敏感词数组 for(vari=0;ikeywords.length;i++){//全局替换 varreg=newRegExp(keywords[i],g);//判断内容中是否包括敏感词 if(value.indexOf(keywords[i])!=-1){varresult=value.replace(reg,**);value=result;$(obj).val(result);}}} '>web前端js过滤敏感词</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>12</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/DA5E7638-1C05-4D2D-BB44-198DABE310E3.html' title='HighchartsJS去除Highcharts.com链接的方法1.Highcharts JS去除Highcharts.com链接的方法在js文件中找到Credits，然后把enable的属性从!0改为0。也可以更改为自己需要的：enabled:设置是否显示链接text：设置链接显示的名称href：设置链接的url2.去掉图片右上角的打印及导出按钮在js中设置以下代码：exporting:{enabled:true //用来设置是否显示‘打印’,导出等功能按钮，不设置时默认为显示},3.Highcharts JS去除打印功能exporting.js 图表库去掉 以下代码printButton : {symbol :printIcon,x :-36,symbolFill :#B5C9DF,hoverSymbolFill :#779ABF,_titleKey :printButtonTitle,onclick : function() {this.print()}}'>Highcharts JS去除Highcharts.com链接的方法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>13</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/ED3B41E1-EA3D-436F-8262-844F003F40F3.html' title='asp.net后台注册js的四种方法1. 用Response.Write方法　　代码如下：　　Response.Write(script type=text/javascriptalert(keleyi.com);/script);　　此方法缺陷就是不能调用脚本文件中的自定义的函数，只能调用内部函数，具体调用自定义的函数只能在Response.Write写上函数定 义，比如　　Response.Write(script type=text/javascriptfunction myfun(){}/script);2.用ClientScript类　　代码如下：在想调用某个javascript脚本函数的地方添加代码，注意要保证MyFun已经在脚本文件中定义过了。　　ClientScript.RegisterStartupScript(ClientScript.GetType(), myscript, scriptMyFun();/script);　　这个方法比Response.Write更方便一些，可以直接调用脚本文件中的自定义函数。3.普通的添加控件的Attributes属性　　对于普通按钮就是：Button1.Attributes.Add(onclick,MyFun(););　　只能在Onload中或类似于onload的初始化过程中添加才有效。而且是先执行脚本函数，无法改变执行顺序。注意，以上所有方法中，后台代码都不能有转化当前页的代码，比如Redirect等，要把转页代码放在脚本里面4.?筇釉厥葑魑猨s参数调用js方法 num 是方法注册名， 每调用一次， 注册名不能一样 int num = 0; foreach (RoadStation rr in r) { num++; ScriptManager.RegisterStartupScript(this,this.GetType(), num.ToString(), string.Format(addTr({0},{1});, rr.F_stationName, rr.F_time), true); }'>asp.net后台注册js的四种方法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>14</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/2355A909-1282-47EC-AF2D-2C6317B8520C.html' title='查看效果：http://hovertree.com/texiao/js/snow.htm以下是完整源代码，保存到HTML文件也可以看效果：!DOCTYPEhtmlhtmlheadmetahttp-equiv=Content-Typecontent=text/html;charset=utf-8/title下雪了，我们去堆雪人好吗？-何问起/titlebasetarget=_blank/linkhref=http://hovertree.com/texiao/js/7/hovertreesnow.csstype=text/cssrel=stylesheet/metacharset=utf-8//headbodydivid=hovertreesnowdivclass=hovertreeheadbr/br/下雪了，我们去堆雪人好吗？/divdivclass=hovertreesnowimgid=hewenqisrc=http://hovertree.com/texiao/js/7/hovertreesnow.jpgart=何问起雪人//divdivclass=hovertreefootaudiosrc=http://cms.hovertree.com/hovertreesound/hovertreesnow.mp3autoplay=autoplaycontrols=controlsbr/您的浏览器不支持播放音乐。请用支持html5的浏览器打开,例如chrome或火狐或者新版IE等。br/何问起hovertree.combr//audiobr/ahref=http://hovertree.com首页/aahref=http://hovertree.com/hvtart/bjae/79mtsd1t.htm原文/aahref=http://hovertree.com/texiao/特效/a/div/divscripttype=text/javascriptsrc=http://hovertree.com/texiao/js/7/hovertreesnow.js/script/body/html'>雪花飘落HTML5特效</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>15</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/1A8BD015-D620-4B26-B8FF-74964676D5A2.html' title='排序图解：js排序算法实现之前写过js实现数组去重， 今天继续研究数组：排序算法实现。 排序是数据结构主要内容，并不限于语言主要在于思想；大学曾经用C语言研究过一段时间的排序实现， 这段时间有空用JS再将排序知识点熟悉一遍。理解排序不得不提的是日本人实现的一个排序动画站， 该站对于研究排序大有益处。当然本文的排序算法并不与其一致， 本文是9种js排序实现的实践与完善： 理解其9种算法然后使每种算法代码均能正常运行。1.插入排序最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多；原理图：代码：//插入排序从下标1开始每增1项排序一次，越往后遍历次数越多functionsort1(array){varlen=array.length,  i,j,tmp,result;  //设置数组副本  result=array.slice(0);for(i=1;ilen;i++){  tmp=result[i];  j=i-1;while(j=0tmpresult[j]){  result[j+1]=result[j];  j--;  }  result[j+1]=tmp;  }returnresult;  }2.二分插入排序插入排序的一种优化实现， 通过二分法减少遍历时间。原理图：代码：//先在有序区通过二分查找的方法找到移动元素的起始位置，//然后通过这个起始位置将后面所有的元素后移functionsort2(array){varlen=array.length,  i,j,tmp,low,high,mid,result;//赋予数组副本  result=array.slice(0);for(i=1;ilen;i++){  tmp=result[i];  low=0;  high=i-1;while(low=high){  mid=parseInt((low+high)/2,10);if(tmpresult[mid])high=mid-1;elselow=mid+1;  }for(j=i-1;j=high+1;j--){  result[j+1]=result[j];  }  result[j+1]=tmp;  }returnresult;  }3.希尔排序其排序思路有点复杂， 需花多点时间理解；排序思路：先将整个待排序记录序列分割成若干个子序列，在序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。原理图：代码：//希尔排序：先将整个待排序记录序列分割成若干个子序列//在序列内分别进行直接插入排序，待整个序列基本有序时，//再对全体记录进行一次直接插入排序functionsort3(array){varlen=array.length,gap=parseInt(len/2),  i,j,tmp,result;//复制数组  result=array.slice(0);while(gap0){for(i=gap;ilen;i++){  tmp=result[i];  j=i-gap;while(j=0tmpresult[j]){  result[j+gap]=result[j];  j=j-gap;  }  result[j+gap]=tmp;  }  gap=parseInt(gap/2);}returnresult;  }4.冒泡排序很常见很容易理解的排序算法， 排序思路：遍历数组，每次遍历就将最大（或最小）值推至最前。越往后遍历查询次数越少， 跟插入排序刚好相反。原理图：代码：//冒泡排序每次将最小元素推至最前functionsort4(array){varlen=array.length,  i,j,tmp,result;  result=array.slice(0);for(i=0;ilen;i++){for(j=len-1;ji;j--){if(result[j]result[j-1]){  tmp=result[j-1];  result[j-1]=result[j];  result[j]=tmp;  }  }  }returnresult;  }5.改进冒泡排序对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。原理图：代码：//如果在某次的排序中没有出现交换的情况，//那么说明在无序的元素现在已经是有序了，就可以直接返回了。functionsort5(array){varlen=array.length,  i,j,tmp,exchange,result;    result=array.slice(0);for(i=0;ilen;i++){  exchange=0;for(j=len-1;ji;j--){if(result[j]result[j-1]){  tmp=result[j];  result[j]=result[j-1];  result[j-1]=tmp;  exchange=1;  }  }if(!exchange)returnresult;  }returnresult;  }6.快速排序快速排序在诸多算法排序中可能不是最好的， 但个人认为在JS语言实现中是最快的！以前公司项目中对比过二分插入排序、优化冒泡排序、快速排序的JS实现执行时间，几千条数据的数组在firefox下快速排序的速度比冒泡、插入排序快3至4秒（数组元素为复杂的对象，根据对象某一属性值排序）。阮一峰老师研究JS实现排序时曾只针对该种排序进行讲解：javascript的快速排序实现。原理图：代码：//（1）在数据集之中，选择一个元素作为基准（pivot）。//（2）所有小于基准的元素，都移到基准的左边；所有大于基准的元素，都移到基准的右边。//（3）对基准左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。functionsort6(array){vartmp_array=array.slice(0),result,  quickSort=function(arr){  　　if(arr.length=1){returnarr;}  　　varpivotIndex=Math.floor(arr.length/2);  　　varpivot=arr.splice(pivotIndex,1)[0];  　　varleft=[];  　　varright=[];  　　for(vari=0;iarr.length;i++){  　　　　if(arr[i]pivot){  　　　　　　left.push(arr[i]);  　　　　}else{  　　　　　　right.push(arr[i]);  　　　　}  　　}  　　returnquickSort(left).concat([pivot],quickSort(right));  };  result=quickSort(tmp_array);returnresult;  }7.选择排序实现思路跟冒泡排序差不多， 可以说是冒泡排序的衍生版本；原理图：代码：//在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。//原理跟冒泡排序一样，算是冒泡的衍生版本functionsort7(array){varlen=array.length,  i,j,k,tmp,result;    result=array.slice(0);for(i=0;ilen;i++){  k=i;for(j=i+1;jlen;j++){if(result[j]result[k])k=j;  }if(k!=i){  tmp=result[k];  result[k]=result[i];  result[i]=tmp;  }  }returnresult;  }8.堆排序因为js模拟二叉树比较麻烦，所以堆排序的优势用js语言无法体现， 相对而言C语言的链表在实现上更能表现堆排序，堆排序或许更适合指针类的计算机语言。本文注重图解各排序的基本思路，所以该排序的具体实现没讲太细， 如想深究实现细节请看：堆排序及其分析。原理图：1.调整二叉树，形成大根堆(子节点都比父节点小)。2.交换堆第一元素跟最后元素位置，最后元素弹出堆。然后继续回到1，调整堆。3.重复2， 当所有节点弹出堆后；弹出的节点值就是有序的了。代码：//1)初始堆：将原始数组调整成大根堆的方法——筛选算法:子节点都比父节点小//2)堆排序：每次将堆顶元素与数组最后面的且没有被置换的元素互换。//参考代码：http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/functionsort8(array){varresult=array.slice(0);functionswap(array,i,j){vartemp=array[i];  array[i]=array[j];  array[j]=temp;  }functionmaxHeapify(array,index,heapSize){variMax,iLeft,iRight;while(true){  iMax=index;  iLeft=2*index+1;  iRight=2*(index+1);if(iLeftheapSizearray[index]array[iLeft]){  iMax=iLeft;  }if(iRightheapSizearray[iMax]array[iRight]){  &nbs'>排序图解：js排序算法实现</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>16</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/4ABD7AFF-6229-4994-B24E-618A367B4FF4.html' title='JS获取当前对象大小以及屏幕分辨率等scripttype=text/javascriptfunctiongetInfo(){vars=;s+=网页可见区域宽：+document.body.clientWidth+\n;s+=网页可见区域高：+document.body.clientHeight+\n;s+=网页可见区域宽：+document.body.offsetWidth+(包括边线和滚动条的宽)+\n;s+=网页可见区域高：+document.body.offsetHeight+(包括边线的宽)+\n;s+=网页正文全文宽：+document.body.scrollWidth+\n;s+=网页正文全文高：+document.body.scrollHeight+\n;s+=网页被卷去的高(ff)：+document.body.scrollTop+\n;s+=网页被卷去的高(ie)：+document.documentElement.scrollTop+\n;s+=网页被卷去的左：+document.body.scrollLeft+\n;s+=网页正文部分上：+window.screenTop+\n;s+=网页正文部分左：+window.screenLeft+\n;s+=屏幕分辨率的高：+window.screen.height+\n;s+=屏幕分辨率的宽：+window.screen.width+\n;s+=屏幕可用工作区高度：+window.screen.availHeight+\n;s+=屏幕可用工作区宽度：+window.screen.availWidth+\n;s+=你的屏幕设置是+window.screen.colorDepth+位彩色+\n;s+=你的屏幕设置+window.screen.deviceXDPI+像素/英寸+\n;alert(s);}getInfo();/script'>JS获取当前对象大小以及屏幕分辨率等</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>17</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/2CA58811-867F-4675-A310-551B0BE04FCF.html' title='如何禁止向文本框黏贴内容只能键盘输入:在某些情况下需要限制文本框内容的输入方式来达到一些特殊的效果，比如用户注册的时候，一般需要输入两次密码，以确保输入正确，这个时候可能有些用户会采用复制黏贴这种偷工减料的方式，极有可能导致注册密码并非自己预期密码。这个时候限制复制黏贴就非常的重要了，下面直接给出代码实例:!DOCTYPEhtmlhtmlheadmetacharset=utf-8metaname=authorcontent=http://www.softwhy.com//title蚂蚁部落/title/headbodyinputtype=textonpaste=returnfalseoncontextmenu=returnfalseoncopy=returnfalseoncut=returnfalse//body/html以上代码实现了我们想要的功能，只能通过键盘输入内容，复制黏贴是不允许的。'>如何禁止向文本框黏贴内容只能键盘输入</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>18</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/E00432B1-048D-442A-B002-591BDC68B8FC.html' title='getElementsByClassName()用法详解:在编程中，我们习惯于使用以下方式获取对象:getElementById(id)  getElementsByName(name)  getElementsByTagName(tag)第一个可以获取指定id值的对象，第二个可以获取具有指定name属性值的对象集合，第三个则是获取指定标签名称的对象集合。这三种方式在编写代码中非常的常用，当然也非常的便利，这个时候可能很多朋友就有这样的以为，class属性作为标签的常用属性，有没有一个方法能够通过制定的class属性值获取对象，其实这样的方法并非没有：getElementsByTagName(class)此方法实现了我们想要的功能，它可以获取具有指定class属性值的对象集合，但是令人遗憾的是具有浏览器兼容问题。代码实例如下:!DOCTYPEhtmlhtmlheadmetacharset=utf-8metaname=authorcontent=http://www.softwhy.com//titlegetElementsByClassName()用法详解-蚂蚁部落/titlescripttype=text/javascriptwindow.onload=function(){  document.getElementsByClassName(mytest)[0].style.color=#F00;  }/script/head  body  divclass=mytest大家好/div/body/html以上代码可以在谷歌、火狐和IE8以上的浏览器中完美运行，但是IE8和IE8以下的浏览器不支持此函数。虽然在将来低版本的IE浏览器退出市场之后，此函数肯定会意气风发，当前来说还是最好不要直接使用此函数，不过我们可以模拟实现此函数。代码实例如下:!DOCTYPEhtmlhtmlheadmetacharset=utf-8metaname=authorcontent=http://www.softwhy.com//titlegetElementsByClassName()用法详解-蚂蚁部落/titlescripttype=text/javascriptvargetElementsByClass=function(searchClass,node,tag){varclassElements=newArray();if(node==null){  node=document;  }if(tag==null){  tag=*;  }varels=node.getElementsByTagName(tag);varelsLen=els.length;varpattern=newRegExp((^|\\s)+searchClass+(\\s|$));for(i=0,j=0;ielsLen;i++){if(pattern.test(els[i].className)){  classElements[j]=els[i];  j++;  }  }returnclassElements;  }  window.onload=function(){  getElementsByClass(haha)[0].style.color=#F00;  }/script/headbody  divclass=mytesthaha大家好/div/body/html以上代码模拟实现了getElementsByClassName()功能，下面简单介绍一下如何实现此功能:一.实现原理:通过getElementsByTagName()函数获取相应的对象集合，然后再使用for循环语句来遍历每一个对象，并使用pattern.test()检测对象的className属性值是否含有正则表达式所匹配的内容，如果有则说明对象的具有指定的class属性值，并将此对象存储在classElements数组中，最后返回此数组，此数组中的元素即是具有指定class属性值的对象。二.代码注释:1.var classElements=new Array()，创建一个数组用来存放具有指定class属性值的对象。2.if(node==null)，判断是否指定了节点，如果没有则使用document作为默认节点。指定了getElementsByTagName()的查找范围。3.if(tag==null)，判断是否指定了标签名称，如果没有则使用通配符（*），也就是获取所有的标签。4.var els=node.getElementsByTagName(tag)，获取指定节点下具有指定标签名称的对象。5.var elsLen=els.length，获取对象的数量。6.var pattern=new RegExp((^|\\s)+searchClass+(\\s|$))，创建一个正则对象，规定如何检索具有给定class属性值的对象。这里需要具有一定的正则表达式知识。之所以使用以上规则就是为兼容class=mytest haha这种形式的class属性值和防止一个class属性值中包含有要检索的class属性值被匹配的情况，例如，一个class=haorenyisheng ，另一个class=hao，如果要检索hao，这样haorenyisheng就不会被匹配了。7.for循环用来执行便利每一个对象的className属性值（即class属性值），并检测是否符合匹配规则，如果符合则将此对象存入classElements数组。8.return classElements，返回数组对象，即具有指定class属性值的对象。9.getElementsByClass(haha)[0].style.color=#F00，设置class属性值为haha的对象中字体颜色为#F00。原文地址是:http://www.softwhy.com/forum.php?mod=viewthreadtid=6256更多内容可以参阅:http://www.softwhy.com/javascript/'>getElementsByClassName()用法详解</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>19</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/F0B79CA4-4949-4DC6-AC60-63CA23B7BCBB.html' title='JavaScript中为什么string可以拥有方法？所有文章搬运自我的个人主页：sheilasun.me引子我们都知道，JavaScript数据类型分两大类，基本类型（或者称原始类型）和引用类型。基本类型的值是保存在栈内存中的简单数据段，它们是按值访问的。JS中有五种基本类型：Undefined、Null、Boolean、Number和String。引用类型的值是保存在堆内存中的对象，它的值是按引用访问的。引用类型主要有Object、Array、Function、RegExp、Date。对象是拥有属性和方法的，所以我们看到下面这段代码一点也不奇怪.varfavs=[鸡蛋,莲蓬];  favs.push(秋葵);  console.log(favs);//[鸡蛋,莲蓬,秋葵]  console.log(favs.length);//3Array是引用类型，所以它自然可以拥有属性(length)和方法(push)，这天经地义地就像夏天一定要吃冰淇淋一样。但是，再看下面的代码，仔细想想，这这这，合法吗？varrealMessage=SaidIloveyoubutIlied;  varmyMessage=realMessage.substring(5,15);  console.log(myMessage);//Iloveyou有一个心碎的女纸任性地对一个用来分手的字符串任性地执行了“substring”方法，然后开心地看着剪辑版睡过去了。可是可是可是，不是说string是基本类型吗，为什么它可以拥有方法？？还有没有王法啊青天大老爷！其实，这一切，都是因为有个叫“基本包装类型”的东东。这个基本包装类型特别耿直，是真正的“事了拂衣去，深藏功与名”！基本包装类型除了一开始提到的Object、Array等引用类型，JavaScript还为我们提供了三种特殊的引用类型：String、Number和Boolean，方便我们操作对应的基本类型。继续看上面的剪辑字符串的例子，有没有注意到，尽管使用了substring方法，realMessage本身的值是不会变的，调用这个方法只是返回了一个新的字符串。这就是基本包装类型的作用了。本来你是没有方法的，但是你想用方法的时候，你尽管调，对应的基本包装类型有这个方法就行。例如上面的substring方法，string这个基本类型是不可能有这个方法的，但是String这个包装类型有啊，它会吭吭哧哧地把这个方法执行完把结果返回。在执行到：realMessage.substring(5,15)这行代码时，发生了很多事。首先，它会从内存中读取realMessage的值。当处于这种读取模式下的时候，后台就开始干活了。JS高程是这样描述后台完成的这些动作的：1.创建String类型的一个实例；2.在实例上调用指定的方法；3.销毁这个实例上面的例子可以用这样的代码来说明：var_realMessage=newString(SaidIloveyoubutIlied);  varmyMessage=_realMessage.substring(5,15);  _realMessgae=null;//方法调用后即销毁所以，这样我们就明白了，并不是基本类型string执行了自身方法，而是后台为它创建了一个对应的基本包装类型String，它根据基本类型的值实例化出了一个实例，让这个实例去调用指定方法，最后销毁自己，感天动地有木有。注意最后一步基本包装类型“会销毁”的特性，这决定了我们不能为基本类型值添加自定义属性和方法。varme=sunjing;  me.age=18;  console.log(me.age);//undefined我给“me“这个字符串添加了age属性，值设为美好的18岁，然并卵，再次访问时，这个属性已经渺无踪迹了。这是因为:执行到第二行代码属性赋值时，后台创建了一个基本包装类型的实例，这个age属性确实挂到实例上去了，但是紧跟着，这个实例就被销毁了。执行到第三行时，又重新创建了新的基本包装类型的实例，自然是没有age属性的。显示使用基本包装类型除了在字符串处于读取模式下，后台会帮我们创建基本包装类型实例时，我们自己也可以显示地创建。varstr=newString(hello);  varstr2=str.toUpperCase();  console.log(str2);//HELLO:这样与后台帮我们创建时变量中保存的东西是不同的。varstr1=newString(hello);  varstr2=hello;  typeofstr1//object  typeofstr2//string总结多亏了有基本包装类型，我们操作string、boolean、number这三种基本类型更方便了。每当读取这三种基本类型值时，后台会创建对应的包装类型实例，这个实例会调用指定方法，调用完会被销毁。这种短暂的生命周期决定了我们不能为基本类型添加自定义的属性和方法。'>JavaScript中为什么string可以拥有方法？</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>20</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/309B34B1-3644-4566-9D66-720BAE434529.html' title='服务器调用JS服务器控件调用JS一、两类JS的触发设计1.提交之前的JS -- 加js的事件例：script language=javascript// 构造函数function test(){alert(abcdefg);return true;}/script// 添加点击事件，点击按钮后调用test 返回值，如果获得Faluse 则不执行C#代码 ；true 执行代码；asp:Button ID=Button1 runat=server OnClientClick=return test(); Text=Button OnClick=Button1_Click /C#代码：2.提交之后 的JS -- 用C#代码向页面上写script../script在aspx 页面添加 Literal 控件在cs 页面：Label1.Text = DateTime.Now.ToString();// literal 控件用于页面输出。其内容是可以编程的Literal1.Text = script language=javascriptalert( + DateTime.Now.ToString() + 正确吗？)/script;可以实现点击按钮前后弹出提示信息；二、除了Button之外的其它控件如何触发JS？（其他控件没有Onclick 事件）要点思想：1.直接在服务端控件的HTML代码中加上JS的事件。2.在C#代码界面中的PageLoad中，使用“控件名.Attributes.Add(键,值);”例子：效果：点击前提示（“请输入姓名”） 输入后不提示 。输入值直接传给Label文本框；★★★★★★★★★★★★控件：TEXTBOX★★★★★★★★★★★★★★HTML 知识点：// document - HTML 文档 getElementById(to) - 其中的 id=to 的 HTML 元素// innerHTML - HTML 元素的内部文本document.getElementById(to).innerHTML=代码：1 添加TEXTBox 控件后，在aspx 中添加Onblur（失去焦点后触发） 事件，asp:TextBox ID=TextBox1 onfocus=this.value=; onblur=document.getElementById(Label1).innerHTML=this.value; runat=server Height=47px必填/asp:TextBox★★★★★★失去焦点触发事件★★★★★★ onblur=document.getElementById(Label1).innerHTML=this.value;★★★★★★★★★★★Label★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★效果：添加点击事件，点击后弹出”你好“提示代码：asp:Label ID=Label2 runat=server onclick=alert(你好！); Text=Label/asp:Label★★★★★★★★★★★ RadioButten★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★效果： 点击“同意” “下一步” 点击”不同意“ “下一步不可用”知识点补充：setAttribute() 方法用于改变属性的值removeAttribute() 方法删除指定属性。asp:RadioButton ID=RadioButton1 runat=server onclick=document.getElementById(Button2).removeAttribute(disabled) GroupName=q OnCheckedChanged=RadioButton1_CheckedChanged Text=同意 /asp:RadioButton ID=RadioButton2 runat=server onclick=document.getElementById(Button2).setAttribute(disabled,disabled) Checked=True GroupName=q Text=不同意 /'>服务器调用JS</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>21</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/C50FBA5C-A75B-46FE-9318-7A8CB502EF6C.html' title='functionCheckTel(){/*验证电话号码  验证规则：区号+号码，区号以0开头??位或4位号码由7位或8位数字组成  区号与号码之间可以无连接符，也可以“-”连接  如01088888888,010-88888888,0955-7777777*/  varisPhone=/^0\d{2,3}-?\d{7,8}$/;/*验证手机号码  移动：134(1349除外）135136137138139147150151152157158159182183184187188  联通：130131132155156185186145  电信：133153177180181189*/  varisMob=/^((\+?86)|(\(\+86\)))?(13[012356789][0-9]{8}|15[012356789][0-9]{8}|18[02356789][0-9]{8}|147[0-9]{8}|1349[0-9]{7})$/;varvalue=$(#telphone).val();if(isMob.test(value)||isPhone.test(value)){returntrue;  }else{returnfalse;  }  }'>js 验证电话号 座机及手机号</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>22</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/039156C0-18E7-4F0C-B993-B0C4D2505F4E.html' title='Jquery 事件Jquery 事件在javascript中事件调用方式为onclick、onmouseover等，在jquery中 使用事件无需写前面的onbind()方法为元素绑定事件$(#id).bind(click,function(){//为id绑定click事件  alert(ok);  });使用bind()方法绑定的事件，是多播事?校褪窃俅味ㄒ宓氖录换岣哺乔耙桓鍪录?/p>//可以按顺序执行两个事件$(#id).bind(click,function(){alert(1);});  $(#id).bind(click,function(){alert(2)});one()方法绑定一次性事件//只执行一次单击操作下次不会再执行$(#id).one(click,function(){  alert(a);returnfalse;  });unbind()方法删除事件，取消绑定$(#id).unbind();//删除id的所有事件$(#id).unbind(click);//删除id的所有click事件快捷事件javascript事件去掉on基本都支持click()方法单击事件$(#id).click();//如果不写函数体表示立即触发事件$(#id).click(function(){//这是一个点击事件});dbclick()方法双击事件$(#id).dbclick();//触发事件$(#id).dbclick(function(){//双击后执行});focus()方法获得焦点$(#id).focus();//触发$(#id).focus(function(){//获得焦点后执行});blur()方法失去焦点$(#id).blur();//触发失去焦点事件$(#id).blur(function(){//失去焦点后执行});change()方法改变时$(#id).change();//触发改变事件$(#id).change(function(){//改变后执行});mouseover()方法鼠标移入$(#id).mouseover();  $(#id).mouseover(function(){});mouseout()方法鼠标移出$(#id).mouseout();  $(#id).mouseout(function(){});submit()方法提交表单$(#id).submit();  $(#id).submit(function(){});hover()方法用于解决mouseover和mouseout存在的问题//两个function分别对应移入和移出$(div).hover(function(){  $(div).html(啊啊啊啊啊啊啊快跑啊他来了);  },function(){  $(div).html(呼、吓死了终于走了！)  });toggle()方法依次执行每个函数，如果执行完毕重复执行$(#div).toggle(function(){  $(#div).css({width:100px});  },function(){  $(#div).css({width:200px});  },function(){  $(#div).css({width:300px});  }  );Jquery 事件对象Jquery event将不同浏览器的差异进行了合并，比如可以在所有浏览器中都使用event.target来获取触发者而不用判断浏览器使用srcElement。$(#div).click(function(e){  alert(e.type);//返回事件名click  alert(e.target);//返回事件源谁触发的  alert(e.altKey);//返回alt是否按下  alert(e.screenX);//...等等js中的事件});'>Jquery 事件</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>23</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/94DBE0CB-8A77-43FF-BC49-BF7BF0121748.html' title='我知道Ajax是google的 google map应该，我们都知道，b/s架构跟c/s架构的区别。所谓的C/S架构其实就是我们常说的胖客户端，需要我们将程序部署到各个客户端上，费时，费力，容易出错，但是也有好处，就是响应能力强，典型的又QQ之类的程序，那B/S架构呢？也就是通俗的网站，程序部署在服务器上，我们通过浏览器浏览内容，B/S是基于HTTP的协议，而HTTP协议的典型特征就是无状态，什么是无状态，就是客户端不能记住我们操作的状态，或者数据。举一个最简单的例子。body  form id=form1 runat=server  div  asp:TextBox ID=Mytext runat=server/asp:TextBox  asp:Button ID=MyButton Text=Check here runat=server      onclick=MyButton_Click /  /div  /form/body这里我们有一个最简单的ASP.NET页面，所要实现的功能也是很简单的，一个文本框一个按钮，要实现的功能就是点击一个按钮，文本逛里的数字就加一。后台代码public partial class WebForm1 : System.Web.UI.Page{  int value = 0;  protected void Page_Load(object sender, EventArgs e)  {  }  protected void MyButton_Click(object sender, EventArgs e)  {    value++;    this.Mytext.Text = value.ToString();  }}可是结果却是无论我怎么点击，textbox的值始终是1，但是再winfrom程序里就可以达到我们要的效果，至于原因，我会在ASP.NET的文章里解释，这里只简单的说一下，因为HTTP实际也是请求----响应，一次请求一次响应，彼此之间的请求响应是不互相联系的。那么在我们与浏览器产生交互的时候实际上是向服务器请求数据，然后服务器返回数据给我们。这里就有几个问题，就是每次我们都需要服务器的响应。如果我们想向服务器响应的只是一小部分内容而不是正个页面，这时也还是会返回整个页面，造成长时间的等待，比如验证数据。二就是每次操作都需要往返，用户的体验不好。而Ajax就是为了解决这个问题AJAX（Asynchronous JavaScript and XML）异步Javascript和XML。先看原理图　解释一下这幅图 1，用户触发页面事件产生交互，调用事件处理函数 2，事件处理函数利用ajax核心的XMLHttpRequest异步向服务器发起请求 3，服务器响应，触发XMLHttpRequest定义的回调函数 4，根据一系列的属性检测返回状态，如果成功执行代码，如果不成功提示用户　这跟正常的请求响应方式有所不同，但是也不是那么难理解，其实就是整个请求是异步的，异步请求，然后服务器返回，我们处理代码。 那么我们刚刚看到了基本原理，也看了AJAX的核心其实就是XMLHttpRequest。现在就介绍一些这个对象，然后看看这个对象怎么使用，这里介绍的例子都是只返回纯文本格式，其实服务器返回的内容的格式可以是XML，也可以是JSON。这里为了简单，返回的都是纯文本。服务器技术为ASP.NET。 XMLHttpRequest最早是在IE5中引进的，但是各个浏览器所实现的标准不一样，所以我们在创建的时候要注意，我在Javascript的文章中有写到怎么检测浏览器，可以参考。这里我们采用的是对象/特性检测法var xmlHttp;function CreateXMLHttpRequest() {  if (window.ActiveXObject) {    xmlHttp = new ActiveXObject(Microsoft.XMLHTTP);  } else {  xmlHttp = new XMLHttpRequest();  }}这里我们创建的是一个全局的变量，也可以使这个函数返回值来创建一个局部变量。下面来看看XMLHttpRequest对象的一些属性onreadystatechange  //这是一个很重要的属性，即XMLHttpRequest的每个状态改变时都会触发这个事件，即如果我们异步的发送一个请求，请求回来就是改变状态。通常会有一个事件处理函数。readyState   //这个属性同样重要，请求的状态。0=未初始化，1=正在加载，2=已加载，3=交互中，4=完成，我们根据状态做不同的操作responseText  //服务器的响应，表示为一个串responseXML  //服务器的响应，表示为XML。这个对象可以解析为一个DOM对象。statusText //http状态码的相应文本（OK或NotFound：404）XMLHttpRequest的一些方法abort()  //停止当前请求getAllResponseHeaders()  //把HTTP请求的所有响应首部作为键值对返回getResponseHeader(header) //返回指定首部的串值open(method,url)  //建立对服务器的调用。methed参数可以的get，post或put。url参数可以是相对url或绝对url，这个方法还包含3个可选参数。send(content) //向服务器发送请求setRequestHeader(header,value) //把指定首部设置为所提供的值。在任何设置首部之前必须先调用open().open方法的完整参数open(method,url,asynch,username,password)，asynch指示是否是异步，默认为true。后面可以指定一个用户名和密码我们要注意的是Contect-Type的类型和是否缓存结果，要是不想缓存结果可以设置成response.setHeader(Cache—Control,no-cache);或者response.setHeader(pragma,no-cache);Get和Post的区别get和post的区别1 get是从服务器获取数据，而post则是向服务器提交数据2 get请求的数据会明文的附在在url后，以?的形式分割，而post则是把数据附在HTTP包的包体中3 根据第二点，post比get安全性高4 IE会对URL长度限制，即get的长度限制（2083字节），而Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。get和post的区别参考于http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html，如想了解更多信息，请参考以上连接。简单的AJAX示例这个示例非常简单，一个文本框，一个按钮。点击按钮，文本框显示服务器端返回的“Hello World”首先我们定义一个函数，这个函数的作用就是实例化一个XMLHttpRequest，我们之前定义过var xmlHttp;function CreateXMLHttpRequest() {  if (window.ActiveXObject) {    xmlHttp = new ActiveXObject(Microsoft.XMLHTTP);  } else {  xmlHttp = new XMLHttpRequest();  }}然后我们定义另外一个函数，这个函数用于异步向服务器发送请求function startRequest() {  CreateXMLHttpRequest();  var url = HelloWorld.ashx;  xmlHttp.onreadystatechange = handleStateChange  xmlHttp.open(GET, url.toString());  xmlHttp.send(null);}我们这里的服务端使用的是一般处理程序，ASP.NET还可以使用WebService和后置代码，这个以后再讲然后我们就可以定义回调函数了function handleStateChange() { if(xmlHttp.readyState==4) {   if (xmlHttp.Status == 200) {     var otext = document.getElementById(MyText);     otext.value = xmlHttp.responseText;   } }}html代码body  form id=form2 runat=server  div  input type=text id=Text1 /  input type=button id=Button1 value=Check me onclick=startRequest()/  /div  /form/bodyHelloWorld.ashx代码public class HelloWorld : IHttpHandler{  public void ProcessRequest(HttpContext context)  {    context.Response.ContentType = text/plain;    context.Response.Write(Hello World);  }  public bool IsReusable  {    get    {      return false;    }  }}点击按钮，文本框显示HelloWorld。在这里HelloWorld字符串太短，这个过程我们看不清楚，那我们就返回比较长的字符串来看看效果，我们只需要改动HelloWorld.ashx代码public class HelloWorld : IHttpHandler{  public void ProcessRequest(HttpContext context)  {    string s = ;    context.Response.ContentType = text/plain;    for (int i = 0; i  9000000; i++)    {      s = i.ToString();    }    context.Response.Write(Complete!);  }  public bool IsReusable  {    get    {      return false;    }  }}执行循环来延迟服务器响应时间。这时我们就可以看到异步的详细了。我们还可以添加一些东西来完善，比如我们经常看到的loading...需要改动的只是HTML文件　　完整代码如下head id=Head1 runat=server  title/title  script type=text/javascript    var xmlHttp;    function CreateXMLHttpRequest() {      if (window.ActiveXObject) {        xmlHttp = new ActiveXObject(Microsoft.XMLHTTP);      } else {        xmlHttp = new XMLHttpRequest();      }    }    function startRequest() {      CreateXMLHttpRequest();      var url = HelloWorld.ashx;      xmlHttp.onreadystatechange = handleStateChange      xmlHttp.open(GET, url.toString());      xmlHttp.send(null);    }    function handleStateChange() {      if (xmlHttp.readyState == 1) {        var oimage = document.getElementById(MyImg);        oimage.style.display = ;      }      if (xmlHttp.readyState == 4) {        if (xmlHttp.Status == 200) {          var oimage = document.getElementById(MyImg);          oimage.style.display = none;          var otext = document.getElementById(MyText);          otext.value = xmlHttp.responseText;        }      }    }  /script/headbody  form id=form3 runat=server  div  input type=text id=Text2 /  input type=button id=Button2 value=Check me onclick=startRequest()/  img id=MyImg alt= src=Image/loading.gif style=display:none /  /div  /form/body'>Ajax原理及简介</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>24</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/38172617-ECDB-4FD8-AC54-9D0DADF98B71.html' title='网页正文、屏幕、滚动条相关分类：web前端2015-08-23 11:37100人阅读评论(0)收藏举报网页正文频幕滚动条坐标宽高网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth(包括边线的宽);网页可见区域高： document.body.offsetHeight(包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight;屏幕可用工作区宽度：window.screen.availWidth;scrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量要获取当前页面的滚动条纵坐标位置，用：document.documentElement.scrollTop;而不是：document.body.scrollTop;documentElement 对应的是 html 标签，而 body 对应的是 body 标签'>js?获取网页正文、屏幕、滚动条相关</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>25</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/EA02A2A3-D734-4066-989F-D2872690689A.html' title='javascript类型系统大汇总[1]javascript中的类型系统:原生对象 + 宿主对象 + 浏览器拓展对象[注意]javascript不支持任何创建自定义类型的机制　　[1.1]原生对象(15种)：Undefined、Null、Boolean、Number、String、Object、Function、Array、Date、RegExp、Error、Math、JSON、Global、arguments　　[1.2]宿主对象：window、document、navigator……　　[1.3]浏览器拓展对象：ActiveXObject、XML、Debug、Script、VBArray……[2]原生对象可分为：　　[2.1]标准类型(6种)：Undefined、Null、Boolean、Number、String、Object　　[2.2]基本包装类型(3种):Boolean、Number、String　　[2.3]构造器(9种)：Boolean、Number、String、Object、Function、Array、Date、RegExp、Error　　[2.4]标准内置对象(12种)：Boolean、Number、String、Object、Function、Array、Date、RegExp、Error、Math、JSON、Global【目录链接】　　【1】基本数据类型　　【2】引用类型中的对象Object　　【3】引用类型中的数组Array　　【4】引用类型中的时间Date　　【5】函数Function　　【6】正则表达式RegExp　　【7】包装类型(Boolean、Number、String)　　【8】单体内置对象(Global、Math)javascript类型系统之基本数据类型[0]6种数据类型：[0.1]基本数据类型：Undefined、Null、Boolean、Number、String[0.1.1]基本类型值是指简单的数据段，5种基本类型是按值访问的，因为可以操作保存在变量中的实际值[0.1.2]基本类型的值在内存中占据固定大小的空间，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。[0.1.3]不能给基本类型的值添加属性[0.2]引用数据类型：Object[0.2.1]引用类型值是指那些可以由多个值构成的对象。js不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。[0.2.2]引用类型的值是对象，保存在堆内存中，包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。[0.2.3]对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法[1]Undefined[1.1]Undefined类型只有一个值，就是undefined[1.2]var a = var a = undefined;[1.3]对于尚未声明过的变量，只能执行一项操作，就是使用typeof操作符检测其数据类型【但在严格模式下会导致错误】[1.4]出现场景：[1.4.1]已声明未赋值的变量[1.4.2]获取对象不存在的属性[1.4.3]无返回值的函数的执行结果[1.4.4]函数的参数没有传入[1.4.5]void(expression)[1.5]类型转换Boolean(undefined)：falseNumber(undefined):NaNString(undefined):undefined[2]Null[2.1]Null类型只有一个值，就是null,逻辑角度看，null值表示一个空对象指针[2.2]如果定义的变量将用于保存对象，最好将该变量初始化为null[2.3]实际上undefined值是派生自null值的，所以undefined == null[2.4]出现场景：对象不存在时[2.5]类型转换Boolean(null)：falseNumber(null):0String(null):null[注意1]null是空对象指针，而[]是空数组，{}是空对象，三者不相同[注意2]null不能添加自定义属性[3]Boolean[3.1]Boolean类型只有两个值：true 和 false[3.2]出现场景：[3.2.1]条件语句导致系统执行的隐士类型转换[3.2.2]字面量或变量定义[3.3]类型转换Number(true): 1 || Number(false) : 0String(true):true || String(false):false[3.4]Boolean()Boolean(undefined):falseBoolean(null):falseBoolean(非空对象包括空数组[]和空对象{}):trueBoolean(非0): true || Boolean(0和NaN):falseBoolean(非空包括空格字符串):true || Boolean():false[注意]true不一定等于1,false也不一定等于0[4]Number[4.1]Number类型使用IEEE754格式来表示整数和浮点数值[注意]可以用一个值-0来将其转换成一个数字[4.2]三种字面量格式是十进制、八进制、十六进制[4.2.1]八进制字面值的第一位必须是0，然后是八进制数字序列(0-7),如果字面值中的数值超出了范围，那么前导0将被忽略，后面的数值被当作十进制数解析[4.2.2]八进制字面量在严格模式下是无效的，会导致js抛出错误[4.2.3]十六进制字面值的前两位必须是0x,后跟十六进制数字序列，字母可大写可小写[4.2.4]十六进制中字面值中的数值走出范围，如出现g,h等会报错[4.2.5]在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值[4.3]数值表示：[4.3.1]js中可以保存正0和负0，且被认为相等[4.3.2]浮点数值：该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。[4.3.2.1]由于浮点型数值需要的内存空间是保存整数值的两倍，因此js会不失时机地将浮点数值转换成整数值，若小数点后没有跟任何数字或者浮点值本身表示的就是一个整数，这个数值会作为整数值来保存。[4.3.2.2]浮点数值的最高精度是17位小数[4.3.2.3]对于极大或者极小的数，可以用科学计数法e来表示的浮点数值来表示[4.3.2.4]默认情况下，js会将小数点后面带有6个0以上的浮点数值转换为以e表示法表示的数值[4.3.2.5]基于IEEE754数值的浮点计算的通病是舍入误差的问题。如：0.1+0.2 === 0.3(15个0)4[4.3.3]js中的数值范围是Number.MIN_VALUE(5e-324) —— Number.MAX_VALUE(1.7976931348623157e+308)[4.3.3.1]如果超出正数范围，输出Infinity(正无穷大)，超出负数范围，输出-Infinity(负无穷大)[4.3.3.2]+-Infinity不能参与数值计算[4.3.3.3]Number.MAX_VALUE+1 != Infinity,因为计算机最多保存52位尾数位，保存不了1000多位，早就失去精度，即小数位全为0，所以相加不变[4.3.3.4]Number.MIN_VALUE - 1 != -Infinity,也是同样的原因，所以结果为-1[4.3.3.5]可以用isFinite()来确定一个数值是不是有穷的,包含着隐式类型转换Number()[4.3.3.6]isFinite(NaN) //false[4.3.4]NaN[4.3.4.1]NaN与任何值都不相等，包括NaN本身[4.3.4.2]任何涉及NaN的操作都会返回NaN[4.3.4.3]isNaN()来判断这个数字是不是NaN,包含着隐式类型转换Number()[4.4]数值转换:Number()可用于任何类型，parseInt()和parseFloat专门用于把字符串转换成数值[注意1]Number()、parseInt()、parseFloat()可以接受各种进制的数字，但对于含数字的字符串并不适用[注意2]Number()、parseInt()、parseFloat()中数字为1.2. 会报错，但字符串为1.2.则不会报错　[注意3]Number()、parseInt()、parseFloat()解析字符串时都能识别前置空格并去掉[4.4.1]Number()Number(true):1 || Number(false):0Number(各种进制的数字)：运算后的十进制的数字，如1.0或1.或01会以1输出Number(undefined):NaNNumber(null):0Number(字符串)：Number(只包含数字的十进制和十六进制的字符串)：运算后的十进制的数字[注意]字符串中不识别八进制，按照十进制数字处理Number(和 ):0Number(其他情况的字符串):NaNNumber(对象)：Number([]和[0]和[-0]):0Number([数字])：运算后的数字Number([1,2]和{}和其他对象):NaN[4.4.2]parseInt()：在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN。如果是，则继续解析，直到解析完成或者遇到非数字字符。[4.4.2.1]parseInt()可以识别出各种进制的整数,但在解析八进制字面量的字符串，ECMAScript3会解析八进制，但ECMAScript5没有解析八进制的能力[4.4.2.2]parseInt()函数提供第二个参数，表示多少进制，如：parseInt(123,16或10或2)[4.4.2.3]parseInt(各种进制的数字)：运算后的十进制的数字，如1.0或1.或01会以1输出[4.4.2.4]因为parseInt()是专门用来处理字符串转换数字的，所以parseInt(其他类型包括)//NaN[4.4.3]parseFloat():类似于parseInt()，会忽略字符串前面的空格，直到找到第一个非空格字符[4.4.3.1]parseFloat()只能解析十进制字符串[4.4.3.2]parseFloat(各种进制的数字)：运算后的十进制的数字，如1.0或1.或01会以1输出[5]String:由单引号或双引号括起来的字符序列,任何字符串的长度都可以通过访问length属性获得[5.1]字符字面量，也叫转义序列\n 换行\t 制表\b 空格\r 回车\f 进纸\\ 斜杠\ 单引号\ 双引号\xnn 以十六进制nn表示一个字符(n为0-f)，如\x41表示A\unnnn 以十六进制nnnn表示一个Unicode字符(n为0-f)，如\u03a3表示希腊字符ε[5.2]ECMAScript中的字符串是不可变的[5.3]字符串连接需要先创建一个新字符串，然后在新字符串中填充两个需要拼接的字符串，最后再销毁原来的字符串。这个过程在后台发生，也是在某些旧版本浏览器(IE6)拼接字符串速度慢的原因，但后来已经解决了这个低效率问题[5.4]字符串转??/p>[5.4.1]toString()Null和Undefined没有该方法Boolean、Object、String有该方法Number使用该方法可以传递基数2、8、10、16,如var num = 10;num.toString(2);//1010但10.toString(2)会报错,因为数字后面不能跟标识符[5.4.2]String()有toString()方法，使用toString()方法String(null);//nullString(undefined);//undefined[5.4.3]要把某个值转换为字符串，可以使用加号操作符把它与一个空字符串加在一起　　 [5.4.4]如果数组中的某一项的值是null或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示javascript引用类型之对象Object[前面的话]　　引用类型：在javascript中，引用类型是一种数据结构，用于将数据和功能组织在一起，它也常被称为类。引用类型有时也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。引用对象的值（对象）：是引用类型的一个实例。对象是某个特定引用类型的实例，新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。对象的别名是集合。Object:是一组数据和功能的集合[1]对象创建：两种Object类型的创建方法　　[1.1]使用new操作符后跟Object构造函数varperson=newObject();类似于varperson=newObject;//也就是说可以不加括号person.name=bai;  person.age=29;　　[1.2]使用对象字面量varperson={  name:bai,  age:29}　　[注意1]在对象字面量中使用逗号来分隔不同的属性，但是在最后一个属性后面添加逗号，会在IE7及更早版本和Opera中导致错误　　[注意2]使用对象字面量的方法来定义对象，属性名会自动转换成字符串,实际上不会调用Object构造函数　　[注意3]如果留空其花括号，则可以定义只包含默认属性和方法的对象　　e.g. var person = {}; 相当于 var person = new Object();　　　　[1.2.1]使用对象字面量来封装多个可选参数的方法：functiondisplayInfo(args){varoutput=;if(typeofargs.name==string){  output+=name:+args.name+\n;  }if(tyoepfargs.age==number){  output+=Age:+args.age+\n;  }  alert(output);  }  displayInfo({  name:Nicholas,  age:29});　　[注意]以上这种传递参数的模式最适合需要向函数传入大量可选参数的情形。最好的做法是，对那些必需值使用形参，而使用对象字面量来封装多个可选参数。[2]Object的实例的属性和方法　　[2.1]constructor:保存着用于创建当前对象的函数　　[2.2]hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。其中，propertyName必须以字符串形式指定　　[2.3]isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型　　[2.4]propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句来枚举。其中，propertyName必须以字符串形式指定　　[2.5]toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。　　[2.6]toString():返回对象的字符串表示　　[2.7]valueOf():返回对象的字符串、数值或布尔值表示，通常与toString()方法的返回值相同[3]两种访问对象属性的方法　　[注意1]除非必须使用变量来访问属性，否则建议使用点表示法，且在属性名命名时尽量符合命名规则　　[注意2]变量中可以存在中文，因为中文相当于字符，与英文字符同样对待，因此可以写成person.白或person[白]　　[注意3]方括号中的值若是非字符串类型会使用String()隐式转换成字符串再输出；如果是字符串类型，若有引号则原值输出，否则会被?侗鹞淞浚舯淞课炊ㄒ澹虮ù?/p>person[0]=1;//[]中的数字不会报错，而是自动转换成字符串person[a]=1;//[]中符合变量命名规则的元素会被当成变量，变量未被定义，而报错person[]=2;//[]中的空字符串不会报错,是实际存在的且可以调用,但不会在控制台右侧的集合中显示person[undefined或null或true或false]=4;//不会报错，而是自动转换成字符串person[白]=6;//不会报错　　[3.1] person.name　　[3.2] person[name]　　　　[3.2.1]方括号的主要优点　　　　　　[a]可以通过变量来访问属性　　　　　　[b]属性名中可以包含导致语法错误的字符，或者属性名中使用的是关键字或保留字 　　　　　　e.g. person[first name];[4]对象可以嵌套，但必须逐层取值varstudent={  name:{  chinese:1,  englisth:2  },  sex:1,  age:26}　　[注意]取值只能一层一层取,如student.name.chinese,而不能跨过name,直接用student.chinese,因为与name的同级下也可能有叫chinese的元素[5]对象的delete运算符: delete只能删除对象下的数据，其他5种基础类型的值是删除不掉的　　[5.1]如果在全局状态下声明变量a，相当于window对象下的一个数据a,可以通过window.a或a来对a赋值，且window.a和a的值总是相等，但就是无法删除　　[5.2]如果用window.b 来声明并赋值(b相当于声明在window对象下),可以删除,且用delete b 和 delete window.b 的效果相同，删除后，console.log(b)提示变量不存在，console.log(window.b)提示undefinedjavascript引用类型之数组Array[数组的22种方法概述]Array:数组中的每一项可以保存任何类型的数据，且数组的大小是动态调整的(最多可包含4294967295项，大约43亿项)[1.1]数组创建:[1.1.1]使用Array构造函数(在使用Array构造函数时，也可以省略New操作符)e.g. var colors = new Array(); var colors = new Array(20); var colors = new Array(red,blue,green); var colors = Array(3);[注意]若传递的是数值，则会按照该数值创建包含给定项数的数组；  如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组  e.g. var colors = new Array(3);//包含三项的数组  var colors = new Array(Greg);//包含一项，且该项为Greg的数组 [1.1.2]使用数组字面量表示法(用该方法不会调用Array构造函数)e.g. var colors = [red,blue,green]; var colors = [];[不可用] var colors = [1,2,];//在IE8及以前中会包含一个三个项目,且每个项目为1、2和undefined的数组。在其他浏览器中为只包含1和2的数组[不可用] var colors = [,,,];//在IE8及以前会创建4项的数组,而在其他浏览器中会创建3项的数组[1.2]数组读写[1.2.1]在读取和设置数组的值时，要使用方括号并提供相应值的基于0的数字索引，数组的项数保存在其length属性中，这个属性始终会返回0或更大的值[1.2.2]数组的length属性可读可写，通过设置数组的Length属性，可以从数组的末尾移除项或向数组中添加新项e.g. var colors = [red,blue,green];　　colors.length = 2;　　alert(colors[2]);//undefined　　colors.length = 4;　　alert(colors[3]);//undefined[1.2.3]利用length属性可以方便地在数组末尾添加新项e.g. colors[colors.length] = black;[1.2.4]当把一个值放在超出数组大小的位置上时，数组就会重新计算其长度值，即长度值等于最后一项的索引加1e.g. var colors = [red,blue,green]; colors[99] = black; alert(colors.length);//100[1.3]数组检测[1.3.1]if(value instanceof Array){}:问题在于它假定只有一个全局执行环境，如果网页中包含多个框架，那实际上就存在两个以上不同的全局环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。[1.3.2]ECMAScript5新增了Array.isArray()方法:if(Array.isArray(value)){}。该方法的目的是最终确定某个值到底是不是数组，而不管它在哪个全局环境中创建的[1.4]数组转换[注意]如果数组中的某一项的值是null或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示[1.4.1]toString():返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串[1.4.2]valueof():返回的还是数组e.g. var colors = [red,blue,green];  console.log(colors.valueOf());//[red,blue,green] alert(colors.valueOf());//red,blue,green alert(colors.toString());//red,blue,green alert(colors);//red,blue,green[注意]由于alert()要接收字符串参数，它会在后台调用toString()方法，会得到与toString()方法相同的结果[1.4.3]toLocaleString():它会创建一个数组值以逗号分隔的字符串，而每一项的值调用的是toLocaleString()方法varperson1={    toLocaleString:function(){returnNikolaos;    },    toString:function(){returnNicholas;    }    };varperson2={    toLocaleString:function(){returnGrigorios;    },    toString:function(){returnGreg;    }    };varpeople=[person1,person2];    alert(people);//Nicholas,Gregalert(people.toString());//Nicholas,Gregalert(people.toLocaleString());//Nikolaos,GrigoriosView Code[1.4.4]join:可以使用不同的分隔符来构建这个字符串,join只接收一个字符，用作分隔符的字符串，然后返回包含所有数组项的字符串e.g. var colors = [red,green,blue]; alert(colors.join(,));//red,green,blue alert(colors.join(||));//red||green||blue alert(colors.join());//red,green,blue<span style="background-color: inherit; font-family: 宋体; font-s'>javascript类型系统大汇总</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>26</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/20C8F6E6-50A8-465F-A29E-C5502B6F369A.html' title='javascript的return语句简单介绍:return语句在js中非常的重要，不仅仅具有返回函数值的功能，还具有一些特殊的用法，有个清晰的把握是非常有必要的。下面就结合实例简单介绍一下return语句的作用。一.用来返回控制和函数结果:通常情况，return语句对于一个函数是很有必要的，因为往往需要函数在一系列的代码执行后会得到一个期望的返回值，而此值就是通过return语句返回，并且将控制权返回给主调函数。语法格式:return表达式代码实例如下:functionadd(){vara=1;varb=2;returna+b;  }functionfunc(){  console.log(add())  }  func();以上代码中，当调用func()函数的时候，控制权由func函数掌握，当再调用add函数的时候，控制权交付给add函数，然后返回一个值并将控制权再交付给func函数。通常情况下return后面跟有表达式，但是并不是绝对的，例如:return;此情况就是单纯的将控制权转交给主调函数继续执行。扩展说明:return语句的普通应用并没有特殊之处，最需要注意的是return false的使用。事件处理函数返回false可以组织默认事件的发生。代码实例如下:!DOCTYPEhtmlhtmlheadmetacharset=utf-8metaname=authorcontent=http://www.softwhy.com//title蚂蚁部落/titlescripttype=text/javascriptwindow.onload=function(){  varolink=document.getElementById(thelink);  olink.onclick=function(){returnfalse  }  }  /script/headbodyahref=http://www.softwhy.comid=thelink蚂蚁部落/a/body/html点击一个链接就会发生onclick事件，它的默认动作是链接指向href属性规定的链接，但是如果事件处理函数使用了return false，那么就会阻止默认事件的发生。return false也可以组织事件冒泡现象的发生，具体内容可以参阅JavaScript中return false的作用是什么一章节。'>javascript的return语句简单介绍</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>27</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/D9380598-5D4A-4A07-B70E-4FA4BC11F167.html' title='JavaScript学习笔记——动画基础 3.2一、让对象动起来让一个对象动起来，我们的初衷并非是想让它跳跃到目的地，这样不符合我们的直观感受，我们需要的是，让它逐步的移动到目的地。现在的需求已经很明确，自创新函数之前，我们需要根据需求对它进行分析，进而生成相对应的函数。1、逻辑分析首先，需要获取元素的初始位置，也就是元素的当前位置；如果元素在没有到达目的地之前它的位置在逐步的改变，这个地方需要用?皆怂惴?+、--；如果元素抵达目的地后，需要停止，也就是跳出函数本身；如果需要在一定时间间隔之后这个元素才开始运动，我们需要用到setTimeout方法；2、具体实例!doctypehtmlhtmlheadmetacharset=utf-8title筱雨生-博客园/titlestylebody{  font-family:Cambria,HoeflerText,LiberationSerif,Times,TimesNewRoman,serif,MicrosoftYahei;  background:#fff;  color:#333;  min-height:1000px;}table{border-collapse:collapse;}caption{  padding:1em;}td{  width:10em;  padding:.5em;  border:1pxsolid#999;}#myCat{  position:fixed;  width:500px;  height:100px;  right:10px;  bottom:10px;}/stylescriptfunctionaddonLoadEvent(func){varoldonload=window.onload;//把现有的window.onload事件处理函数的值存储到变量oldonloadif(typeofwindow.onload!=function){//如果这个处理函数上还没有绑定任何函数window.onload=func;//将这个函数绑定到window.onload事件}else{  window.onload=function(){//如果这个处理函数已经绑定了函数，就把这个函数追加到指令的末尾oldonload();  func();  }  }  }functionstripeTables(){if(!document.getElementsByTagName)returnfalse;vartables=document.getElementsByTagName(table);varodd,rows;for(vari=0;itables.length;i++){  odd=false;  rows=tables[i].getElementsByTagName(tr);for(varj=0;jrows.length;j++){if(odd==true){  rows[j].style.backgroundColor=#ffc;  odd=false;  }else{  odd=true;  }  }  }  }  addonLoadEvent(stripeTables);functionhightTR(){if(!document.getElementsByTagName)returnfalse;varhightRows=document.getElementsByTagName(tr);for(vari=0;ihightRows.length;i++){  hightRows[i].onmouseover=function(){this.style.fontWeight=700;  }  hightRows[i].onmouseout=function(){this.style.fontWeight=normal;  }  }  }  addonLoadEvent(hightTR);functionmoveElement(){varele=document.getElementById(myCat);varxpos=ele.offsetLeft;varypos=ele.offsetTop;if(xpos100){  xpos--;  }if(xpos100){  xpos++;  }if(ypos100){  ypos--;  }if(ypos100){  ypos++;  }if(xpos==100ypos==100){returntrue;  }  ele.style.left=xpos+px;  ele.style.top=ypos+px;  movement=setTimeout(moveElement(),10);  }  addonLoadEvent(moveElement);/script/headbodyh1筱雨生/h1p時光飛逝，莫讓網絡蹉跎了歲月/pdivid=myBlogtablewidth=300border=0cellspacing=0cellpadding=0id=myCatcaption我的博客分类/captiontbodytrtdWindows/tdtdiOS/tdtdAndroid/td/trtrtdJavaScript/tdtdHTML/tdtdCSS/td/trtrtdActionScript/tdtdAnimate/tdtdOthers/td/tr/tbody/table/div/body/html二、自定义moveElement函数根据上面的实例，我们可以进一步将其抽象化，让它适应所有元素的位置运动需求。!doctypehtmlhtmlheadmetacharset=utf-8title筱雨生-博客园/titlestylebody{  font-family:Cambria,HoeflerText,LiberationSerif,Times,TimesNewRoman,serif,MicrosoftYahei;  background:#fff;  color:#333;  min-height:1000px;}table{border-collapse:collapse;}caption{  padding:1em;}td{  width:10em;  padding:.5em;  border:1pxsolid#999;}#myCat{  position:fixed;  width:500px;  height:100px;  right:10px;  bottom:10px;}/stylescriptfunctionaddonLoadEvent(func){varoldonload=window.onload;//把现有的window.onload事件处理函数的值存储到变量oldonloadif(typeofwindow.onload!=function){//如果这个处理函数上还没有绑定任何函数window.onload=func;//将这个函数绑定到window.onload事件}else{  window.onload=function(){//如果这个处理函数已经绑定了函数，就把这个函数追加到指令的末尾oldonload();  func();  }  }  }functionstripeTables(){if(!document.getElementsByTagName)returnfalse;vartables=document.getElementsByTagName(table);varodd,rows;for(vari=0;itables.length;i++){  odd=false;  rows=tables[i].getElementsByTagName(tr);for(varj=0;jrows.length;j++){if(odd==true){  rows[j].style.backgroundColor=#ffc;  odd=false;  }else{  odd=true;  }  }  }  }  addonLoadEvent(stripeTables);functionhightTR(){if(!document.getElementsByTagName)returnfalse;varhightRows=document.getElementsByTagName(tr);for(vari=0;ihightRows.length;i++){  hightRows[i].onmouseover=function(){this.style.fontWeight=700;  }  hightRows[i].onmouseout=function(){this.style.fontWeight=normal;  }  }  }  addonLoadEvent(hightTR);functionaddonLoadEvent(func){varoldonload=window.onload;//把现有的window.onload事件处理函数的值存储到变量oldonloadif(typeofwindow.onload!=function){//如果这个处理函数上还没有绑定任何函数window.onload=func;//将这个函数绑定到window.onload事件}else{  window.onload=function(){//如果这个处理函数已经绑定了函数，就把这个函数追加到指令的末尾oldonload();  func();  }  }  }functionmoveElement(elementID,finalX,finalY,interval){varele=document.getElementById(elementID);varxpos=ele.offsetLeft;varypos=ele.offsetTop;if(xpos==finalXypos==finalY){returntrue;  }if(xposfinalX){  xpos--;  }if(xposfinalX){  xpos++;  }if(yposfinalY){  ypos--;  }if(yposfinalY){  ypos++;  }  ele.style.left=xpos+px;  ele.style.top=ypos+px;  movement=setTimeout(function(){moveElement(elementID,finalX,finalY,interval);},interval);    }  addonLoadEvent(function(){moveElement(myCat,200,200,10);});/script/headbodyh1筱雨生/h1p時光飛逝，莫讓網絡蹉跎了歲月/pdivid=myBlogtablewidth=300border=0cellspacing=0cellpadding=0id=myCatcaption我的博客分类/captiontbodytrtdWindows/tdtdiOS/tdtdAndroid/td/trtrtdJavaScript/tdtdHTML/tdtdCSS/td/trtrtdActionScript/tdtdAnimate/tdtdOthers/td/tr/tbody/table/div/body/html三、moveElement函数的应用上面的函数效果，很容易让我们想到，在很多年前，网络上常见的漂浮广告效果，尽管这样的效果很烦人，但是，它的出现确实容易让浏览者对其产生兴趣。除了这类应用，还有目前比较常见的鼠标移动到某个元素对象上，在另外一个地方出现一个新的元素然后进行相应的变换效果。!doctypehtmlhtmlheadmetacharset=utf-8title筱雨生-博客园/titlestylebody{  font-family:Cambria,HoeflerText,LiberationSerif,Times,TimesNewRoman,serif,MicrosoftYahei;  background:#fff;  color:#333;  min-height:1000px;}table{border-collapse:collapse;}caption{  padding:1em;}td{  width:10em;  padding:.5em;  border:1pxsolid#999;}#myBlog{  position:fixed;  right:20px;  bottom:20px;  line-height:2em;}#myBlogli{  list-style:none;  display:block;  line-height:2em;  height:2em;  padding:10px;  color:#fff;  text-decoration:none;  background:rgba(4,155,163,1.00);}#myBlogli:hover{  background:rgba(4,155,163,.8);}#myBloglia{  color:#fff;  text-decoration:none;}#showImg{  position:relative;  width:400px;  height:100px;  overflow:hidden;}/stylescriptfunctionaddonLoadEvent(func){varoldonload=window.onload;//把现有的window.onload事件处理函数的值存储到变量oldonloadif(typeofwindow.onload!=function){//如果这个处理函数上还没有绑定任何函数window.onload=func;//将这个函数绑定到window.onload事件}else{  window.onload=function(){//如果这个处理函数已经绑定了函数，就把这个函数追加到指令的末尾oldonload();  func();  }  }  }functionmoveElement(elementID,finalX,finalY,interval){varele=document.getElementById(elementID);varxpos=ele.offsetLeft;varypos=ele.offsetTop;if(xpos==finalXypos==finalY){returntrue;  }if(xposfinalX){  xpos--;  }if(xposfinalX){  xpos++;  }if(yposfinalY){  ypos--;  }if(yposfinalY){  ypos++;  }  ele.style.left=xpos+px;  ele.style.top=ypos+px;  movement=setTimeout(function(){moveElement(elementID,finalX,finalY,interval);},interval);    }functionshowSlide(){varpreview=document.getElementById(preview);varmyBlog=document.getElementById(myBlog);varlist=document.getElementById(linklist);varlinks=list.getElementsByTagName(li);varshow=document.getElementById(showImg);  preview.style.position=absolute;  preview.style.left=0;  preview.style.top=0;  links[0].onmouseover=function(){  moveElement(preview,0,-75,0);  }  links[1].onmouseover=function(){  moveElement(preview,0,-150,0);  }  links[2].onmouseover=function(){  moveElement(preview,0,-220,0);  }  links[3].onmouseover=function(){  moveElement(preview,0,-290,0);  }  }  addonLoadEvent(showSlide);/script/headbodydivid=myBlogulid=linklistliahref=#JavaScript/a/liliahref=#HTML/a/liliahref=#CSS/a/liliahref=#ActionScript/a/li/ul/divdivstyle=position:fixed;bottom:145px;right:160px;divid=showImgimgsrc=http://images0.cnblogs.com/blog2015/24899/201508/261924477657654.pngalt=showimagesid=preview//div/div/body/html四、题外话同一种武功，在不同的人身上会发挥出不同的效果'>JavaScript学习笔记——动画基础 3.2</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-1 上午 12:00:00</span></li>
                        </ul>
                        <br /><hr />
                    </div>
                </div>
                <div id="footerInnerSeparator"></div>
            </div>
        </div>
        <div id="footerOuterSeparator"></div>
    </div>
    <br /><br /><br />
    <script src="../../js/jquery-1.9.1.js"></script>
</body>
</html>