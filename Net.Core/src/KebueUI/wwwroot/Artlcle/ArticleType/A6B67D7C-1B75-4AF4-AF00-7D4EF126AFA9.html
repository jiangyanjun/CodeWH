<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="Language" content="zh-CN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../images/kebue.ico">
    <link rel="icon" href="../../images/kebue.ico">
    <meta name="description" content=SQLServer>
    <meta name="keywords" content=SQLServer>
    <title>SQLServer</title>

    <link href="../../template/scripts/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="../../template/styles/custom.css" rel="stylesheet" />

</head>
<body id="pageBody">
    <div id="divBoxed" class="container">
        <div class="transparent-bg" style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;z-index: -1;zoom: 1;"></div>
        <div class="divPanel notop nobottom">
            <div class="row-fluid">
                <div class="span12">
                    <div id="divLogo">
                        <a href="../../../Home/Index" id="divSiteTitle">科布尔 kebue</a><br />
                        <a href="../../../Home/Index" id="divTagLine">开发者用代码改变世界从科布尔开始</a>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="divMenuRight" class="pull-right">
                        <div class="navbar">
                            <button type="button" class="btn btn-navbar-highlight btn-large btn-primary" data-toggle="collapse" data-target=".nav-collapse">
                                NAVIGATION <span class="icon-chevron-down icon-white"></span>
                            </button>
                            <div class="nav-collapse collapse">
                                <ul class="nav nav-pills ddmenu">
                                    <li class="dropdown glyphicon glyphicon-arrow-left"><a href='javascript:window.history.back()'>后退</a></li>
                                    <li class="dropdown active"><a href="http://www.kebue.com/">Home</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="contentInnerSeparator"></div>
                </div>
            </div>
        </div>
        <div class="contentArea">
            <div class="divPanel notop page-content">
                <div class="breadcrumbs">
                    <a href="../../../Home/Index">Home</a> &nbsp;/&nbsp; <span>SQLServer</span>
                </div><br /><hr />
                <div class="row-fluid">
                    <div class="span12" id="Article-type">
                        <ul>
                            <li><span>1</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/D6A0BF25-DBD7-4BDE-A568-95BDF2B646DA.html' title='在Sql Server 2012程序，也就是SSMS 2O12启动时出现Cannot find one or more components.Please reinstall the application.方法/步骤1在运行中输入regedit.exe，启动注册表工具2找到注册表中的此处路径“HKEY_CURRENT_USER\Software\Microsoft\SQL Server Management Studio”3删除11.0_Config文件夹4重新启动sql server 2012，也就是SSMS 2012'>SQL 2012 启动出现 Cannot find one or more</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-16 上午 12:00:00</span></li><li><span>2</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/290CEFC1-95B6-4ADE-AE18-182C222D1DF6.html' title='1 基本思想之什么是分库分表？从字面上简单理解，就是把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。2 基本思想之为什么要分库分表？数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，由于无法进行分布式式部署，而一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。3 分库分表的实施策略。分库分表有垂直切分和水平切分两种。3.1 何谓垂直切分，即将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库workDB、商品数据库payDB、用户数据库userDB、日志数据库logDB等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。3.2 何谓水平切分，当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。3.3 应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。我们的游戏项目便综合使用了垂直与水平切分，我们首先对数据库进行垂直切分，然后，再针对一部分表，通常是用户数据表，进行水平切分。4 分库分表存在的问题。4.1 事务问题。在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。4.2 跨库跨表的join问题。在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。4.3 额外的数据管理负担和数据运算压力。额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。上述整理于互联网'>数据库为什么要分库分表</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>3</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/C805DB1F-67CE-43F1-9EBB-71DFCE7605E9.html' title='经典sql语句大全一、基础1、说明：创建数据库　　CREATE DATABASE database-name2、说明：删除数据库　　drop database dbname3、说明：备份sql server　　--- 创建 备份数据的 device　　USE master　　EXEC sp_addumpdevice disk, testBack, c:\mssql7backup\MyNwind_1.dat　　--- 开始 备份　　BACKUP DATABASE pubs TO testBack4、说明：创建新表　　create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)　　根据已有的表创建新表：　　A：create table tab_new like tab_old (使用旧表创建新表)　　B：create table tab_new as select col1,col2… from tab_old definition only5、说明：删除新表　　drop table tabname6、说明：增加一个列　　Alter table tabname add column col type　　注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。7、说明：添加主键：Alter table tabname add primary key(col)　　说明：删除主键： Alter table tabname drop primary key(col)8、说明：创建索引：create [unique] index idxname on tabname(col….)　　删除索引：drop index idxname　　注：索引是不可更改的，想更改必须删除重新建。9、说明：创建视图：create view viewname as select statement　　删除视图：drop view viewname10、说明：几个简单的基本的sql语句　　选择：select * from table1 where 范围　　插入：insert into table1(field1,field2) values(value1,value2)　　删除：delete from table1 where 范围　　更新：update table1 set field1=value1 where 范围　　查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!　　排序：select * from table1 order by field1,field2 [desc]　　总数：select count as totalcount from table1　　求和：select sum(field1) as sumvalue from table1　　平均：select avg(field1) as avgvalue from table1　　最大：select max(field1) as maxvalue from table1　　最小：select min(field1) as minvalue from table111、说明：几个高级查询运算词　　A： UNION 运算符　　UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。　　B： EXCEPT 运算符　　EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。　　C： INTERSECT 运算符　　INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。　　注：使用运算词的几个查询结果行必须是一致的。12、说明：使用外连接　　A、left （outer） join：　　左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。　　SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c　　B：right （outer） join:　　右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。　　C：full/cross （outer） join：　　全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。13、分组:Group by:　　 一张表，一旦分组 完成后，查询后只能得到组相关的信息。　　 组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准)　　 在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据　　 在selecte统计函数中的字段，不能和普通的字段放在一起；14、对数据库进行操作：　　 分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名15.如何修改数据库的名称:　　sp_renamedb old_name, new_name二、提升1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)　　法一：select * into b from a where 11（仅用于SQlServer）　　法二：select top 0 * into b from a2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)　　insert into b(a, b, c) select d,e,f from b;3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)　　insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件　　例子：..from b in Server.MapPath(.)\data.mdb  where..4、说明：子查询(表名1：a 表名2：b)　　select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)5、说明：显示文章、提交人和最后回复时间　　select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b6、说明：外连接查询(表名1：a 表名2：b)　　select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c7、说明：在线视图查询(表名1：a )　　select * from (SELECT a,b,c FROM a) T where t.a  1;8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括　　select * from table1 where time between time1 and time2　　select a,b,c, from table1 where a not between 数值1 and 数值29、说明：in 的使用方法　　select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)10、说明：两张关联表，删除主表中已经在副表中没有的信息　　delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )11、说明：四表联查问题：　　select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....12、说明：日程安排提前五分钟提醒　　SQL: select * from 日程安排 where datediff(minute,f开始时间,getdate())513、说明：一条sql 语句搞定数据库分页　　select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段　　具体实现：　　关于数据库分页：　　declare @start int,@end int　　@sql nvarchar(600)　　set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid-1)’　　exec sp_executesql @sql注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）14、说明：前10条记录　　select top 10 * form table1 where 范围15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)　　select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表　　(select a from tableA ) except (select a from tableB) except (select a from tableC)17、说明：随机取出10条数据　　select top 10 * from tablename order by newid()18、说明：随机选择记录　　select newid()19、说明：删除重复记录　　1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)　　2),select distinct * into temp from tablename　　delete from tablename　　insert into tablename select * from temp　　评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作　　3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段　　alter table tablename　　--添加一个自增列　　add column_b int identity(1,1)　　delete from tablename where column_b not in(　　select max(column_b) from tablename group by column1,column2,...)　　alter table tablename drop column column_b20、说明：列出数据库里所有的表名　　select name from sysobjects where type=U // U代表用户21、说明：列出表里的所有的列名　　select name from syscolumns where id=object_id(TableName)22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。　　select type,sum(case vender when A then pcs else 0 end),sum(case vender when C then pcs else 0 end),sum(case vender when B then pcs else 0 end) FROM tablename group by type显示结果：　　type vender pcs　　电脑 A 1　　电脑 A 1　　光盘 B 2　　光盘 A 2　　手机 B 3　　手机 C 323、说明：初始化表table1　　TRUNCATE TABLE table124、说明：选择从10到15的记录　　select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc三、技巧1、1=1，1=2的使用，在SQL语句组合时用的较多　　“where 1=1” 是表示选择全部 “where 1=2”全部不选，　　如：　　if @strWhere !=　　begin　　set @strSQL = select count(*) as Total from [ + @tblName + ] where  + @strWhere　　end　　else　　begin　　set @strSQL = select count(*) as Total from [ + @tblName + ]　　end　　我们可以直接写成　　set @strSQL = select count(*) as Total from [ + @tblName + ] where 1=1 安定 + @strWhere 2、收缩数据库　　--重建索引　　DBCC REINDEX　　DBCC INDEXDEFRAG　　--收缩数据和日志　　DBCC SHRINKDB　　DBCC SHRINKFILE3、压缩数据库　　dbcc shrinkdatabase(dbname)4、转移数据库给新用户以已存在用户权限　　exec sp_change_users_login update_one,newname,oldname　　go5、检查备份集　　RESTORE VERIFYONLY from disk=E:\dvbbs.bak6、修复数据库　　ALTER DATABASE [dvbbs] SET SINGLE_USER　　GO　　DBCC CHECKDB(dvbbs,repair_allow_data_loss) WITH TABLOCK　　GO　　ALTER DATABASE [dvbbs] SET MULTI_USER　　GO7、日志清除　　SET NOCOUNT ON　　DECLARE @LogicalFileName sysname,　　@MaxMinutes INT,　　@NewSize INT　　USE tablename -- 要操作的数据库名　　SELECT @LogicalFileName = tablename_log, -- 日志文件名　　@MaxMinutes = 10, -- Limit on time allowed to wrap log.　　@NewSize = 1 -- 你想设定的日志文件的大小(M)　　Setup / initialize　　DECLARE @OriginalSize int　　SELECT @OriginalSize = size　　FROM sysfiles　　WHERE name = @LogicalFileName　　SELECT Original Size of  + db_name() +  LOG is  +　　CONVERT(VARCHAR(30),@OriginalSize) +  8K pages or  +　　CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + MB　　FROM sysfiles　　WHERE name = @LogicalFileName　　CREATE TABLE DummyTrans　　(DummyColumn char (8000) not null)　　DECLARE @Counter INT,　　@StartTime DATETIME,　　@TruncLog VARCHAR(255)　　SELECT @StartTime = GETDATE(),　　@TruncLog = BACKUP LOG  + db_name() +  WITH TRUNCATE_ONLY　　DBCC SHRINKFILE (@LogicalFileName, @NewSize)　　EXEC (@TruncLog)　　-- Wrap the log if necessary.　　WHILE @MaxMinutes  DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expiredAND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)　　AND (@OriginalSize * 8 /1024)  @NewSize　　BEGIN -- Outer loop.　　SELECT @Counter = 0　　WHILE ((@Counter  @OriginalSize / 16) AND (@Counter  50000))　　BEGIN -- update　　INSERT DummyTrans VALUES (Fill Log) DELETE DummyTrans　　SELECT @Counter = @Counter + 1　　END　　EXEC (@TruncLog)　　END　　SELECT Final Size of  + db_name() +  LOG is  +　　CONVERT(VARCHAR(30),size) +  8K pages or  +　　CONVERT(VARCHAR(30),(size*8/1024)) + MB　　FROM sysfiles　　WHERE name = @LogicalFileName　　DROP TABLE DummyTrans　　SET NOCOUNT OFF8、说明：更改某个表　　exec sp_changeobjectowner tablename,dbo9、存储更改全部表　　CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch　　@OldOwner as NVARCHAR(128),　　@NewOwner as NVARCHAR(128)　　AS　　DECLARE @Name as NVARCHAR(128)　　DECLARE @Owner as NVARCHAR(128)　　DECLARE @OwnerName as NVARCHAR(128)　　DECLARE curObject CURSOR FOR　　select Name = name,　　 Owner = user_name(uid)　　from sysobjects　　where user_name(uid)=@OldOwner　　order by name　　OPEN curObject　　FETCH NEXT FROM curObject INTO @Name, @Owner　　WHILE(@@FETCH_STATUS=0)　　BEGIN　　if @Owner=@OldOwner　　begin　　 set @OwnerName = @OldOwner + . + rtrim(@Name)　　 exec sp_changeobjectowner @OwnerName, @NewOwner　　end　　-- select @name,@NewOwner,@OldOwner　　FETCH NEXT FROM curObject INTO @Name, @Owner　　END　　close curObject　　deallocate curObject　　GO10、SQL SERVER中直接循环写入数据　　declare @i int　　set @i=1　　while @i30　　begin　　 insert into test (userid) values(@i)　　 set @i=@i+1　　end案例：　　有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:　　 Name score　　 Zhangshan 80　　 Lishi 59　　 Wangwu 50　　 Songquan 69　　while((select min(score) from tb_table)60)　　begin　　update tb_table set score =score*1.01　　where score60　　if (select min(score) from tb_table)60　　 break　　else　　 continue　　end数据开发-经典1.按姓氏笔画排序:　　Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多2.数据库加密:　　select encrypt(原始密码)　　select pwdencrypt(原始密码)　　select pwdcompare(原始密码,加密后密码) = 1--相同；否则不相同 encrypt(原始密码)select pwdencrypt(原始密码)　　select pwdcompare(原始密码,加密后密码) = 1--相同；否则不相同3.取回表中字段:　　declare @list varchar(1000),　　@sql nvarchar(1000)　　select @list=@list+,+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name=表A　　set @sql=select +right(@list,len(@list)-1)+ from 表A　　exec (@sql)4.查看硬盘分区:　　EXEC master..xp_fixeddrives5.比较A,B表是否相等:　　if (select checksum_agg(binary_checksum(*)) from A)　　 =　　 (select checksum_agg(binary_checksum(*)) from B)　　print 相等　　else　　print 不相等6.杀掉所有的事件探察器进程:　　DECLARE hcforeach CURSOR GLOBAL FOR SELECT kill +RTRIM(spid) FROM master.dbo.sysprocesses　　WHERE program_name IN(SQL profiler,NSQL 事件探查器)　　EXEC sp_msforeach_worker ?7.记录搜索:　　开头到N条记录　　Select Top N * From 表　　-------------------------------　　N到M条记录(要有主索引ID)　　Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc　　----------------------------------　　N到结尾记录　　Select Top N * From 表 Order by ID Desc案例　　例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第31到第40个记录。　　select top 10 recid from A where recid not in(select top 30 recid from A)　　分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。　　 select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。解决方案　　1， 用order by select top 30 recid from A order by ricid 如果该字段不是自增长，就会出现问题　　2， 在那个子查询中也加条件：select top 30 recid from A where recid-1　　例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。　　set @s = select top 1 * from T where pid not in (select top  + str(@count-1) +  pid from T)　　print @s exec sp_executesql @s8：获取当前数据库中的所有用户表　　select Name from sysobjects where xtype=u and status=09：获取某一个表的所有字段　　select name from syscolumns where id=object_id(表名)　　select name from syscolumns where id in (select id from sysobjects where type = u and name = 表名)　　两种方式的效果相同10：查看与某一个表相关的视图、存储过程、函数　　select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like %表名%11：查看当前数据库中所有存储过程　　select name as 存储过程名称 from sysobjects where xtype=P12：查询用户创建的所有数据库　　select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name=sa)　　或者　　select dbid, name AS DB_NAME from master..sysdatabases where sid  0x0113：查询某一个表的字段和数据类型　　select column_name,data_type from information_schema.columns　　where table_name = 表名14：不同服务器数据库之间的数据操作　　--创建链接服务器　　exec sp_addlinkedserver ITSV ,  , SQLOLEDB , 远程服务器名或ip地址 　　exec sp_addlinkedsrvlogin ITSV , false ,null, 用户名 , 密码 　　--查询示例　　select * from ITSV.数据库名.dbo.表名　　--导入示例　　select * into 表 from ITSV.数据库名.dbo.表名　　--以后不再使用时删除链接服务器　　exec sp_dropserver ITSV , droplogins 　　--连接远程/局域网数据(openrowset/openquery/opendatasource)　　--1、openrowset　　--查询示例　　select * from openrowset( SQLOLEDB , sql服务器名 ; 用户名 ; 密码 ,数据库名.dbo.表名)　　--生成本地表　　select * into 表 from openrowset( SQLOLEDB , sql服务器名 ; 用户名 ; 密码 ,数据库名.dbo.表名)　　--把本地表导入远程表　　insert openrowset( SQLOLEDB , sql服务器名 ; 用户名 ; 密码 ,数据库名.dbo.表名)　　select *from 本地表　　--更新本地表　　update b　　set b.列A=a.列A　　from openrowset( SQLOLEDB , sql服务器名 ; 用户名 ; 密码 ,数据库名.dbo.表名)as a inner join 本地表 b　　on a.column1=b.column1　　--openquery用法需要创建一个连接　　--首先创建一个连接创建链接服务器　　exec sp_addlinkedserver ITSV ,  , SQLOLEDB , 远程服务器名或ip地址 　　--查询　　select *　　FROM openquery(ITSV, SELECT * FROM 数据库.dbo.表名 )　　--把本地表导入远程表　　insert openquery(ITSV, SELECT * FROM 数据库.dbo.表名 )　　select * from 本地表　　--更新本地表　　update b　　set b.列B=a.列B　　FROM openquery(ITSV, SELECT * FROM 数据库.dbo.表名 ) as a　　inner join 本地表 b on a.列A=b.列A　　--3、opendatasource/openrowset　　SELECT *　　FROM opendatasource( SQLOLEDB , Data Source=ip/ServerName;User ID=登陆名;Password=密码  ).test.dbo.roy_ta　　--把本地表导入远程表　　insert opendatasource( SQLOLEDB , Data Source=ip/ServerName;User ID=登陆名;Password=密码 ).数据库.dbo.表名　　select * from 本地表　　SQL Server基本函数　　SQL Server基本函数　　1.字符串函数 长度与分析用　　1,datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格　　2,substring(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度　　3,right(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反4,isnull( check_expression , replacement_value )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类　　5,Sp_addtype 自定義數據類型　　例如：EXEC sp_addtype birthday, datetime, NULL　　6,set nocount {on|off}使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。　　SET NOCOUNT 为 OFF 时，返回计数一、基础1、说明：创建数据库　　CREATE DATABASE database-name2、说明：删除数据库　　drop database dbname3、说明：备份sql server　　--- 创建 备份数据的 device　　USE master　　EXEC sp_addumpdevice disk, testBack, c:\mssql7backup\MyNwind_1.dat　　--- 开始 备份　　BACKUP DATABASE pubs TO testBack4、说明：创建新表　　create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)　　根据已有的表创建新表：　　A：create table tab_new like tab_old (使用旧表创建新表)　　B：create table tab_new as select col1,col2… from tab_old definition only5、说明：删除新表　　drop table tabname6、说明：增加一个列　　Alter table tabname add column col type　　注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。7、说明：添加主键：Alter table tabname add primary key(col)　　说明：删除主键： Alter table tabname drop primary key(col)8、说明：创建索引：create [unique] index idxname on tabname(col….)　　删除索引：drop index idxname　　注：索引是不可更改的，想更改必须删除重新建。9、说明：创建视图：create view viewname as select statement　　删除视图：drop view viewname10、说明：几个简单的基本的sql语句　　选择：select * from table1 where 范围　　插入：insert into table1(field1,field2) values(value1,value2)　　删除：delete from table1 where 范围　　更新：update table1 set field1=value1 where 范围　　查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!　　排序：select * from table1 order by field1,field2 [desc]　　总数：select count as totalcount from table1　　求和：select sum(field1) as sumvalue from table1　　平均：select avg(field1) as avgvalue from table1　　最大：select max(field1) as maxvalue from table1　　最小：select min(field1) as minvalue from table111、说明：几个高级查询运算词　　A： UNION 运算符　　UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。B： EXCEPT 运算符　　EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。　　C： INTERSECT 运算符　　INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。　　注：使用运算词的几个查询结果行必须是一致的。12、说明：使用外连接　　A、left （outer） join：　　左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。　　SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c　　B：right （outer） join:　　右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。　　C：full/cross （outer） join：　　全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。13、分组:Group by:　　 一张表，一旦分组 完成后，查询后只能得到组相关的信息。　　 组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准)　　 在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据　　 在selecte统计函数中的字段，不能和普通的字段放在一起；14、对数据库进行操作：　　 分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名15.如何修改数据库的名称:　　sp_renamedb old_name, new_name二、提升1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)　　法一：select * into b from a where 11（仅用于SQlServer）　　法二：select top 0 * into b from a2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)　　insert into b(a, b, c) select d,e,f from b;3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)　　insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件　　例子：..from b in Server.MapPath(.)\data.mdb  where..4、说明：子查询(表名1：a 表名2：b)　　select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)5、说明：显示文章、提交人和最后回复时间　　select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b6、说明：外连接查询(表名1：a 表名2：b)　　select a.a,'>经典sql语句大全</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>4</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/317144FB-B6AE-46FA-9627-CBD5CFF50ECA.html' title='mssqlserver数据导出到另外一个数据库准备源数据库，找到想要导出的数据库，右键选择任务再选择导出数据设置源数据库信息3.设置目标数据库，导出到的数据库信息4.设置要复制的数据这里有两大类，一是直接复制某些表，二是根据sql查询出的指定数据复制某些表的话选择第一项，之后选择要复制的表，选择之后点击完成按钮即可开始复制数据从源数据库到目标数据库选择第二个的话，需要提供sql以获取复制的数据集'>mssqlserver数据导出到另外一个数据库</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>5</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/CD968A6C-5FCA-4BC2-AF84-FF3405B5DA4A.html' title='数据库的高级应用数据库的高级应用数据库五大高级应用：视图（view）索引（index）存储过程（proc）触发器（trigger）事务（trans）●●●●●●●●●●●●下面将对这五大应用详细解●●●●●●●●●●●●一视图（view）：只是用来快速展示查询数据：主要内容：l视图的概念以及优缺点视图是一张虚拟表，他所展现的内容并没有存储在视图表中而是存储在他所引用的表中。优点;简化操作；根据不同用户定制不同数据；合并分割数据?话踩裕?/span>缺点：性能不高；数据修改受限；l单表视图多表视图基于视图的视图创建视图语法结构：Createview视图名[(column,```````)]--column列名[withencryption]As[Withcheckoption]--这条语句作用：1规定在视图上做过的修改必须符合引用表的要求；2通过视图修改的数据可以确保修改后的数据仍然可以通过视图看到。注意点：视图中的查询语句中不能包含orderby/compute/computeby或者是into关键字例子：1单表视图创建视图createviewjiageAsselect*fromCarwherePricebetween30and50go引用：select*fromjiage2带有where字段的视图Createviewview2AsSelect姓名，工资from职工where工资1800Go3带有计算字段的视图Go2多表视图3带有聚合函数的视图4更改原表中的字段名称createviewview1(车名,车的价格)--将新设置的列名在此设置。asselectname,pricefromCarwhereNamelike%宝马%goselect*fromview1l利用sql代码修改视图alterviewview1(啥车,多钱)--可以同时更改原有视图中的列名asselectname,pricefromCarwhereNamelike%奥迪%goselect*fromview1l利用sql删除视图《删除单张视图》dropview视图名《删除多张视图》dropviewview1，view2~~~~《带有判断条件删除视图》l视图数据的查询l通过视图添加更新以及删除数据二索引（index）创建索引：create[unique][clustered][nonclustered]indexindex-name1on[table|view](列名asc|desc)Unique创建唯一索引，即索引的键值不能重复，在列包含重复值是不能创建唯一索引；Clustered指明创建的索引为簇索引，如果此选项默认，则创建的为非簇索引。Nonclustered指明创建的索引为非簇索引例子：1创建普通索引createindexidex-sclon仓库备份（面积）2创建多列普通索引createindexidex-sc2on仓库备份（城市，创建时间）3删除索引dropindex表名.索引名dropindex仓库备份.index1三存储过程（proc）主要内容：l存储过程的分类以及优点定义：为了完成特定功能的sql集合，编译后存储在服务器端数据库中，利用存储过程可以加速sql语句的执行。存储过程可以分为两类：系统存储过程和自定义存储过程。系统存储过程：系统存储过程是在sql成功安装后存在系统数据库master中的，这些存储过程是以sp-为前缀命名的，主要功能是在系统表中获取信息，系统管理员可以通过简单的调用系统存储过程完成复杂的管理工作，调用系统存储过程时在其他非master数据库中也可以调用。自定义存储过程：有用户自己定义完成特定功能，返回值只能表明返回值执行是否成功而且只能利用想、execute完成存储过程。优点：1提高应用程序的通用性和可移植性2可以更有效的管理用户操作数据库的权限3可以提高sql的速度4减轻服务器的负担。l创建并执行存储过程语法结构：Createprocedure过程名@ming参数类型output~~~~~AsBegin命令块end创建完成后利用execute过程名[参数值~~][output]例子：1功能为求0-5之间的和alterprocproc3asdeclare@sumint,@aintselect@a=0,@sum=0while@a6beginset@sum=@sum+@aset@a=@a+1Endprint和是+cast(@sumasvarchar)GoExectuteproc3功能2判断系统商品库存以及购买者账户金额决定交易是否进行createprocshuiguo2@idssvarchar(10),@buyervarchar(10),@shuliangintas--判断库存if(selectnumbersfromFruitwhereIds=@idss)@shuliangbeginif(selectpricefromFruitwhereIds=@idss)*@shuliang(selectaccountfromLoginwhereUserName=@buyer)begin--减库存updatefruitsetnumbers=numbers-@shuliangwhereIds=@idss--减余额updateLoginsetAccount=Account-(selectpricefromFruit)*@shuliangwhereUserName=@buyerendelsebeginprint余额不足，请充值！endendelsebeginprint抱歉，库存不足！endgo功能3不带参数的存储过程4带输入参数的存储过程5带有输入参数的数据查询功能的存储过程6带有输入输出参数的存储过程7带有登陆判断功能的存储过程8带有判断条件的插入功能的存储过程（exists）9带有判断条件的删除功能的存储过程10带有判断条件的更新功能的存储过程11加密存储过程Createproc过程名WithencryptionAs命令块Go★查看存储过程的属性以及功能代码信息executesp_helpproc3--查询存储过程的属性信息executesp_dependsproc1--查询存储过程所使用的数据对象的信息,如果没有引用或者加密会提示没有引用.executesp_helptextproc3--查询存储过程的功能代码,如果加密后不能被查询到selectnamefromcarwheretype=p--能共查找本表创建存储过程的名字和时间l修改存储过程的功能代码Alterproc过程名@参数参数类型~~~~AsBegin命令行endl重命名存储过程Executesp_rename原名，新名l删除存储过程Dropproc过程名1，过程名2~~同时可以删除多个过程带有判断条件的删除存储过程（与ifexists语句结合）l存储过程的自动执行和监控lOracle和DB2数据库中存储过程的区别四触发器（trigger）l触发器与存储过程的区别1.存储过程是独立于表存在的，触发器需要依附某个表的某个操作。2.存储过程需要使用名称去调用才能执行，触发器则在表的操作过程中自动被触发调用。l触发器的分类和作用定义;触发器是一种特殊类型的存储过程，通过事件的触发来被执行，例如updatedeletedropalterdrop等。在sql中有两种方法可以保持数据的完整性和有效性：约束和触发器，约束直接设置在表内只能执行一些比较简单的功能，而触发器可以执行比较复杂的过程。作用：1可以调用存储过程2强化数据条件约束3跟踪数据库内数据的变化并判断数据变化是否符合数据库的要求4级联和并行运行。分类：DML触发器DDL触发器DML触发器：datamanipulationlanguage又可以分为事后触发器（after触发器）替代触发器（insteadof）After触发器先执行变得增删改操作后在触发触发器。Insteadof触发器不执行表的增删改操作，它的这些操作只起到触发触发器的功能。DDl触发器用来执行数据库的管理任务。注释：触发器中两个临时表：inserted,deleted这两个表是临时表，触发器执行完成后，会自动消失，再次触发会再次创建。这两个表的结构与on后面的那表的结构是一样的（列名、列数、类型）。而且里面只有一条记录。插入操作--把新增的数据放到inserted表中。删除操作--把删除的数据放到deleted表中。修改操作--把旧数据放到deleted表中，把新数据放到inserted表中。对两个临时表的使用。从两个临时表中把数据取出来放到变量中，以备后面的使用。l创建执行事后触发器After触发器注意事项：触发器名在同一数据库中是唯一的；可以利用withencryption对触发器进行加密；只能定义在数据表中不能定义在视图上；after触发器的动作只能是updatedeleteinsert三种其中的一种或者多种。创建语法：Createtrigger触发器名on表名forinsert[updatedelete]AsBegin命令End实例：运行触发器当数据表进行增删改时自动发送邮件Createtrigger触发器名on表名forinsert[update，delete]AsbeginExecutexp_sendmail‘邮箱地址’endl创建与执行替代触发器注意点：insteadof触发器主要作用是使不可修改的视图能够支持修改。当然也可以对表进行操作。构建语法：Createtrigger触发器名on表名或者视图名insteadofinsert[deleteupdate]AsBegin命令块EndGol查看触发器的属性以及功能代码信息l修改触发器的功能代码l重命名和删除触发器Sp_rename原名，新名--重命名触发器Droptrigger触发器名【123】--可以同时删除多个触发器l禁用和启用触发器Altertable表名disabletrigger触发器名禁用触发器Altertable表名enabletrigger触发器名启用触发器Altertable表名enabletrigger触发器名1，触发器名2启用多个触发器触发器Altertable表名enabletriggerall启用这个表中的所有触发器l创建与执行ddl触发器DDL触发器一般用于数据库的管理工作，其触发事件为createalterdrop开头的语句创建DDl触发器语法结构：Createtrigger触发器名on服务器或者是数据库For或者aftercreate[dropalter]Asbegin命令块End注意点：DDl触发器没有替代触发器只有事后触发器，不同是作用于数据库还是服务器l修改和删除ddl触发器l触发器的使用五事务（begintransrollback返回commit确定）'>数据库的高级应用</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>6</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/47BC4CE7-CF5B-44CE-85CC-41828B1D0AD9.html' title='COALESCE作用是返回第一个非空的值。SELECTCOALESCE(NULL,NULL,A,CC)----A原理的话其实也是相当于case when A is not null then A　　　when B is not null then B　　　　.　　　　.　　　　.　　　　else N end对于简化代码来说确实不错~--总结下面3点--1、不能所有常量都使用NULL,只有报错的份SELECTCOALESCE(NULL,NULL)    --2、针对情况1，用变量的话是可以的！DECLARE@AINT=NULL,@BVARCHAR(50)=NULLSELECTCOALESCE(@A,@B)-----------NULL--3、小心数据类型差异！！小心数据类型差异！！小心数据类型差异！！--COALESCE返回各项里面数据类型最高级的类型SELECTCOALESCE(1,A)--OKSELECTCOALESCE(A,1)--报错就是这个原因'>简单说下COALESCE这个日常使用的函数</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>7</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/6BAB3001-A0F7-4A1E-A341-2DD64971773C.html' title='1.查询全体学生的学号与姓名select sno,snamefrom student;3.查询全体学生的详细信息select *from student;4.查询全体学生的姓名及其出生年份select sname,2004-sagefrom student;5.查询全体学生的姓名，出生年份和所在院系，要求用小写字母表示所有系名select sname,year of birth:,2004-sage,lower(sdept)from student;6.查询选修课程的学生学号，DISTINCT去掉重复行select DISTINCT snofrom SC;select snofrom SC;等价于select ALL snofrom SC;7.查询计算机科学系全体学生的名单select snamefrom studentwhere sdept=cs;8.查询所有年龄在20岁以下的学生姓名及其年龄select sname,sagefrom studentwhere sage20;9.查询考试成绩有不及格的学生的学号select DISTINCT snofrom scwhere grade60;10.查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名，系别和年龄select sname,sdept,sagefrom studentwhere sage between 20 and 23;11查询年龄不在20~23岁之间的学生的姓名，系别和年龄select sname,sdept,sagefrom studentwhere sage not between 20 and 23;12.查询计算机科学系cs，数学系ma和信息系is学生的姓名和性别select sname,ssexfrom studentwhere sdept in(cs,ma,is);13.查询不是计算机科学系cs，数学系ma和信息系is学生的姓名和性别select sname,ssexfrom studentwhere sdept not in(cs,ma,is);14.查询学号为200215121的学生的详细情况select *from studentwhere sno like 200215121;等价于select *from studentwhere sno=200215121;15.查询所有姓刘的学生的姓名，学号和性别select sname,sno,ssexfrom studentwhere sname like 刘%;16.查询所有不姓刘的学生的姓名，学号和性别select sname,sno,ssexfrom studentwhere sname not like 刘%;17.查询姓欧阳且全名为3个汉字的学生的姓名select snamefrom studentwhere sname like 欧阳_;19.查询DB_Design课程的课程号和学分select cno,ccreditfrom coursewhere cname like DB\_DesignESCAPE\;ESCAPE\表示\为换码字符。这样匹配串中紧跟着\后面的字符_不再具有通配符的含义，转义为普通的_字符20.查询以DB_开头，且倒数第3个字符为i的课程的详细情况select *from coursewhere cname like DB\_%i__ESCAPE\;21.查询缺少成绩的学生的学号和相应的课程号select sno,cnofrom scwhere grade is null;22.查询计算机科学系年龄在20岁以下的学生姓名select snamefrom studentwhere sdept=cs and sage20;23.查询计算机科学系cs，数学系ma和信息系is学生的姓名和性别select sname,ssexfrom studentwhere sdept=cs or sdept=ma or sdept=is;24.查询选修了3号课程的学生的学号及其成绩，查询结果按分数的降序排序select sno,gradefrom scwhere cno=3order by grade DESC;25.查询全体学生情况，查询结果按所在系的系号升序排列，同一系的学生按年龄降序排列select *from studentorder by sdept,sage DESC;26.查询学生总人数select COUNT(*)from student;27.查询选修了课程的学生人数select COUNT(DISTINCT sno)from sc;28.计算1号课程的学生的平均成绩select AVG(grade)from scwhere cno=1;29.查询选修1号课程的学生的最高分数select MAX(grade)from scwhere cno=1;30.查询学生200215012选修课程的总学分数select SUM(ccredit)from sc,coursewhere sno=200215012 and sc.cno=course.cno;31.求各个课程号及相应的选课人数select cno,count(sno)from scgroup by cno;32.查询选修了3门以上课程的学生学号select snofrom scgroup by snohaving count(*) 3;33.查询每个学生及其选课情况select student.*,sc.*from student,scwhere student.sno=sc.sno;35.查询每一门课的间接先修课select first.cno=second.cpnofrom course first,course secondwhere first.cpno =second.cno;36.select student.sno,sname,ssex,sage,sdept,cno,gradefrom student left out join sc on (student.sno=sc.sno);37.查询选修2号课程且成绩在90分以上的所有学生select student.sno,snamefrom student,sc<span style="font-family: ms shell dlg; font-size: 14px; line-height: 28px;  background-color: rgb(255, 2'>SQL查询语句基础</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>8</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/CF744C8F-7794-4CAB-BFCB-609EECFB3559.html' title='今日匆忙中写了2各存储过程，查询的表，查询的结构，返回的值基本一样，就是对参数的使用有点不同。晚上到家想着优化下，看看能不能合并了。在几次重写后，拿着几个版本查看执行计划时，发现个以前没注意的问题。第一个SP传入的2个时间参数直接用于里面的查询条件。第二个SP传入的2个时间参数，在SP内又定义了2个时间变量，将参数通过简单计算后Set给了2个变量，然后在查询中使用这2个变量作为条件。这2个SP，在执行开销上相差数倍。在外面套一层SP，把时间算好了再当参数传给第二个SP，修改SP直接使用参数作为查询的条件，2个SP的开销就一样了。这是怎么回事呢，SP里面对参数和变量的使用会对性能有多大的影响呢？暂时没时间去仔细了解和分析。'>存储过程中使用参数和变量作为查询条件对性能的影响？</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>9</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/592ADD07-46F4-435C-ACB6-355527A557FE.html' title='有时候存储过程使用自定义表类型，就一个字~方便，类似于整个table直接传入到存储过程里面去玩，比起万能的xml~ 还不用解析，直接能用~多方便。但是！！！使用自定义表变量，并不一定是一帆风顺的~比如说和如果调用的参数不是有数据库这边来组装，由程序去控制传入的时候，我目前发现的就有以下2个地方十分的需要注意1、字段顺序！  在我们看来，自定义表变量，就当时一个普通的表进行使用，赋值，写插入，直接insert select 就完事了~但是，如果写在存储过程的传入参数里面，确不一定这样看，程序传入，生成的表变量，是严格按照表的字段顺序去插入的。其实也就是 insert into biao变量 values () 这样的语句。所以，有时候数据库调试没问题，但是程序调用的时候直接报错，有可能就是这个问题了，这个最直接的例子就是，在建自定义表类型中间的字段有个默认值，程序传的时候没赋值……然后一调用，直接就报插入字段数目不对了2、标识列！  同理，标识列并不能在程序里面直接Insert进来，所以直接报错╮(╯_╰)╭。应该来说，这2方面的问题可大可小，发现起来也不难，只是日常发现了~就跟大家分享一下'>关于自定义表类型遇到的问题~</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>10</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/120B05A5-896D-4532-B3AD-B65E35D4D010.html' title='create trigger CMD_MST_RodID on CMD_MSTafter insert asbeginUPDATE CMD_MST SET RodID=  where CmdSno=CMD_MST.CmdSno;end;'>SQL Server（Trigger）触发器</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>11</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/79F0B9BD-FF6D-4B0B-A65D-56050AB96B7F.html' title='人名模糊查找，是一个非常寻常的功能。然而用起来发现了一个问题比方说我有一个人员Table 数据量大概300W。人名那列有索引--这个是背景故事然后看下以下这两句，是不是并没有什么卵区别DECLARE@NameNVARCHAR(50)=黄小ASELECT*  FROMdbo.tb_personsWHEREpess_fullnameLIKE%+@Name+%SELECT*  FROMdbo.tb_personsWHEREpess_fullnameLIKE%黄小A%是的！在平时执行的时候，确实没有区别，在300W的数据里面直接秒出结果。然而在存储过程里面就不一样了~CREATEPROCTmp_Proc  (@NameNVARCHAR(50)  )ASSETNOCOUNTON;SETTRANSACTIONISOLATIONLEVELREADUNCOMMITTED;SELECTpess_id,pess_fullnameFROMdbo.tb_personsWHEREpess_fullnameLIKE%+@Name+%GOCREATEPROCTmp_Proc2ASSETNOCOUNTON;SETTRANSACTIONISOLATIONLEVELREADUNCOMMITTED;SELECTpess_id,pess_fullnameFROMdbo.tb_personsWHEREpess_fullnameLIKE%黄小变%GO执行起来是不是一样？？ NO !上图，存储过程1执行了接近5S，存储过程2确实正常的50毫秒，怎么会这样呢？然后我开启了Profile ,终于发现问题，存储过程1里面Parallel里面的并行全部是0，没有启用并行存储过程2就还是简单明了，并行运行。╮(╯_╰)╭原来还有这一套要解决这个问题。可以在存储过程里面使用动态语句进行拼接，就可以还是使用并行了yeah~'>奇妙的并行问题</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>12</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/EA430279-B6A9-4B9C-8C01-7A01F6E4104F.html' title='昨晚上老同事聚会，一个同事说道一个面试问题没有一个人做出来，就是求连续日期登录次数最大的用户，同事说借助 rownumber即可求解，由于是喝酒聊天，也没有说详细的解决过程。今天早上想了下，终于想到了具体的解决思路。登录时间里面有详细的时分秒数据，而我们的题目只要求连续的天数，所以使用DATEDIFF函数可以解决，DATEDIFF(d,LoginTime,getdate())asdiffDate,有多个用户都在登录，因此应该以用户名为分区，登录时间为顺序来计算rownumber，因此，就是下面的表达式：ROW_NUMBER()over(partitionbyNameorderbyLoginTimedesc)asrn关键问题来了，如何求得连续的登录情况？如果是连续的记录，那么 diffDate- rn 肯定是相同的！OK，果然这种方式很巧妙，那么我们最终的SQL写出来也不难了。开始动手，先构造一个表，插入初始数据：/*  求连续登录次数最多的用户*/createtableUserLoginInfo(  IDintIDENTITYprimarykey,  Namevarchar(50)notnull,  LoginTimedatetimenotnull  )go    insertUserLoginInfo(Name,LoginTime)values(zhang,2015-11-1012:01:50)  ,(li,2015-11-1111:01:50)  ,(wang,2015-11-911:01:50);go    insertUserLoginInfo(Name,LoginTime)values  (zhang,2015-11-1112:01:50),  (li,2015-11-1112:01:50),  (wang,2015-11-1111:01:50),    (zhang,2015-11-1212:01:50),  (li,2015-11-1313:01:50),  (wang,2015-11-1211:01:50),    (zhang,2015-11-1312:01:50),  (li,2015-11-1411:01:50),  (wang,2015-11-1411:01:50);go然后用下面的SQL得到结果：selecttop1  Name,diffRn,COUNT(diffRn)asLoginCount  from(selectName,diffDate,rn,(diffDate-rn)asdiffRn  from(  selectID,Name,  DATEDIFF(d,LoginTime,getdate())asdiffDate,  ROW_NUMBER()over(partitionbyNameorderbyLoginTimedesc)asrnfromUserLoginInfo  )t1  )t2groupbydiffRn,Name  orderbyLoginCountdesc答案是：NamediffRnLoginCount  zhang144如果注释掉 top 1，我们就知道这个结果的由来了：NamediffRnLoginCount  zhang144li133wang142wang151li141wang131这个问题也可以衍生出 求连续登录的用户，或者求连续登录15天的用户（比如QQ的签到功能），是不是很熟悉呢？实际上，上面这个查询，遇到一天登录多次的情况下，统计是不准确的，例如，构造下面的测试数据：View Code这时应该先去除某天的重复数据，才是正确的，所以查询应该做如下改进：select--top1  Name,diffRn,COUNT(diffRn)asLoginCount  from(selectName,diffDate,rn,(diffDate-rn)asdiffRn  from(  selectName,  diffDate,  ROW_NUMBER()over(partitionbyNameorderbydiffDateasc)rnfrom(  selectdistinctName,DATEDIFF(d,LoginTime,getdate())asdiffDate  fromUserLoginInfo  )t0  )t1  )t2groupbydiffRn,Name  orderbyLoginCountdesc;结果是：NamediffRnLoginCount  zhang144wang142li132li142li482li4112li7742wang131wang151结果符合我们的预期，算是完整的答案了。不知道别的同学还没有更好的解决方案？-------------------------------------------PS：如果你经常会在程序中写这样复杂的SQL，推荐你使用PDF.NET SOD框架的SQL-MAP功能，将SQL写在配置文件中，集中管理，并且方便跨数据库移植。SOD框架PDF.NET_SOD Ver 5.3.6.1125已经发布，喜欢的朋友可以下载当前这个最新的稳定版本，有问题，可以加框架的QQ群：PDF.NET SOD高级群 18215717'>求连续操作（登录）数量（次数）最大的记录（用户）</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>13</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/6F8E28A0-2980-4AB9-BB9D-7E0F3CF9A179.html' title='一SQL报表常常会遇到在表格中的相除，如果分母为零，一般会显示错误号，我们可以这么处理：（加上是A/B）=A/iif(B=0,99999999999999,B)但是我们不能这么写：=iif(B=0,0,A/B)//我们不能这么写，会产生BUG，至于什么BUG，你们可以自己试试二我们假设报表中的某一个格子的名字为A，我们在A中需要引用另一个格子B的值，在这种情况下，我们通常会把B中的计算公式再次引用在A中复制一遍，这样很导致很麻烦。我们可以在A中直接这么写：ReportItems!B表的名字.Value这样就不需要再一次得把公式写一遍了三在报表曲线图中的横坐标，倘若我们需要动态得变化横坐标，我们这时候一般会把轴选项设置为自动，但是这样往往得不到我们想要的结果，下面的例子就是根据参数（开始时间和结束时间）的间隔动态地改变横坐标的样式水平轴属性》数字》自定义=IIf(Parameters!startime.Value=Parameters!endtime.Value,,iif(DateAdd(DateInterval.day,-4,Parameters!endtime.Value)=Parameters!startime.Value,MM/dd,M/dH:mm))'>SQL报表(Report Builder)里面的几个常见问题</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>14</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/9F8E3AA6-3EE8-4C9F-9F7F-86F3E77C7B12.html' title='我们每个人都知道是个不好的做法，但有时我们还是要这样做：我们执行SELECT*语句。这个方法有很多弊端：你从你的表里返回每个列，甚至后期加的列。想下如果你的查询里将来加上了VARCHAR(MAX)会发生什么……对于指定的查询，你不能定义覆盖非聚集索引来克服执行计划里的查找（lookup）运算符，因为你会在额外的索引里重复你的数据……现在的问题是你如何阻止SELECT*语句？当然你可以进行代码审核，你可以提供最佳模式指导，但谁最终会留意这些？基本上没有人——很遗憾这就就是令人伤心的事实……但有一个非常简单方法来阻止SELECT*语句，在表里用技术层面来解决。这个问题的解决方法非常简单：在你的表定义上增加一个产生除零错误的的计算列。这个方法超简单，但却真正有效。我们来看下面的表定义：复制代码1--Createasimpletablewithacomputedcolumnthatgenerates2--adividebyzeroexception.3CREATETABLEFoo4(5Col1INTIDENTITY(1,1)NOTNULLPRIMARYKEY,6Col2CHAR(100)NOTNULL,7Col3CHAR(100)NOTNULL,8DevelopersPainAS(1/0)9)10GO1112--Insertsometestdata13INSERTINTOFooVALUES(a,a),(b,b),(c,c)14GO复制代码如你所见，我这里增加了一个进行除零的计算列。这表示当是查询这个列时，你会得到一个错误信息——例如在SELECT*语句里：1--ASELECT*statementdoesntworkanymore,ouch...2SELECT*FROMFoo3GO但另一方面如果你通过名称指定查询列，你不会反悔计算列，你的查询如愿正常执行：1--ThisSQLstatementworks2SELECTCol1,Col2,Col3FROMFoo3GO很不错吧，是不是？小结在各个交流会上我经常提到：有时我们只是变得太复杂了！这个用计算列的方法非常简单——肯定需要表架构修改。但下次设计新表的时候，要记得用这个方法。感谢关注！参考文章：www.sqlpassion.at/archive/2015/10/26/how-to-prevent-select-statements/注：此文章为WoodyTu学习MSSQL技术，收集整理相关文档撰写，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出此文链接！若您觉得这篇文章还不错请点击下右下角的推荐，有了您的支持才能激发作者更大的写作热情，非常感谢！'>如何阻止SELECT星号语句</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>15</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/0532E943-7F1B-4E0B-B2A2-94290202DE19.html' title='空间索引，一个专门用来处理空间数据计算的索引，目前支持STContains()、STDistance()、STEquals()、STIntersects()、STOverlaps()、STTouches()和STWithin()然而通常我们平常使用的，通常就是STDistance() 求两点之间的距离。更加详细の资料，请戳：https://msdn.microsoft.com/zh-cn/library/bb895265(v=sql.120).aspx先看下空间索引的创建语法，简单的必填项就是酱~CREATESPATIALINDEXIndexName ON#Tmp(GeographyCoordinate)   WITH(BOUNDING_BOX=(XMIN=-180,YMIN=-90,XMAX=180,YMAX=90)) *最好要保证最大最小值要覆盖整个坐标系的值域，否则不能最有效使用索引好，上个不太严谨的Sample然后我们测试一下。创建了一个模拟酒店表 (数据量大概是45W左右)  Hotel，只有主键，其他没有任何东西，坐标存在GeographyCoordinate 的栏位里面  Tmp_Hotel1 ，结构和Hotel完全一致，并在GeographyCoordinate 里面创建了一个空间索引。DECLARE@DTDATETIME=GETDATE()DECLARE@GEOGEOMETRY=GEOMETRY::STGeomFromText(POINT(39.866620.017),0)  SELECTDATEDIFF(ms,@DT,GETDATE())SELECT*  FROMHotelWHEREGeographyCoordinate.STDistance(@GEO)0.43SELECTDATEDIFF(ms,@DT,GETDATE())SELECT*  FROMTmp_Hotel1WHEREGeographyCoordinate.STDistance(@GEO)0.43SELECTDATEDIFF(ms,@DT,GETDATE())结果如下 ，可见第一句执行了1320ms ,第二句仅仅执行了 50ms，这是一个坐标在45W数据里面的大概分析情况然后我们把比对的数据扩大10条，比如说我要找这10个酒店5公里之内的其他酒店。首先我会建个临时表存放那10间酒店的位置。--随机取10条，避免被读取顺序误导SELECTTOP10ID,  GeographyCoordinateINTO#TmpFROMdbo.Hotel  WHEREORDERBYNEWID()顺手开个统计看看SET STATISTICS IO ON#Tmpba.GeographyCoordinate.STDistance(b.GeographyCoordinate)a.#Tmpba.GeographyCoordinate.STDistance(b.GeographyCoordinate)结果 28s,还有8次的Hotel物理扫描 ╮(╯_╰)╭表 #Tmp。扫描计数 1，逻辑读取 9 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Hotel。扫描计数 8，逻辑读取 241960 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Worktable。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Worktable。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。第二位空间索引选手的表现呢，执行时间18s。看起来比没有索引好不了多少表 Tmp_Hotel1。扫描计数 0，逻辑读取 1332493 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Worktable。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Workfile。扫描计数 48，逻辑读取 1384 次，物理读取 96 次，预读 1440 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 extended_index_907150277_384000。扫描计数 5413，逻辑读取 18390 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 #Tmp。扫描计数 1，逻辑读取 9 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。然而，根据资料，欲用空间索引，必先在Where 和 OrderBy 使用效果更佳。加上Order By 试下SELECTa.*,b.IDFROMdbo.Tmp_Hotel1aINNERJOIN#TmpbONa.GeographyCoordinate.STDistance(b.GeographyCoordinate)0.43  ORDERBYa.GeographyCoordinate.STDistance(b.GeographyCoordinate)执行时间6S，比没有OrderBy 选手好多了~表 #Tmp。扫描计数 1，逻辑读取 9 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Tmp_Hotel1。扫描计数 0，逻辑读取 1332549 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Worktable。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Workfile。扫描计数 48，逻辑读取 1440 次，物理读取 96 次，预读 1440 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 extended_index_907150277_384000。扫描计数 5413，逻辑读取 18525 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Worktable。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。看IO其实两边差不多，为什么时间差辣么远？我看了一下才发现，加上了OrderBy 之后，执行计划会使用并行，所以速度刷一下上去了--尝试一下看看帮#Tmp加个空间索引会不会有更大提升ALTERTABLE#TmpADDCONSTRAINTPK_TmpPRIMARYKEY(ID)CREATESPATIALINDEX#IX_TmpON#Tmp(GeographyCoordinate)WITH(BOUNDING_BOX=(XMIN=-180,YMIN=-90,XMAX=180,YMAX=90))再执行一下第二句，执行时间也是差不多，应该是临时表数据量太少，没有走到索引，╮(╯_╰)╭。表 #Tmp。扫描计数 1，逻辑读取 3 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次?琹ob 预读 0 次。表 Tmp_Hotel1。扫描计数 0，逻辑读取 1332553 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Worktable。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Workfile。扫描计数 48，逻辑读取 1376 次，物理读取 96 次，预读 1440 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 extended_index_907150277_384000。扫描计数 5413，逻辑读取 18546 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。表 Worktable。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。其实到这里，我觉得有个定性的认识就差不多了。总结：要使用空间索引1、主要对付查询STDistance 函数等问题。2、建索引的时候边界范围要禁可能包含出现的值域3、在Where条件和 OrderBy 都要使用 STDistance函数4、特别注意Null 值会影响空间索引的性能写在最后：其实我也想过一下其他替代STDistance建空间索引的方式。1、建一个对照表，预先做个笛卡尔积，这样就可以不用调度函数 （想到此方法先给自己2个耳光，维护成本太高了）2、可以把XY值抽取出来，用个游标来做数值计算，不使用STDistance 进行计算。这样我测试过性能还算可以。（但是逼格不够高，而且看起来有点蠢╮(╯_╰)╭）3、一般来说可以用Top 或者其他条件加强筛选，减少待计算的数据量，也有助于提高性能。'>空间索引应用</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>16</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/FE1918AF-838A-40D0-98C7-94FA647C1BE6.html' title='防止sql注入的三种方法常用的避免SQL注入的三种方法一，存储过程  在学习数据库视频的时候接触过，它是存储在数据库中的一些事先编译好的指令。在用的时候不用重新编写，直接调用就好了。所以，使用它可以大大提高程序的执行效率。那么，如果创建一个存储程序并使用它呢？这是我们今天要解决的问题1.创建过程  可编程性——下拉菜单——存储过程——右键——查询菜单——指定模板参数的值——新建查询——输入语句——查询菜单中的分析检查语法是否正确——执行     2.具体创建语法    在创建存储程序时，为了应对各种变换的数据，通常会涉及到带参数的存储程序，其中参数用@来表示。  Create Procedureprocedurename[:number] --[number]表示一组存储程序中的第几个，如果只有一个，此参数可忽略  [@parameter data_type] [default] [OUTPUT] --@parameter表示存储过程中的参数，default表示默认值，OUTPUT表示输出值即输出值as SqlStatement --[]代表可选参数  3.具体执行过程  exec[ute]procedurename [参数]  举例：--创建CreateProcedurescores @score1smallint, @score2smallint, @score3smallint,@secre4smallint, @score5smallint, @myAvgsmallint Output --Output可用return来代替 As select @myAvg=(@score1+@score2+@score3+@score4+@score5)/5 --调用过程Declare@avgscore smallint --将输出结果放在avgscore中Execavgscore Output 5,6,7,8,9, --带有参数的存储过程调用时，必须加上Output关键字，否则SQL会当做参数来对待小结：存储程序的创建可分为带参数和不带参数，以及含有默认值和输出值的存储程序，但是他们的使用原理是一样的。只是带输出值得存储程序在调用过程中要使用关键字Output来对要输出的变量进行声明，否则SQL会将它当做参数来处理。注意：创建存储程序后，我们可以在编写程序时，直接调用存储程序的名称来代替复杂的查询语句：strSQL=select .....; strSQL=Execte produreName二、参数化SQL是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值，用@或？来表示参数。 在使用参数化查询的情况下，数据库服务器不会将参数的内容视为SQL指令的一部份来处理，而是在数据库完成SQL 指令的编译后，才套用参数运行，因此就算参数中含有恶意的指令，由于已经编译完成，就不会被数据库所运行,因此，可从一定程度上避免SQL注入。参数化SQL在不同数据库中支持的方式有一定的差别。SQL server中二者均支持。在不用的数据库上基本语法都是一样的，但在不同的运行平台上客户端的书写有不同之处，在这里就拿现在我正在学习的SQL server在.net上执行来举例。--SQL server中的参数化SQL语句: SELECT * FROM myTable WHERE myID = @myID INSERT INTO myTable (c1, c2, c3, c4) VALUES (@c1, @c2, @c3, @c4).在.NET上执行SqlCommand sqlcmd = new SqlCommand(INSERT INTO myTable (c1, c2, c3, c4) VALUES (@c1, @c2, @c3, @c4), sqlconn);sqlcmd.Parameters.AddWithValue(@c1, 1);  设定参数 @c1 的值。sqlcmd.Parameters.AddWithValue(@c2, 2);  设定参数 @c2 的值。sqlcmd.Parameters.AddWithValue(@c3, 3);  设定参数 @c3 的值。sqlcmd.Parameters.AddWithValue(@c4, 4);  设定参数 @c4 的值。sqlconn.Open();sqlcmd.ExecuteNonQuery();sqlconn.Close();在向command中增加参数时，还有其他的方法，如：sqlcmd.parameters.Add(@c1,SqlDbType.BigInt) BigInt为c1的数据类型sqlcmd.parameter(@c1).value=1 设定值三、Regular Expression 简称REs是一种非常强大的文字验证技术。通常我们在设计程序时，如果要在TEXT中输入数字的话，那么我们会用到IsNumberic函数来限制，但是很多情况，为了用户方便，我们不止要用到限定数字这一个技术，还有很多关系式需要我们去遵循，如手机号码要限定成11为，邮箱号码要限制相应的格式等。这时候就用到了REs这种技术。它可以为我们要输入的内容提供一个模板，让用户的输入必须遵循这个模板的格式，如果格式不正确，则程序不能继续执行。这样也可以避免SQL注入。例如\d -------代表数字\d{5} -------代表5位数字\w+@\w+ -------@前的w+表示要有至少一个的字符，@代表这个模板中必须有一个@字符。当然在使用这种技术之前，是有条件的，首先，它需要引用一个命名空间，具体如下：Imports RE=System.Text.RegularExpressions.Regex这样还不够，我们需要一个方法来做验证用户输入是否正确的工作，这里，我们要用到一个方法match，具体使用如下：Dim input,pattern As StringInput=Me.txtInput.TextTrim()Pattern=Me.txtPattern.TextIf Re.Mathc(input,pattern).Success Then ‘使用Match方法来对用户输入的内容与定义好的模板进行验证MessageBox.Show(True,input matches pattern) Else MessageBox.Show(False,input does not match pattern) End if以上，是?ü?net视频总结出来的避免SQL注入的三种方法，由于对专业知识了解有限，具体原理并不清楚，有待以后深入学习后总结。'>防止sql注入的三种方法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>17</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/CF394B54-C44F-4D2C-9E6B-D1E74F3A24C0.html' title='SQL---------表的约束表的约束防止同一条数据完全重复：主键约束（primarykey）唯一键约束（unique），自增长；防止数据为空：非空约束（notnoll），默认值；防止乱填数据：外键，定义数据类型，check；1主键约束（Primarykeyconstraint）要求主键能够唯一区分每一行数据，主键可以是一列也可是几列组合成主键，并且不允许为空，表中的数据按照主键有序排列，l语句操作：altertablestuinfoaddconstraintpk-srunoprimarykey(stuno)l表格操作：在表的设计界面，在相应的列上，右击-设为主键/删除主键；2唯一约束(uniqueconstraint)要求该列唯一，允许为空，但只能出现一个空值l语句操作：altertablestuinfoaddconstraintunique（stuid）l表格操作：在表的设计界面上，右击--“索引/键”在弹出窗口上，点击左下角“添加”,右侧属性列表，修改类型——唯一键，设置列例子qq号与qq邮箱的关系3检查约束（checkconstraint）某列取值范围格式限制等例如有关年龄的限制4默认约束（defaultconstraint）某列的默认值语句操作：sxexvarchar(2)default(男),表格操作：在表的设计界面，选择相应的列，在下面的属性面版中——默认值例子insertintoStudente(sno,sname,sbirthday,class)values(201,小王,1974-06-03,95031)5外键约束（foreeignkeyconstraint）用于建立两表之间的关系，需要制定引用主表的那一列三、自增长列：标识列，Identity列1.不能手动向里面填值。如果要写insert语句的话，则语句应当把这一列忽略2.自增长列主要用于整型、长整型，Decimal类型。3.不要随便把自增长列作为主键。--操作：在表的设计界面中，选中相应的列，在下面的属性面版——“标识规范”--选择是防止有些该填的没有填：一、非空约束不能为NULL。操作：在表的设计界面中“允许NULL值”中的复选框去掉。二、默认值。如果不给列赋值的话，会使用默认值填上。操作：在表的设计界面，选择相应的列，在下面的属性面版中——默认值防止乱填：一、Check约束。按照某种规则对数据进行检查。操作：在表的设计界面中，右击相应的列，选择“CHECK约束”在弹出的对话框中，设置约束的名称和表达式。二、外键约束。主表，从表。主表是用来约束从表的。外键应当建在从表上。使用主表的主键来约束从表外键。从表中的外键列是不能随便乱填内容的，它只能填写主表主键中存在的数据。一旦建立起外键关系来，从表的外键不能乱填，反过主表中的主键列也不能乱删除乱改。级联删除的设置——整理操作：先建好主表，在从表的设计界面上，右击-“关系”，在弹出的对话框中选择“添加”，在右边属性列表中设“表和列的规范”三、类型。完整性包括1实体完整性数据行不能存在重复2域完整性实现了对输入到特定列的数值的限制3引用的完整性1要求子表中的相关项必训在主表中也存在2如果建立了主表和子表则子表中的相关项目的数据，在主表中必须存在3主表中相关的项数据更改了，则子表中的数据也要相应的更改4在删除子表前主表不能删除四自定义完整性创建表包括选择字段的名称数据类型定义是否为空设置默认值主键外键关系检查约束等。表中没有合适的列作为主键可以创建标示列。sql中存在的5中约束添加约束的方法：altertable表名addconstraint约束名约束类型具体的约束说明约束名取名规则：主键pk-stuno唯一uq默认de检查ck外键fk代码添加约束书写方法(以表格stuinfo)添加主键约束：添加唯一键约束：altertablestuinfoaddconstraintunique（stuid）添加默认约束键：altertablestuinfoaddconstraintdf-stuadddressdefault（‘地址不详’）forstuaddress添加检查约束：altertablestuinfoaddconstraintck-stuagecheck(stuagebetween13and40)添加外约束键：ALTERTABLEstuMarksADDCONSTRAINTFK_stuNoFOREIGNKEY(stuNo)REFERENCESstuInfo(stuNo)'>SQL---------表的约束</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>18</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/A341A56D-7F6C-489E-B13B-C04A10249678.html' title='AnalysisServices服务提供的凭据无效解决办法当安装sql数据库时，会遇到一种错误，您为 Analysis Services 服务提供的凭据无效。若要继续，请为 Analysis Services 服务提供有效的帐户和密码，这个时候需要为所有服务提供一个相同的密码我们可以使用电脑的开机密码即可，如：administrator123'>Analysis Services 服务提供的凭据无效解决办法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>19</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/C9490013-A7A3-444C-A200-D472457C576F.html' title='Sql server聚合函数在实际工作中应对各种需求使用的还是很广泛的，对于聚合函数的优化自然也就成为了一个重点，一个程序优化的好不好直接决定了这个程序的声明周期。Sql server聚合函数对一组值执行计算并返回单一的值。聚合函数对一组值执行计算，并返回单个值。除了 COUNT 以外，聚合函数都会忽略空值。 聚合函数经常与 SELECT 语句的 GROUP BY 子句一起使用。回到顶部v1.写在前面如果有对Sql server聚合函数不熟或者忘记了的可以看我之前的一片博客。sql server 基础教程。本文中所有数据演示都是用Microsoft官方示例数据库：Northwind，至于Northwind大家也可以在网上下载。至于下载方法MSDN已经有了详细的说明了，这里就不多说了。回到顶部v2.Sql server标量聚合2.1.概念：在只包含聚合函数的 SELECT 语句列列表中指定的一种聚合函数（如 MIN()、MAX()、COUNT()、SUM() 或 AVG()）。当列列表只包含聚合函数时，则结果集只具有一个行给出聚合值，该值由与 WHERE 子句谓词相匹配的源行计算得到。2.2.探索标量聚合：我们先用Sql server的包括实际的执行计划来看看一个简单的流聚合COUNT()来看看表里数据所有的行数。再通过SET SHOWPLAN_ALL ON(关于输出中包含的列更多信息可以在链接中查看)来看看有关语句执行情况的详细信息，并估计语句对资源的需求。通过SET SHOWPLAN_ALL ON我们来看看COUNT()具体做了那些事情:索引扫描：扫描当前表的行数流计算：计算行数的数量计算标量：将流计算出来的结果转化为适当的类型。(因为索引扫描出来的结果是根据表中数据的大小决定的，如果表中数据很多的话，COUNT是int类型就会有问题，所以在最终返回的时候需要将默认类型(数值一般默认类型是Big)转成int类型。)小结：通过SET SHOWPLAN_ALL ON我们可以查看Sql server聚合函数在给我们呈现最终效果的时候，为这个效果做了些什么事情。2.3.标量聚合优化技巧：我们通过两个比较简单的sql查询来看看他们的区别SELECTCOUNT(DISTINCTShipCity)FROMOrdersSELECTCOUNT(DISTINCTOrderID)FROMOrders从上图中可以看到，其实这两个查询从语句上来说没什么太大的区别，但是为什么开销会不一样，一个是查询城市一个是查询订单号。这是因为其实DISTINCT对于OrderID查询来说，是没有什么意义的，因为OrderID是主键，是不会有重复的。而ShipCity是会有重复的，Sql server的去重机制在去重的时候，会有一个排序的过程。这个排序还是比较消耗资源的。对于数据量比较大的表其实不是很建议对大表排序或者对大表的某个重复次数多的字段去重运算。所以我们这里可以对ShipCity进行优化一下。可以对ShipCity创建一个非聚集索引。CREATEINDEXIndex_ShipCityOnOrders(ShipCitydesc)go从上图中可以看到，加了索引以后COUNT(DISTINCT ShipCity)的查询变成了两个流聚合，而没有了排序，节省了开销。总结：对于标量聚合从上面的例子大家可以看到，标量聚合优缺点很明显:Sql server标量聚合优点：算法比较简单直观，适合非重复值的聚合操作。Sql server标量聚合缺点：性能较差(需要排序)，不适合重复值的聚合操作。优化技巧:尽量避免排序产生将分组字(GROUP BY)段锁定在索引覆盖范围内回到顶部v3.Sql server哈希聚合3.1.概念：哈希(Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。)哈希聚合的内部实现方法和哈希连接的实现机制一样，需要哈希函数的内部运算，形成不同的哈希值，依次并行扫描数据形成聚合值。3.2.背景：为了解决流聚合的不足，应对大数据的操作，所以哈希聚合就诞生了。3.3.分析：来看看两个简单的查询。ShipCountry和CustomerID的分组查询看上去很类似，但是为什么执行计划会不同呢？这是因为ShipCountry包含了大量的重复值，CustomerID重复值非常少，所以Sql server系统给ShipCountry推送的哈希聚合，而CustomerID推送的是流聚合。也就是说Sql server系统会动态的根据查询的情况选择合适的聚合方式。所以我们在做SQL优化的时候不能仅根据SQL语句来优化，还得结合具体数据分布的环境。回到顶部v4.运算过程监控指标4.1.监控元素：可视化查看运行时间T-sql语句查询时间占用内存T-sql语句查询IO4.2.可视化查看运行时间：4.3.T-sql语句查询时间：4.4.占用内存：4.5.T-sql语句查询IO：关于监控元素还有很多，这里就列举几个。回到顶部v博客总结SQL Server 聚合函数算法优化技巧差不多就介绍到这里，如果有对sql语句优化感兴趣的可以看这篇博客。sql server之数据库语句优化'>SQL Server 聚合函数算法优化技巧</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>20</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/D7C5E58A-91D8-4E22-92E9-C06978F23BB4.html' title='本系列为SQL SERVER自动化运维的一些操作技巧点，所有内容都是根据日常运维过程中最经常遇到的问题，并为此形成了一些自动化运维的方式，皆为原创....供部分DBA和开发人员浏览借鉴，所应用平台基于微软server平台，所利用技术为Power Shell，所关注的点为SQL Server.1、SQL Server需要监控哪些计数器2、SQL Server自动化运维系列——监控性能指标脚本（Power Shell）3、SQL Server自动化运维系列——监控磁盘剩余空间及SQL Server错误日志（Power Shell）4、SQL Server自动化运维系列——关于邮件通知那点事（.Net开发人员的福利）5、SQL Server自动化运维系列——监控跑批Job运行状态（Power Shell）6、SQL Server自动化运维系列——关于数据收集（多服务器数据收集和性能监控）'>SQL Server 自动化运维系列</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>21</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/7C9C9602-E2EF-467C-81C6-B14EB935A0F2.html' title='SQL Server DBA11. 查询数据库各种历史记录在SQL Server数据库中，从登陆开始，然后做了什么操作，以及数据库里发生了什么，大多都是有记录可循的，但是也有一些确实无从查起。一.数据库启动记录1.最近一次启动SQL Server的时间selectsqlserver_start_timefromsys.dm_os_sys_info;--也可参考系统进程创建的时间，比服务启动时间略晚(秒级)selectlogin_timefromsysprocesseswherespid=1selectlogin_timefromsys.dm_exec_sessionswheresession_id=1--也可参考tempdb数据库创建的时间，比服务启动时间略晚(秒级)selectcreate_datefromsys.databases  wheredatabase_id=22.最近几次启动SQL Server的时间--参考errorlog，系统默认保留6个归档，共7个文件execxp_readerrorlog0,1,NServerprocessIDisexecxp_readerrorlog1,1,NServerprocessIDisexecxp_readerrorlog2,1,NServerprocessIDisexecxp_readerrorlog3,1,NServerprocessIDisexecxp_readerrorlog4,1,NServerprocessIDisexecxp_readerrorlog5,1,NServerprocessIDisexecxp_readerrorlog6,1,NServerprocessIDis3.历史上更多次启动SQL Server的时间查看windows event log，SQL语句无法直接读取event log，如果想用命令行，可以试试VBS，Powershell。Event Viewer/Windows logs下Application 或者 System 事件里都有服务启动的记录。二.登陆数据库记录1.查看error log默认情况下，只有失败的登录会被记录在error log里，如果想登录失败/成功都被记录到error log，需要开启如图选项：用SQL语句修改注册表，也同样可以开启，键值对应关系如下：0, None1, Failed2, Successful3, Both failed and successfulUSE[master]GOEXECxp_instance_regwriteNHKEY_LOCAL_MACHINE,NSoftware\Microsoft\MSSQLServer\MSSQLServer,NAuditLevel,REG_DWORD,3GO在error log里查看登录记录：execxp_readerrorlog0,1,NLogin,Nforuser,null,null,NDESC2.利用LOGON触发器进行记录从SQL Server 2005 SP2开始引入了LOGON Trigger，可以用它在登录时做个记录，实现如下：--创建LOGON触发器CREATEdatabaseDBAGOUSEDBAGOIFOBJECT_ID(login_history,U)isnotnullDROPTABLElogin_historyGOCREATETABLElogin_history  (  FACT_IDbigintIDENTITY(1,1)primarykey,  LOGIN_NAMEnvarchar(1024),  LOGIN_TIMEdatetime)GOIFEXISTS(select1fromsys.server_triggerswherename=login_history_trigger)DROPTRIGGERlogin_history_triggerONALLSERVERGOCREATETRIGGERlogin_history_triggerONALLSERVERFORLOGONASBEGIN--IFSUSER_NAME()NOTLIKENTAUTHORITY\%AND--SUSER_NAME()NOTLIKENTSERVICE\%IFORIGINAL_LOGIN()NOTLIKENTAUTHORITY\%AND  ORIGINAL_LOGIN()NOTLIKENTSERVICE\%BEGININSERTINTODBA..login_historyVALUES(ORIGINAL_LOGIN(),GETDATE());END;END;GO--登录后查看记录SELECT*FROMlogin_history三.创建，修改，删除记录(DDL)1.服务器对象的创建，修改--创建数据库selectname,create_datefromsys.databases--创建，修改登录selectname,createdate,updatedatefromsysloginsselectname,create_date,modify_datefromsys.server_principals    --创建，修改LOGON触发器selectname,create_date,modify_datefromsys.server_triggers2.数据库对象创建，修改--创建数据库对象selectname,create_date,modify_datefromsys.objects    --创建，修改触发器，DDL触发器不在sys.objects里selectname,create_date,modify_datefromsys.triggers注意：(1)索引的创建，修改并没有记录sys.objects--里面没有0,1之外的索引sys.indexes--里面没有日期objectproperty()--没有日期属性indexproperty()--没有日期属性sys.dm_db_index_operational_stats  sys.dm_db_index_usage_stats  sys.dm_db_index_physical_stats--也都没有STATS_DATE(table_id,index_id)--是索引的统计信息最后更新时间(2)关于creator和ownerSQL Server里只有owner，数据库里对象的owner必须是一个有效的database principal (user或者role)，没有creator，很难知道是谁创建了这个对象，因为owner并不准确：首先，数据库对象的owner可以被修改，ALTER AUTHORIZATION或者sp_changeobjectowner都行；其次，就算owner没被修改过，默认情况下数据库对象的owner沿用schema的owner，除非在创建schema时特意指定了某个owner；最后，系统表并没有记录creator，如果想要查询，也许得利用DDL 触发器来记录。关于owner简单举例如下：--用sysadmin权限的账号登录后创建USEmasterGOCREATELOGINtest_loginWITHPASSWORD=N123,DEFAULT_DATABASE=master,CHECK_EXPIRATION=OFF,CHECK_POLICY=OFFALTERSERVERROLEsysadminADDMEMBERtest_loginGOCREATEdatabaseDBAGOUSEDBAGOCREATEUSERtest_userFORLOGINtest_loginGOCREATESCHEMAtest_schemaGO--用test_login登录后建表ifOBJECT_ID(test_schema.test_owner,U)isnotnulldroptabletest_schema.test_ownerGOcreatetabletest_schema.test_owner(idint)GO--表的owner还是用了schema的ownerselects.nameasschema_name,dp2.nameasschema_owner,  o.nameasobject_name,coalesce(dp1.name,dp2.name)asobject_owner,*fromsys.objectsoinnerjoinsys.schemassono.schema_id=s.schema_idleftjoinsys.database_principalsdp1ono.principal_id=dp1.principal_idleftjoinsys.database_principalsdp2ons.principal_id=dp2.principal_idwhereo.name=test_owner--用objectproperty也可以查看ownerselectnameasobject_ownerfromsys.database_principals  whereprincipal_id=OBJECTPROPERTY(object_id(test_schema.test_owner),OwnerId)object owner3.默认跟踪里的创建，修改，删除对象(create, alter, drop)从sql server 2005开始引入了默认跟踪，这是sql server默认开启的跟踪，并定义了事件、文件大小，个数，查看定义如下：t.eventid,te.name(eventidsys.fn_trace_geteventinfo())tsys.trace_eventstet.eventidte.trace_event_idsys.tracesid示例，利用默认跟踪查看删除数据库记录如下：DECLARE@pathvarchar(1024)SELECT@path=pathFROMsys.traceswhereid=1SELECT*FROMfn_trace_gettable(@path,1)whereDatabaseName=DBAandEventClass=47--46表示Create对象，47表示Drop对象，164表示修改对象andObjectType=16964--16964表示数据库注意：(1) 其他对象比如表的删除等也都可以查到；(2) 跟踪返回的列值有很多定义，没有系统表记载，需要去翻帮助，比如ObjectType列值参考这个列表：https://msdn.microsoft.com/en-us/library/ms180953.aspx(3) 注意默认跟踪的时效性，5个20MB的文件，也许想要看的信息很快就被覆盖了；(4) truncate table并没有被默认跟踪记录。四.数据库表的各种记录汇总一下对表的各种历史操作记录的查看：(1) create table, alter table记录，查看sys.objects 或者默认跟踪；(2) drop table记录，查看默认跟踪；(3) truncate table 也许只有去打开数据库log文件查看了，最后会简单介绍下；(4) DML操作表中数据的记录，查?磗ys.dm_db_index_usage_stats，如下：SELECTo.nameastable_name,  s.last_user_seek,  s.last_user_scan,  s.last_user_lookup,  s.last_user_updatefromsys.indexesi  leftjoinsys.dm_db_index_usage_statss  ons.object_id=i.object_idand  s.index_id=i.index_id  innerjoinsys.objectsooni.object_id=o.object_idwherei.index_id=1ando.is_ms_shipped=0orderbyo.name注意：动态管理视图(DMV) 中采集来的信息都是从sql server启动后开始的，也就是说重启后就没了。五.历史SQL语句记录有些数据库本身，会记录所有历史的SQL命令。比如：mysql和pgsql都有专门的log文本文件来存放所有历史的SQL命令；也有些数据库在保存log文本的同时，还保留最近的N条SQL命令在数据库里，以方便查询。SQL Server并没有这样的实现，只有sys.dm_exec_query_stats缓存了一部分 (sql server服务开启后执行的语句，某些不被缓存执行计划的语句并不记录)。这个视图主要是对执行计划的统计，包含消耗成本，运行次数等等，并没有session，user，每次被执行的时间等信息：SELECTst.textassql_statement,  qs.creation_timeasplan_last_compiled,  qs.last_execution_timeasplan_last_executed,  qs.execution_countasplan_executed_count,  qp.query_planFROMsys.dm_exec_query_statsqsCROSSAPPLYsys.dm_exec_sql_text(qs.plan_handle)stCROSSAPPLYsys.dm_exec_query_plan(qs.plan_handle)qporderbytotal_elapsed_time/execution_countdesc当然，开启跟踪，审计之类的方法，是可以记录所有操作的，但是这个开销有可能会影响系统性能，所以一般并不在生产环境启用。六.数据库备份还原历史记录备份还原的记录都在msdb里。1.备份记录SELECT  bs.backup_set_id,  bs.database_name,  bs.backup_start_date,  bs.backup_finish_date,CAST(CAST(bs.backup_size/1000000ASINT)ASVARCHAR(14))++MBAS[Size],CAST(DATEDIFF(second,bs.backup_start_date,  bs.backup_finish_date)ASVARCHAR(4))++Seconds[TimeTaken],CASEbs.[type]WHENDTHENFullBackupWHENITHENDifferentialBackupWHENLTHENTLogBackupWHENFTHENFileorfilegroupWHENGTHENDifferentialfileWHENPTHENPartialWHENQTHENDifferentialPartialENDASBackupType,  bmf.physical_device_name,CAST(bs.first_lsnASVARCHAR(50))ASfirst_lsn,CAST(bs.last_lsnASVARCHAR(50))ASlast_lsn,  bs.server_name,  bs.recovery_modelFROMmsdb.dbo.backupsetbsINNERJOINmsdb.dbo.backupmediafamilybmf  ONbs.media_set_id=bmf.media_set_idORDERBYbs.server_name,bs.database_name,bs.backup_start_date;GO如果server_name是本机，那么备份是在本机生成的；如果server_name是别的主机名，那么备份是被拿到本机做过数据库还原；2.还原纪录SELECT  rs.[restore_history_id],  rs.[restore_date],  rs.[destination_database_name],  bmf.physical_device_name,  rs.[user_name],  rs.[backup_set_id],CASErs.[restore_type]WHENDTHENDatabaseWHENITHENDifferentialWHENLTHENLogWHENFTHENFileWHENGTHENFilegroupWHENVTHENVerifyonlyENDASRestoreType,  rs.[replace],  rs.[recovery],  rs.[restart],  rs.[stop_at],  rs.[device_count],  rs.[stop_at_mark_name],  rs.[stop_before]FROM[msdb].[dbo].[restorehistory]rsINNERJOIN[msdb].[dbo].[backupset]bsonrs.backup_set_id=bs.media_set_idINNERJOINmsdb.dbo.backupmediafamilybmf  ONbs.media_set_id=bmf.media_set_idGO还原数据库的时候是会写backupset和backupmediafamily系统表的，用来记录还原所用到的备份文件信息。七.作业，维护计划，数据库邮件历史记录作业，维护计划，数据库邮件的历史记录，也都在msdb里。1.作业历史记录ifOBJECT_ID(tempdb..#tmp_job)isnotnulldroptable#tmp_job--只取最后一次结果selectjob_id,  run_status,CONVERT(varchar(20),run_date)run_date,CONVERT(varchar(20),run_time)run_time,CONVERT(varchar(20),run_duration)run_durationinto#tmp_jobfrommsdb.dbo.sysjobhistoryjh1wherejh1.step_id=0and(selectCOUNT(1)frommsdb.dbo.sysjobhistoryjh2  wherejh2.step_id=0and(jh1.job_id=jh2.job_id)and(jh1.instance_id=jh2.instance_id))=1--排除syspolicy_purge_history这个系统作业selecta.namejob_name,caseb.run_statuswhen0thenFailedwhen1thenSucceededwhen2thenRetrywhen3thenCanceledelseUnknownendasjob_status,LEFT(run_date,4)+-+SUBSTRING(run_date,5,2)+-+RIGHT(run_date,2)+SPACE(1)+LEFT(RIGHT(1000000+run_time,6),2)+:+SUBSTRING(RIGHT(1000000+run_time,6),3,2)+:+RIGHT(RIGHT(1000000+run_time,6),2)asjob_started_time,+LEFT(RIGHT(1000000+run_duration,6),2)+:+SUBSTRING(RIGHT(1000000+run_duration,6),3,2)+:+RIGHT(RIGHT(1000000+run_duration,6),2)asjob_durationfrommsdb.dbo.sysjobsa  leftjoin#tmp_jobb  ona.job_id=b.job_id  wherea.namenotin(syspolicy_purge_history)anda.enabled=1orderbyb.run_statusasc,a.name,b.run_durationdesc2.维护计划历史记录select*frommsdb..sysdbmaintplan_history--新的系统表也可以select*frommsdb..sysmaintplan_logselect*frommsdb..sysmaintplan_logdetail维护计划最终是作为作业在运行的，也可以直接查看同名作业的历史记录。3.数据库邮件历史记录--直接查系统表select*frommsdb..sysmail_mailitemsselect*frommsdb..sysmail_log--也可查看基于这2个系统表的系统视图select*frommsdb..sysmail_allitemsselect*frommsdb..sysmail_sentitemsselect*frommsdb..sysmail_unsentitemsselect*frommsdb..sysmail_faileditemsselect*frommsdb..sysmail_event_log--更多系统表和视图usemsdbGOselect*fromsys.objects  wherenamelike%sysmail%andtypein(U,V)orderbytype,name八.查看数据库日志文件数据库日志文件里对于DDL，DML操作肯定是有记录的，有2个内置函数可以用来解析，但是并不那么轻松，简单介绍如下：1. fn_dblog读取当前在线的日志select*fromfn_dblog(null,null)--2个null代表起始的日志LSN返回的结果集中字段定义：(1) AllocUnitName: 对象名(2) Operation: 操作类型，常见的有 LOP_INSERT_ROWS, LOP_DELETE_ROWS, LOP_MODIFY_ROW(3) [RowLog Contents 0], [RowLog Contents 1], 2,3,4,5: 字段内容，但是是二进制的，和dbcc page看到的类似试着查看truncate table记录如下：IFOBJECT_ID(test_truncate,U)isnotnullDROPTABLEtest_truncateGOCREATETABLEtest_truncate(IDint)INSERTINTOtest_truncatevalues(1)TRUNCATETABLEtest_truncate--查看truncatetable记录select*fromfn_dblog(null,null)whereAllocUnitNamelike%test_truncate%andDescriptionlikeDeallocated%2. fn_dump_dblog读取数据库备份里的日志参数介绍：前面两2个NULL和fn_dblog一样代表起始的日志LSN，DISK表示设备类型，1表示备份文件个数，最多64个，这里以1个文件为例：<img src="http://wafxw.cn/ueditor/themes/default/images/spacer.gif" alt="复制代码" data-media-type="image" dat'>SQL Server DBA</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-4 上午 12:00:00</span></li>
                        </ul>
                        <br /><hr />
                    </div>
                </div>
                <div id="footerInnerSeparator"></div>
            </div>
        </div>
        <div id="footerOuterSeparator"></div>
    </div>
    <br /><br /><br />
    <script src="../../js/jquery-1.9.1.js"></script>
</body>
</html>