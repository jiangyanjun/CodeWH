<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="Language" content="zh-CN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../images/kebue.ico">
    <link rel="icon" href="../../images/kebue.ico">
    <meta name="description" content=JAVA>
    <meta name="keywords" content=JAVA>
    <title>JAVA</title>

    <link href="../../template/scripts/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="../../template/styles/custom.css" rel="stylesheet" />

</head>
<body id="pageBody">
    <div id="divBoxed" class="container">
        <div class="transparent-bg" style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;z-index: -1;zoom: 1;"></div>
        <div class="divPanel notop nobottom">
            <div class="row-fluid">
                <div class="span12">
                    <div id="divLogo">
                        <a href="../../../Home/Index" id="divSiteTitle">科布尔 kebue</a><br />
                        <a href="../../../Home/Index" id="divTagLine">开发者用代码改变世界从科布尔开始</a>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="divMenuRight" class="pull-right">
                        <div class="navbar">
                            <button type="button" class="btn btn-navbar-highlight btn-large btn-primary" data-toggle="collapse" data-target=".nav-collapse">
                                NAVIGATION <span class="icon-chevron-down icon-white"></span>
                            </button>
                            <div class="nav-collapse collapse">
                                <ul class="nav nav-pills ddmenu">
                                    <li class="dropdown glyphicon glyphicon-arrow-left"><a href='javascript:window.history.back()'>后退</a></li>
                                    <li class="dropdown active"><a href="http://www.kebue.com/">Home</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="contentInnerSeparator"></div>
                </div>
            </div>
        </div>
        <div class="contentArea">
            <div class="divPanel notop page-content">
                <div class="breadcrumbs">
                    <a href="../../../Home/Index">Home</a> &nbsp;/&nbsp; <span>JAVA</span>
                </div><br /><hr />
                <div class="row-fluid">
                    <div class="span12" id="Article-type">
                        <ul>
                            <li><span>1</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/05EE2C52-9D1A-4550-B99D-D673D05AFE8C.html' title='1.栈和队列的共同特点是（只允许在端点处插入和删除元素）  4.栈通常采用的两种存储结构是（线性存储结构和链表存储结构）  5.下列关于栈的叙述正确的是（D）  A.栈是非线性结构B.栈是一种树状结构C.栈具有先进先出的特征D.栈有后进先出的特征  6.链表不具有的特点是（B）A.不必事先估计存储空间B.可随机访问任一元素  C.插入删除不需要移动元素D.所需空间与线性表长度成正比  7.用链表表示线性表的优点是（便于插入和删除操作）  8.在单链表中，增加头结点的目的是（方便运算的实现）  9.循环链表的主要优点是（从表中任一结点出发都能访问到整个链表）  10.线性表L＝（a1,a2,a3,……ai,……an），下列说法正确的是（D）  A.每个元素都有一个直接前件和直接后件B.线性表中至少要有一个元素  C.表中诸元素的排列顺序必须是由小到大或由大到小  D.除第一个和最后一个元素外，其余每个元素都有一个且只有一个直接前件和直接后件  11.线性表若采用链式存储结构时，要求内存中可用存储单元的地址（D）  A.必须是连续的B.部分地址必须是连续的C.一定是不连续的D.连续不连续都可以  12.线性表的顺序存储结构和线性表的链式存储结构分别是（随机存取的存储结构、顺序存取的存储结构）  13.树是结点的集合，它的根结点数目是（有且只有1）  14.在深度为5的满二叉树中，叶子结点的个数为（31）  15.具有3个结点的二叉树有（5种形态）  16.设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（13）  17.已知二叉树后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历序列是（cedba）  18.已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为（DGEBHFCA）  19.若某二叉树的前序遍历访问顺序是abdgcefh，中序遍历访问顺序是dgbaechf，则其后序遍历的结点访问顺序是（gdbehfca）  20.数据库保护分为：安全性控制、完整性控制、并发性控制和数据的恢复。1.在计算机中，算法是指（解题方案的准确而完整的描述）  2.在下列选项中，哪个不是一个算法一般应该具有的基本特征（无穷性）  说明：算法的四个基本特征是：可行性、确定性、有穷性和拥有足够的情报。  3.算法一般都可以用哪几种控制结构组合而成（顺序、选择、循环）  4.算法的时间复杂度是指（算法执行过程中所需要的基本运算次数）  5.算法的空间复杂度是指（执行过程中所需要的存储空间）  6.算法分析的目的是（分析算法的效率以求改进）  7.下列叙述正确的是（C）  A．算法的执行效率与数据的存储结构无关  B．算法的空间复杂度是指算法程序中指令（或语句）的条数  C．算法的有穷性是指算法必须能在执行有限个步骤之后终止  D．算法的时间复杂度是指执行算法程序所需要的时间  8.数据结构作为计算机的一门学科，主要研究数据的逻辑结构、对各种数据结构进行的运算，以及（数据的存储结构）  9.数据结构中，与所使用的计算机无关的是数据的（C）  A．存储结构B．物理结构C．逻辑结构D．物理和存储结构  10.下列叙述中，错误的是（B）  A．数据的存储结构与数据处理的效率密切相关  B．数据的存储结构与数据处理的效率无关  C．数据的存储结构在计算机中所占的空间不一定是连续的  D．一种数据的逻辑结构可以有多种存储结构  11.数据的存储结构是指（数据的逻辑结构在计算机中的表示）  12.数据的逻辑结构是指（反映数据元素之间逻辑关系的数据结构）  13.根据数据结构中各数据元素之间前后件关系的复杂程度，一般将数据结构分为（线性结构和非线性结构）  14.下列数据结构具有记忆功能的是（C）A．队列B．循环队列C．栈D．顺序表  15.下列数据结构中，按先进后出原则组织数据的是（B）  A．线性链表B．栈C．循环链表D．顺序表  16.递归算法一般需要利用（队列）实现。  17.下列关于栈的叙述中正确的是（D）A．在栈中只能插入数据B．在栈中只能删除数据  C．栈是先进先出的线性表D．栈是先进后出的线性表  20.由两个栈共享一个存储空间的好处是（节省存储空间，降低上溢发生的机率）  21.应用程序在执行过程中，需要通过打印机输出数据时，一般先形成一个打印作业，将其存放在硬盘中的一个指定（队列）中，当打印机空闲时，就会按先来先服务的方式从中取出待打印的作业进行打印。  22.下列关于队列的叙述中正确的是（C）A．在队列中只能插入数据B．在队列中只能删除数据C．队列是先进先出的线性表D．队列是先进后出的线性表23.下列叙述中，正确的是（D）A．线性链表中的各元素在存储空间中的位置必须是连续的  B．线性链表中的表头元素一定存储在其他元素的前面C．线性链表中的各元素在存储空间中的位置不一定是连续的，但表头元素一定存储在其他元素的前面D．线性链表中的各元素在存储空间中的位置不一定是连续的，且各元素的存储顺序也是任意的  24.下列叙述中正确的是（A）A．线性表是线性结构B．栈与队列是非线性结构  C．线性链表是非线性结构D．二叉树是线性结构  25.线性表L＝（a1,a2,a3,……ai,……an），下列说法正确的是（D）  A．每个元素都有一个直接前件和直接后件B．线性表中至少要有一个元素  C．表中诸元素的排列顺序必须是由小到大或由大到小D．除第一个元素和最后一个元素外，其余每个元素都有一个且只有一个直接前件和直接后件  26.线性表若采用链式存储结构时，要求内存中可用存储单元的地址（连续不连续都可以）  27.链表不具有的特点是（B）A．不必事先估计存储空间B．可随机访问任一元素  C．插入删除不需要移动元素D．所需空间与线性表长度成正比  28.非空的循环单链表head的尾结点（由p所指向），满足（p-next=head）  29.与单向链表相比，双向链表的优点之一是（更容易访问相邻结点）  30.在（D）中，只要指出表中任何一个结点的位置，就可以从它出发依次访问到表中其他所有结点。A．线性单链表B．双向链表C．线性链表D．循环链表  31.以下数据结构属于非线性数据结构的是（C）A．队列B．线性表C．二叉树D．栈  32.树是结点的集合，它的根结点数目是（有且只有1）  33.具有3个结点的二叉树有（5种形态）  34.在一棵二叉树上第8层的结点数最多是（128）注：2K-1  35.在深度为5的满二叉树中，叶子结点的个数为（16）注：2n-1  36.在深度为5的满二叉树中，共有（31）个结点。注：2n－1  37.设一棵完全二叉树共有699个结点，则在该二叉树中的叶子结点数为（350）  说明：完全二叉树总结点数为N，若N为奇数，则叶子结点数为（N+1）/2；若N为偶数，则叶子结点数为N/2。  38.设有下列二叉树，对此二叉树中序遍历的结果是（B）  A．ABCDEF  B．DBEAFC  C．ABDECF  D．DEBFCA  39.已知二叉树后序遍历序列是dabec，中序遍历序列debac，它的前序遍历序列是（cedba）  40.已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为（DGEBHFCA）  41.若某二叉树的前序遍历访问顺序是abdgcefh，中序遍历访问顺序是dgbaechf，则其后序遍历的结点访问顺序是（gdbehfca）42.串的长度是（串中所含字符的个数）  43.设有两个串p和q，求q在p中首次出现位置的运算称做（模式匹配）  44.N个顶点的连通图中边的条数至少为（N-1）  45.N个顶点的强连通图的边数至少有（N）  46.对长度为n的线性表进行顺序查找，在最坏情况下所需要的比较次数为（N）  47.最简单的交换排序方法是（冒泡排序）  48.假设线性表的长度为n，则在最坏情况下，冒泡排序需要的比较次数为（n(n-1)/2）  49.在待排序的元素序列基本有序的前提下，效率最高的排序方法是（冒泡排序）  50.在最坏情况下，下列顺序方法中时间复杂度最小的是（堆排序）  51.希尔排序法属于（插入类排序）  52.堆排序法属于（选择类排序）  53.在下列几种排序方法中，要求内存量最大的是（归并排序）  54.已知数据表A中每个元素距其最终位置不远，为节省时间，应采用（直接插入排序）  55.算法的基本特征是可行性、确定性、有穷性和拥有足够的情报。1.一个算法通常由两种基本要素组成：一是对数据对象的运算和操作，二是算法的控制结构。  1.算法的复杂度主要包括时间复杂度和空间复杂度。  2.实现算法所需的存储单元多少和算法的工作量大小分别称为算法的空间复杂度和时间复杂度。  3.所谓数据处理是指对数据集合中的各元素以各种方式进行运算，包括插入、删除、查找、更改等运算，也包括对数据元素进行分析。  4.数据结构是指相互有关联的数据元素的集合。  5.数据结构分为逻辑结构与存储结构，线性链表属于存储结构。  6.数据结构包括数据的逻辑结构和数据的存储结构。  7.数据结构包括数据的逻辑结构、数据的存储结构以及对数据的操作运算。  8.数据元素之间的任何关系都可以用前趋和后继关系来描述。  9.数据的逻辑结构有线性结构和非线性结构两大类。  10.常用的存储结构有顺序、链接、索引等存储结构。  11.顺序存储方法是把逻辑上相邻的结点存储在物理位置相邻的存储单元中。  12.栈的基本运算有三种：入栈、退栈与读栈顶元素。  13.队列主要有两种基本运算：入队运算与退队运算。  14.在实际应用中，带链的栈可以用来收集计算机存储空间中所有空闲的存储结点，这种带链的栈称为可利用栈。  15.栈和队列通常采用的存储结构是链式存储和顺序存储。  16.当线性表采用顺序存储结构实现存储时，其主要特点是逻辑结构中相邻的结点在存储结构中仍相邻。  17.循环队列主要有两种基本运算：入队运算与退队运算。每进行一次入队运算，队尾指针就进1。  18.当循环队列非空且队尾指针等于对头指针时，说明循环队列已满，不能进行入队运算。这种情况称为上溢。  19.当循环队列为空时，不能进行退队运算，这种情况称为下溢。  20.在一个容量为25的循环队列中，若头指针front=16，尾指针rear=9，则该循环队列中共有18个元素。注：当rearfront时，元素个数＝总容量－（front－rear）；  当rearfront时，元素个数＝rear－front。1.判断链表是否存在环型链表问题：判断一个链表是否存在环，例如下面这个链表就存在一个环：  例如N1-N2-N3-N4-N5-N2就是一个有环的链表，环的开始结点是N5这里有一个比较简单的解法。设置两个指针p1，p2。每次循环p1向前走一步，p2向前走两步。直到p2碰到NULL指针或者两个指针相等结束循环。如果两个指针相等则说明存在环。structlink{intdata;link*next;}; boolIsLoop(link*head){link*p1=head,*p2=head;if(head==NULL||head-next==NULL){returnfalse;}do{p1=p1-next;p2=p2-next-next;}while(p2p2-nextp1!=p2);if(p1==p2)returntrue;elsereturnfalse;}2,链表反转单向链表的反转是一个经常被问到的一个面试题，也是一个非常基础的问题。比如一个链表是这样的：1-2-3-4-5通过反转后成为5-4-3-2-1。最容易想到的方法遍历一遍链表，利用一个辅助指针，存储遍历过程中当前指针指向的下一个元素，然后将当前节点元素的指针反转后，利用已经存储的指针往后面继续遍历。源代码如下：structlinka{intdata;linka*next;}; voidreverse(linka*head){if(head==NULL)return;linka*pre,*cur,*ne;pre=head;cur=head-next;while(cur){ne=cur-next;cur-next=pre;pre=cur;cur=ne;}head-next=NULL;head=pre;}还有一种利用递归的方法。这种方法的基本思想是在反转当前节点之前先调用递归函数反转后续节点。源代码如下。不过这个方法有一个缺点，就是在反转后的最后一个结点会形成一个环，所以必须将函数的返回的节点的next域置为NULL。因为要改变head指针，所以我用了引用。算法的源代码如下：linka*reverse(linka*p,linka*head){if(p==NULL||p-next==NULL){head=p;returnp;}else{linka*tmp=reverse(p-next,head);tmp-next=p;returnp;}}3,判断两个数组中是否存在相同的数字给定两个排好序的数组，怎样高效得判断这两个数组中存在相同的数字？  这个问题首先想到的是一个O(nlogn)的算法。就是任意挑选一个数组，遍历这个数组的所有元素，遍历过程中，在另一个数组中对第一个数组中的每个元素进行binarysearch。用C++实现代码如下：boolfindcommon(inta[],intsize1,intb[],intsize2){inti;for(i=0;isize1;i++){intstart=0,end=size2-1,mid;while(start=end){mid=(start+end)/2;if(a[i]==b[mid])returntrue;elseif(a[i]b[mid])end=mid-1;elsestart=mid+1;}}returnfalse;}后来发现有一个O(n)算法。因为两个数组都是排好序的。所以只要一次遍历就行了。首先设两个下标，分别初始化为两个数组的起始地址，依次向前推进。推进的规则是比较两个数组中的数字，小的那个数组的下标向前推进一步，直到任何一个数组的下标到达数组末尾时，如果这时还没碰到相同的数字，说明数组中没有相同的数字。boolfindcommon2(inta[],intsize1,intb[],intsize2){inti=0,j=0;while(isize1jsize2){if(a[i]==b[j])returntrue;if(a[i]b[j])j++;if(a[i]b[j])i++;}returnfalse;}4,最大子序列问题：  给定一整数序列A1，A2，...An（可能有负数），求A1~An的一个子序列Ai~Aj，使得Ai到Aj的和最大  例如：  整数序列-2,11,-4,13,-5,2,-5,-3,12,-9的最大子序列的和为21。  对于这个问题，最简单也是最容易想到的那就是穷举所有子序列的方法。利用三重循环，依次求出所有子序列的和然后取最大的那个。当然算法复杂度会达到O(n^3)。显然这种方法不是最优的，下面给出一个算法复杂度为O(n)的线性算法实现，算法的来源于一书。在给出线性算法之前，先来看一个对穷举算法进行优化的算法，它的算法复杂度为O(n^2)。其实这个算法只是对对穷举算法稍微?隽艘恍┬薷模浩涫底有蛄械暮臀颐遣⒉恍枰看味贾匦录扑阋槐椤＜偕鑃um(i,j)是A[i]...A[j]的和，那么Sum(i,j+1)=Sum(i,j)+A[j+1]。利用这一个递推，我们就可以得到下面这个算法：intmax_sub(inta[],intsize){inti,j,v,max=a[0];for(i=0;isize;i++){v=0;for(j=i;jsize;j++){v=v+a[j];//Sum(i,j+1)=Sum(i,j)+A[j+1]if(vmax)max=v;}}returnmax;}那怎样才能达到线性复杂度呢？这里运用动态规划的思想。先看一下源代码实现：intmax_sub2(inta[],intsize){inti,max=0,temp_sum=0;for(i=0;isize;i++){temp_sum+=a[i];if(temp_summax)<pre style="margin-top: 0px; margin-bottom: 0px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; color: rgb(57, 57, 57); font-size'>java数据结构面试题</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>2</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/5293B54B-21F6-48ED-81D5-E83CFE099C2A.html' title='简介数组可用用于存储存储多个数据，Java的数组要求所有的数组元素具有一种相同的数据类型。一旦数组初始化完成，数组在内存中的空间被固定下来，长度不可改变，即使把数组的元素清空，所占用的空间依然被保留。生活案例：博物架每一个物品架都是相同类型的物品，长度不变，即使把物品下架，物品架依然不会改变。定义数组使用数组4步走：1、声明数组Java中支持两种格式的数组定义格式：类型[]变量名;  类型变量名[];例：int[]a;intb[];//两种方法都行，不过建议使用第一种。声明数组也就相当于上面例子中购买了一个定制的物品架（数组）到博物馆中，但是还没有确定物品架的大小（数组的大小），也还没有往物品架上放东西（数组元素）。2、分配空间分配空间也就是对数组进行初始化，初始化分为两种方式：第一种：静态初始化静态初始化的语法格式如下：数据类型[]变量名=new数据类型[]{数据1，数据2，数据3，......};例：int[]a=newint[]{4,2,64,12,3};//将这些数存放在数组中，数组的大小（长度）为花括号中元素的数量，该例子中大小为5String[]b=newString[]{张三,李四,王五};//所有数据的类型必须为定义的数据类型int[]c={2,5,7};//也可以使用这样的简写方式这就如同购买一个定制的物品架回来，同时将展示品放到物品架中一起购买回来，而物品架的大小就有多少物品就就有多大。第二种：动态初始化动态初始化是只指定数组的大小，由系统为每个元素指定初始值得一种方式。语法格式如下：数据类型[]变量名=new数据类型[大小];在这个格式中， 需要为其指定一个整数类型的数组大小，指定后，将确定数据的长度，数组能够存放多少元素。同时为所有元素指定一个默认初始值。例：int[]a=newint[5];//定义一个数组，长度为5，也就是说，能够存放5个int类型的数据，同时，默认5个值初始化为0初始化时默认值按以下规定设置：byte，short，int、long默认为0；float、double默认为0.0；char默认为\u0000;boolean默认为false；其他引用类型默认为null；3、赋值尽管你已经初始化好了数组，但是我们还是可以通过通过赋值的方式改变里面的数据。那么已经初始化好了数组，确定了数组的大小，我们该如何为没一个数组元素赋值呢？数组中还有一个下标的概念，数组初始化的时候，会为每个元素分配一个下标，就和物品展示架上的编号一样，我们可以通过下标为每个元素重新赋值。数组的下标从0开始，也就是说，第一个元素的下标为0，至于为什么要从0开始，我们后面再探讨一下，我们先看看赋值的例子：int[]a=newint[3];//定义一个长度为3的int类型数组，里面3个元素值已默认为0；a[0]=4;//设置第一个元素值为4a[1]=5;//设置第二个元素值为5a[2]=7;//设置第三个元素值为7为什么数组下标从0开始？首先我们需要知道的是，程序是在电脑内存中运行的，当我们的程序开始处理数据时，会在内存中开辟一个小小的空间用来存储数据，在代码中也就是定义一个变量，如：inta=5;定义一个int类型变量，值为五，而在内存中表示为，在内存中分配一小块内存，命名为a，里面存的值为5。而我们是如通过a这样一个变量名得到内存中的值得呢？是因为每一小块内存都会有一个地址，就如同我们居住的家有一个地址一样，通过这个地址，通过这个地址，就能知道里面住的是谁。二数组在内存中是以相连的位置存储的，方便对数组的操作，我们看一个例子：int[]b=newint[3];//定义一个int类型的数组，长度为3，里面的元素默认值为0此时内存中是这样的：数组中获得数据也是如此，如何知道b数组每个元素的数据呢？首先我们知道通过b这个数组在内存中的哪个位置，因为数组在内存中是一个相连的内存空间，所以b[0]的位置就等于b+0,而b[1]的位置就为b+1,b[2]=b+2,......以此类推，知道了数组所有元素的位置。而数组中第一个元素正好是在数组中开头的位置，用b[0]表示，则刚好是b表示的位置，而用1表示第一个元素的位置，则需要表示为a+1-1。4、处理数据在前面的内容中，我们已经定义了数组，初始化了数组，赋了值，那么如何使用数据呢，其实前面已经分析过，我们通过数组下标来为数组赋值，也通过数组下标得到每个数组元素的值。int[]a=newint[3];  a[0]=3;  a[1]=4;  a[2]=5;  System.out.println(a[1]);//得到数组的第二个位置的值，将它输出//我们也可以通过循环遍历数组中每个元素for(inti=0;ia.length;i++){  System.out.println(a[i]);//循环打印出数组中每个元素}在上面的例子中，循环打印的时候，我们看到，使用了a.length，通过 数组变量名.length 可以得到数组的长度，所以上面我们通过a.length得到数组的长度为3，循环3次，打印出数组的元素。不应该访问不存在的下标上面我们知道，我们控制数组是通过 变量名[下标] 来为变量赋值或者得到值，而如果访问超过了数组长度的下标时，则会出现异常。int[]a=newint[2];  a[5]=2;//a数组长度只有2个长度，而我们通过下标5访问第6个元素，实际a数组不存在这个位置，则会出现异常。二维数组或多维数组上面我们讲的都是在数组中存储一种基本数据类型或引用数据类型，而我们也可以在数组中存储数组：上面我们在一个数组元素中存储了另外一个数组元素，里面那个数组存储了一种数据类型int的值，我们称这样的数组为二维数组。二维数组的定义，初始化和赋值数据类型[][]数组名=new数据类型[长度1][长度2];长度1为外面一层数组的长度，长度2位里面一层的长度。定义和初始化上图中的形式，我们可以这样：int[][]a=newint[3][3];  a[0][0]=2;//访问时前面一个方括号的数字表示外面一层数组的元素下标，第二个方括号的数字表示里面一层的数组的下标a[0][1]=3;  a[0][2]=4;  a[1][0]=5;  a[1][1]=3;  a[1][2]=9;  a[2][0]=90;  a[2][1]=70;  a[2][2]=85;我们也可以将二维数组定义成这样一种格式：[][]a=[3][];a[0]=[2];a[1]=[12]=[30][0]=3;a[0][1]=41][0]=92][0]=902][1]=702][2]=85;而三维数组就是数组里面的数组里面存放的是数组~~~~~以此类推可以有n多维数组，不过一般人使用的不多 ~~~^_^~~~'>[Java入门笔记] Java语言基础（五）：数组</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>3</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/14C4DE37-367B-4A65-B7BC-B62A8602531A.html' title='常我们的Webservice服务的发布地址都将是一个相对路径，在与Spring一起使用时我们需要引入Cxf配置Webservice的schema，如jaxws，用以定义对应的Webservice。?xml version=1.0encoding=UTF-8?beans xmlns=http://www.springframework.org/schema/beans xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xmlns:jaxws=http://cxf.apache.org/jaxws xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd bean id=helloWorldclass=com.elim.test.cxf.service.HelloWorldServiceImpl/ !-- ID可以加斜杠也可以不加 -- jaxws:server id=/helloWorldserviceBean=#helloWorldserviceClass=com.elim.test.cxf.service.HelloWorldService//beans 然后我们需要定义一个CXFServlet，用以接收对应的Webservice请求，如下所示。?xml version=1.0encoding=UTF-8?web-app version=3.0 xmlns=http://java.sun.com/xml/ns/javaee xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd context-param param-namecontextConfigLocation/param-name param-valueclasspath:webservices.xml/param-value /context-param listener listener-classorg.springframework.web.context.ContextLoaderListener/listener-class /listener servlet servlet-nameCxfServlet/servlet-name servlet-classorg.apache.cxf.transport.servlet.CXFServlet/servlet-class /servlet servlet-mapping servlet-nameCxfServlet/servlet-name url-pattern/sys/service/*/url-pattern /servlet-mapping/web-app 这样如果我们想访问HelloWorldService这个Webservice就可以通过相对于当前工程发布路径的/sys/service/helloWorld来访问了。 但是如果我们的工程没有使用Spring，但是我们也想把Webservice发布为工程的某一个路径的相对路径怎么办？Cxf也为我们提供了相应的支持，这比使用Spring时的CXFServlet要麻烦一点。Cxf为我们提供了一个CXFNonSpringServlet，这要求我们实现自己的继承自CXFNonSpringServlet的Servlet，然后重写其loadBus方法，最终需要达到的效果就是CXFNonSpringServlet使用的Bus与我们的发布Webservice时使用的Bus是同一个即可。这样当我们访问CXFNonSpringServlet请求某个Webservice时，CXFNonSpringServlet将自动根据请求的相对路径去寻找发布路径为其相对路径的Webservice。下?氐刂?/span>java后台框架 springmvc mybaits 集代码生成器publicclassWebserviceServletextendsCXFNonSpringServlet { /** * */privatestaticfinallongserialVersionUID= 3919868434043901738L; @OverrideprotectedvoidloadBus(ServletConfig sc) {super.loadBus(sc); //获取当前CXFNonSpringServlet使用的Bus，然后利用该Bus来发布服务 Bus bus =this.getBus(); JaxWsServerFactoryBean jsFactoryBean =newJaxWsServerFactoryBean(); jsFactoryBean.setBus(bus); //该路径是相对于当前CXFNonSpringServlet匹配的路径的，也可以加斜杠 jsFactoryBean.setAddress(helloWorld); jsFactoryBean.setServiceClass(HelloWorldService.class); jsFactoryBean.setServiceBean(newHelloWorldServiceImpl()); jsFactoryBean.create(); }} 这时我们的web.xml需要定义我们自己的CXFNonSpringServlet，即：?xml version=1.0encoding=UTF-8?web-app version=3.0 xmlns=http://java.sun.com/xml/ns/javaee xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd servlet servlet-nameCxfServlet/servlet-name servlet-classcom.elim.test.cxf.servlet.WebserviceServlet/servlet-class load-on-startup1/load-on-startup /servlet servlet-mapping servlet-nameCxfServlet/servlet-name url-pattern/sys/service/*/url-pattern /servlet-mapping/web-app'>Web环境使用相对路径发布Webservice</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>4</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/69D1B4B7-8094-43BD-8CFA-ED80AEE7EBAC.html' title='　相信大家对于网站也好，手机app也好，用户注册时，需要进行邮箱验证的功能特别好奇吧，本篇我将带领大家一起实现一下这个简单而又神奇的小功能，让我们的应用也可以加入这些神奇的元素。废话不多说，下面开始我们今天的内容介绍。　　首先实现上面的功能，需要一个固定的发送电子邮件的邮箱地址，这里我们就以我们经常使用的QQ邮箱为例实现一下这个功能。　　第一件事，你需要开启QQ邮箱的IMAP/SMAP服务：　　登录QQ邮箱--设置--账号--开启IMAP/SMAP与P0P3/SMAP　　　　　　　　开启这两个时，你会获得两个密码，接下来的内容中会使用到。　　发送电子邮件服务，需要使用到一下三个JAR包：mail.jar;activation.jar;cos.jar，这里我已经帮大家整理好了，下载地址：http://pan.baidu.com/s/1sknsZOp，下载好我们的JAR包，导入到我们工程的lib目录下即可。　　发送电子邮件的JAVA代码如下：importjava.util.Properties;  importjavax.mail.*;  importjavax.mail.internet.InternetAddress;  importjavax.mail.internet.MimeMessage;/**  *使用QQ邮箱IMAP/SMTP的实现发送电子邮件  *2015-12-06*/publicclassMail{publicstaticvoidmain(String[]args){  Propertiesprops=newProperties();  props.put(mail.smtp.host,smtp.qq.com);  props.put(mail.smtp.port,587);//使用465或587端口  props.put(mail.smtp.auth,true);//设置使用验证  props.put(mail.smtp.starttls.enable,true);//使用STARTTLS安全连接  try{  PopupAuthenticatorauth=newPopupAuthenticator();  Sessionsession=Session.getInstance(props,auth);  session.setDebug(true);//打印Debug信息  MimeMessagemessage=newMimeMessage(session);  AddressaddressFrom=newInternetAddress(PopupAuthenticator.mailuser+@qq.com,);//第一个参数为发送方电子邮箱地址；第二个参数为发送方邮箱地址的标签  AddressaddressTo=newInternetAddress(xxxxxxxxxxxx,);//第一个参数为接收方电子邮箱地址；第二个参数为接收方邮箱地址的标签  message.setSubject(发送电子邮件的主题);  message.setText(发送电子邮件内容);  message.setFrom(addressFrom);  message.addRecipient(Message.RecipientType.TO,addressTo);  message.saveChanges();  Transporttransport=session.getTransport(smtp);  transport.connect(smtp.qq.com,PopupAuthenticator.mailuser,PopupAuthenticator.password);  transport.send(message);  transport.close();  System.out.println(发送成功);  }catch(Exceptione){  System.out.println(e.toString());  System.out.println(发送失败);  }  }  }classPopupAuthenticatorextendsAuthenticator{publicstaticfinalStringmailuser=1453296946;//发送方邮箱@符号前的内容:1453296946@qq.com  publicstaticfinalStringpassword=xxxxxxxxxxxx;//成功开启IMAP/SMTP服务，在第三方客户端登录时，腾讯提供的密码。注意不是邮箱密码    publicPasswordAuthenticationgetPasswordAuthentication(){returnnewPasswordAuthentication(mailuser,password);  }  }　　是不是很简单，接下来我们的邮箱验证、登录验证、注册验证、找回密码是不是都找到实现的方向啦。'>JAVA实现发送电子邮件</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>5</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/EB835F1C-974C-46A7-9F83-C5F12AC65F4B.html' title='58、线程的基本概念、线程的基本状态以及状态之间的关系线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。Java中的线程有四种状态分别是：运行、就绪、挂起、结束。59、JSP的常用指令%@pagelanguage=java contenType=text/html;charset=gb2312 session=true buffer=64kb autoFlush=true isThreadSafe=true info=text errorPage=error.jsp isErrorPage=true isELIgnored=true pageEncoding=gb2312 import=java.sql.*%isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式)%@includefile=filename%%@taglibprefix=curi=http://......%60、什么情况下调用doGet()和doPost()？Jsp页面中的form标签里的method属性为get时调用doGet()，为post时调用doPost()。61、servlet的生命周期web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do***()方法。结束服务，web容器调用servlet的destroy()方法。62、如何现实servlet的单线程模式%@ page isThreadSafe=false%63、页面间对象传递的方法request，session，application，cookie等64、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？JSP 是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是类servlet。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。65、四种会话跟踪技术会话作用域ServletsJSP 页面描述page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于 forward 指令和 include 动作的关系）session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域66、Request对象的主要方法：setAttribute(String name,Object)：设置名字为name的request的参数值getAttribute(String name)：返回由name指定的属性值getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组getCharacterEncoding()：返回请求中的字符编码方式getContentLength()：返回请求的Body的长度getHeader(String name)：获得HTTP协议定义的文件头信息getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例getInputStream()：返回请求的输入流，用于获得请求中的数据getMethod()：获得客户端向服务器端传送数据的方法getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例getParameterValues(String name)：获得有name指定的参数的所有值getProtocol()：获取客户端向服务器端传送数据所依据的协议名称getQueryString()：获得查询字符串getRequestURI()：获取发出请求字符串的客户端地址getRemoteAddr()：获取客户端的IP地址getRemoteHost()：获取客户端的名字getSession([Boolean create])：返回和请求相关SessiongetServerName()：获取服务器的名字getServletPath()：获取客户端所请求的脚本文件的路径getServerPort()：获取服务器的端口号removeAttribute(String name)：删除请求中的一个属性67、J2EE是技术还是平台还是框架？ J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。 J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。68、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？ Public String translate (String str) { String tempStr = ; try { tempStr = new String(str.getBytes(ISO-8859-1), GBK); tempStr = tempStr.trim(); } catch (Exception e) { System.err.println(e.getMessage()); } return tempStr; }69、简述逻辑操作(,|,^)与条件操作(,||)的区别。区别主要答两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型b.逻辑操作不会产生短路70、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？a: 两种形式 dtd schema，b: 本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)，c:有DOM,SAX,STAX等 DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 STAX:Streaming API for XML (StAX)71、简述synchronized和java.util.concurrent.locks.Lock的异同 ？主要相同点：Lock能完成synchronized所实现的所有功能主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。72、EJB的角色和三个对象一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性。这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象?荝emote（Local）接口、Home（LocalHome）接口，Bean类73、EJB容器提供的服务主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。74、EJB规范规定EJB中禁止的操作有哪些？ 1.不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，2.不能操作awt，3.不能实现服务器功能，4.不能对静态属生存取，5.不能使用IO操作直接存取文件系统，6.不能加载本地库.，7.不能将this作为变量和返回，8.不能循环调用。75、remote接口和home接口主要作用remote接口定义了业务方法，用于EJB客户端调用业务方法。home接口是EJB工厂用于创建和移除查找EJB实例76、bean 实例的生命周期对于Stateless Session Bean、Entity Bean、Message Driven Bean一般存在缓冲池管理，而对于Entity Bean和Statefull Session Bean存在Cache管理，通常包含创建实例，设置上下文、创建EJB Object（create）、业务方法调用、remove等过程，对于存在缓冲池管理的Bean，在create之后实例并不从内存清除，而是采用缓冲池调度机制不断重用实例，而对于存在Cache管理的Bean则通过激活和去激活机制保持Bean的状态并限制内存中实例数量。77、EJB的激活机制以Stateful Session Bean 为例：其Cache大小决定了内存中可以同时存在的Bean实例的数量，根据MRU或NRU算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个EJB实例业务方法时，如果对应EJB Object发现自己没有绑定对应的Bean实例则从其去激活Bean存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的 ejbActive和ejbPassivate方法。78、EJB的几种类型会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean会话Bean又可分为有状态（Stateful）和无状态（Stateless）两种实体Bean可分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种79、客服端调用EJB对象的几个基本步骤设置JNDI服务工厂以及JNDI服务地址系统属性，查找Home接口，从Home接口调用Create方法创建Remote接口，通过Remote接口调用其业务方法。80、如何给weblogic指定大小的内存?在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS=-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M81、如何设定的weblogic的热启动模式(开发模式)与产品发布模式?可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE=true。82、如何启动时不需输入用户名与密码?修改服务启动文件，增加 WLS_USER和WLS_PW项。也可以在boot.properties文件中增加加密过的用户名和密码.83、在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?保存在此Domain的config.xml文件中，它是服务器的核心配置文件。84、说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入 http://主机:端口号//helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办?Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。85、在weblogic中发布ejb需涉及到哪些配置文件不同类型的EJB涉及的配置文件不同，都涉及到的配置文件包括ejb-jar.xml,weblogic-ejb-jar.xmlCMP实体Bean一般还需要weblogic-cmp-rdbms-jar.xml86、如何在weblogic中进行ssl配置与客户端的认证配置或说说j2ee(标准)进行ssl的配置缺省安装中使用DemoIdentity.jks和DemoTrust.jks KeyStore实现SSL，需要配置服务器使用Enable SSL，配置其端口，在产品模式下需要从CA获取私有密钥和数字证书，创建identity和trust keystore，装载获得的密钥和数字证书。可以配置此SSL连接是单向还是双向的。87、如何查看在weblogic中已经发布的EJB?可以使用管理控制台，在它的Deployment中可以查看所有已发布的EJB88、CORBA是什么?用途是什么?CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。89、说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法 Session Facade Pattern：使用SessionBean访问EntityBeanMessage Facade Pattern：实现异步调用EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。'>java基础知识2</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>6</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/D71E3CBE-3CC9-4E3F-A85A-132F99AEA257.html' title='什么是方法？简介在上一篇的blog中，我们知道了方法是类中的一个组成部分，是类或对象的行为特征的抽象。无论是从语法和功能上来看，方法都有点类似与函数。但是，方法与传统的函数还是有着不同之处：　　在结构化编程语言里，函数是基本的程序组成单元，一个程序由一个个函数组成；　　在面向对象编程语言里，类才是程序的基本单元，方法是属于类或对象?模荒芏懒⒋嬖冢?/p>Java语言里方法的特征主要在以下几个方面：　　方法不能够独立的存在，方法只能够定义在类里面，所属与某个类或对象；　　方法不能够被独立地执行，必须使用类或者对象作为调用者；方法的分类，在Java中，方法主要分为以下几类：　　Java中的方法，主要可以分为构造方法和普通方法，而普通方法可以分为类方法和对象方法；方法的定义在前面一篇blog，我们已经知道了方法的定义方式，我们再来回顾一下：构造方法：[修饰符]类名([形参参数名]){  　　//功能代码}构造方法是你一种特殊的方法，它与普通方法有两个不同之处：方法的名字必须和类名相同，它没有返回值普通方法：[修饰符]返回值方法名([形参参数名]){//功能代码}我们可以看到，普通方法的结构主要分为5个部分，修饰符：设置方法的访问权限，可以是public、protected、private、或者是不填；返回值：调用该方法完成之后返回的内容，可以是基本的数据类型，可以是引用类型，也可以没有返回值，当没有返回值时，使用void方法名：自定义的标识符，主要是调用时使用，在类外部或非子类中调用时使用 类.方法名 或者 对象名.方法名形参：形参调用该方法时所需要传递的参数，可以有0个或多个方法体{}:方法体内主要用于定义实现功能的代码看一个完整的例子：定义一个Person类：publicclassPerson{//定义一个Person类    publicStringname;//String类型的属性name  publicintage;//int类型的属性age    publicPerson(Stringn,inta){//构造方法，有两个参数n和a，在创建对象是如果调用了该构造方法就会将name属性设置为传进来的n，age为a。  name=n;  age=a;  }publicvoidshowName(){//普通方法，主要功能是显示对象的name  System.out.println(我的名字是+name);  }publicvoidsetAge(inta){//普通方法，主要功能是设置对象的age，有一个参数，将对象的age设置为传递进来的a变量  age=a;  }publicintgetAge(){//普通方法，有一个返回值，返回对象的age  returnage;  }  }使用：publicclassTest{publicstaticvoidmain(String[]args){  Personp=newPerson(张三,20);//实例化一个对象，调用构造方法，传递进去两个参数，将参数设置给了对象的name属性和age属性  p.showName();　　　　//调用p对象的showName方法，执行了方法体里面的代码，打印出了p对象的name  p.setAge(25);　　　　//调用了p对象的setAge方法，重新设置了p对象的age属性值为25  intpAge=p.getAge();　//调用了p对象的getAge方法，该方法有一个返回值，将p对象的age属性值返回了出来，并将返回值赋值给了pAge变量}  }方法的调用与参数的传递在内存中的机制不在关键点上追根问底的程序猿不是一个好厨师，下面我们开看看方法的调用与参数传递在程序运行的内存中是一个什么样子滴情况：对于JVM运行机制，有兴趣的可以看看这几篇文章：java运行时内存分配详解深入理解JVM—JVM内存模型《深入理解Java虚拟机》笔记java运行内存分配图当然，有兴趣的并且有一定基础的童鞋推荐大家看看一本好书《深入理解Java虚拟机》我们来看看上面一个例子的代码：Person p = new Person(张三, 20);创建对象的分析我们在上篇blog中分析了，有兴趣的可以围观：[Java入门笔记] 面向对象编程基础（一）：类和对象在最后面对象创建完毕后，在内存中是这样的一个样子：程序继续向下执行：p.showName();调用p对象的showName方法，执行里面的代码：println也是一个方法，这个是JavaApi中定义的方法，执行在内存中有点麻烦，现在先不看这个，执行完这句话后打印出“我的名字是张三”继续下下执行p.setAge(25);调用p对象的setAge方法执行到这一步我们发现，这个方法有一个int类型的形参，名字为a，值为25继续执行setAge方法，将a的值赋值给age此时p对象的age属性值变化为为25，方法执行完成后清除完成代码的引用，继续下面的代码int pAge = p.getAge();执行到这一句会将p对象的age返回，并且赋值给int类型变量pAge,所以pAge的值此时也为25:方法的重载什么是方法的重载？方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。调用重载方法时，Java编译器能通过检查调用的方法的参数类型和个数选择一个恰当的方法。方法重载通常用于创建完成一组任务相似但参数的类型或参数的个数不同的方法。如何实现方法的重载？方法的重载要求两同一不同,三不受影响，两同指的是同一个类中相同的方法名，一不同是方法的形参不同，这个不同主要体现在参数个数不同或者类型不同、参数位置不同。两不受影响是：　　修饰符不同不影响方法重载。　　方法的返回值类型不能用于区分方法的重载，也就是说，无论返回值相同或者不同，都对判断方法是否重载没有影响。　　形参的名字不能用于区分方法是否重载，也就是说，如果形参的类型和个数都相同，只有参数的名字不同，则不构成重载。构造方法的重载：　　构造方法也是一种方法类型，也可以实现重载，也遵循上面的规定。例：publicclassPerson{publicStringname;publicintage;    　　publicPerson(){}    　　publicPerson(Stringn,inta){  　　　　name=n;  　　　　age=a  　　}publicvoidsetInfo(){  name=张三;  age=20;  }publicvoidsetInfo(Stringn){  name=n;  }publicvoidsetInfo(inta){  age=a;  }publicvoidsetInfo(Stringn,inta){  name=n;  age=a;  }publicvoidsetInfo(inta,Stringn){  name=n;  age=a;  }    }上面的2个构造方法和4个setInfo都是重载的方法，因为它们满足了重载的要求：相同的类中相同的方法名，不同的参数类型或个数。如果在上面的例子中添加下面的方法，不是重载：private int setInfo(){} //修饰符和返回值不同，但是上面已经有一个没有参数的setInfo方法，所以不是重载public void set(){} //方法名不同，不是重载public void setInfo(int b){} //参数名不同，类型上面有相同的，不是重载重载方法的使用：publicclassTest{publicstaticvoidmain(String[]args){  Personp1=newPerson();  Personp2=newPerson(李四,30);//这两个对象被实例化时第一个没有传递参数，所以调用第一个构造方法，第二个有两个参数，所以调用第二个构造方法  p1.setInfo();//没有参数，调用第一个setInfo方法  p1.setInfo(王五);//有一个String类型的参数，调用第二个setInfo方法}  }形参个数可变的方法如果我们在实现某个方法不确定方法有多少个参数数，我们应该怎么定义这个方法？比如，如果我们要写一个实现加法的方法，而我们不仅仅是要实现2个数相加，而是无论是有多少个数，我们都需要将它们加起来，我们应该怎样定义这个方法？显然，用普通的形式定义或者重载都不能很好的实现，而我们可以使用jdk1.5之后增加的一种形参传递方法定义这个方法。例：publicclassOperation{publicstaticintadd(int...num){intresult=0;for(inti=0;inum.length;i++){  result+=num[i];  }returnresult;  }  }这个例子中我们可以看到，定义一个可变的形参的方法，只需要在类型后面加三个点即可，调用这个方法时既可传递多个相同类型的是参数。在使用num参数时我们可以明显的看到，就是用数组的形式在使用，因此这个可变的参数在本质上来说其实就是一个数组，不过在调用时可以比较方便，请看：publicclassTest{publicstaticvoidmain(String[]args){  Operationope=newOperation();  ope.add(1,2);//计算1加2  ope.add(3,4,5);//计算3加4加5}  }我们在使用时不需要再创建一个数组对象。'>[Java入门笔记] 面向对象编程基础（二）：方法详解</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>7</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/605CBEF9-1E1D-4A81-AE3B-16900454805B.html' title='什么是面向对象编程？　　我们先来看看几个概念：面向过程程序设计面向过程，是根据事情发展的步骤，按进行的顺序过程划分，面向过程其实是最为实际的一种思考方式，可以说面向过程是一种基础的方法，它考虑的是实际地实现，一般的面向过程是从上往下步步求精。例如：如果你要吃饭，那需要：“买菜-洗菜-做饭-吃饭”等等，一步一步的来设计，就是面向过程结构化程序设计结构化程序设计是主张通过按功能来分析系统需求的一种设计思想。其主要原则可以概括为：自顶向下：程序设计时，应先考虑总体，后考虑细节；先考虑全局目标，后考虑局部目标。不要一开始就过多追求众多的细节，先从最上层总目标开始设计，逐步使问题具体化。逐步细化：对复杂问题，应设计一些子目标作为过渡，逐步细化。模块化设计：一个复杂问题，肯定是由若干稍简单的问题构成。模块化是把程序要解决的总目标分解为子目标，再进一步分解为具体的小目标，把每一个小目标称为一个模块。结构化程序设计首先采用结构化的程序分析方法进行功能需求分析，然后使用结构化设计方法对系统进行设计，最后采用结构化编程方式进行系统实现。这种采用结构化程序设计主张按功能把软件逐步细化，因此这种方法也被称为面向功能的程序设计方法。结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，作为程序入口的函数被称作主函数，由主函数调用其他函数，其他函数再调用其他一些函数，从而完成整个程序的功能。图中可以看出，结构化程序设计自顶而下的设计方式，将一些功能定义成函数模块，再一步步细化功能。结构化程序设计具有两个不足之处：1、设计不够直观，需要将客观世界的模型分解成一个一个的功能，每个功能处理一定的数据。2、可扩展性不强，当其中某一个函数需要修改其功能是，需要自上而下地修改模块结构。面向对象程序设计面向对象就是针对一个功能，而进行模块的划分，这部分和结构化程序很相似，但是有不同点，就是对象有继承，多态等形式，使得你没必要在大体相同地方要重新写程序。它从现实世界中客观存在的事物出发来构造软件系统，强调以现实世界中的事物（既对象）来思考问题。使用面向对象方式开发，其最小的程序单元是类，这些类可以生成系统中的多个对象，而这些对象则直接反应为客观世界中的各种事物，如：有“人”这样一个类，他有什么特征（年龄、体重等），有什么功能（吃饭、行走等），如果我们要完成上面面向过程中的功能，我们只需调用某个“人”对象的“食”方法即可。程序的三种基本结构无论是上面的哪种设计思想设计和实现程序，程序的设计都有可能会涉及都下面三种程序的结构：顺序结构顺序结构表示程序中的各操作是按照它们出现的先后顺序执行的。选择结构选择结构表示程序的处理步骤出现了分支，它需要根据某一特定的条件选择其中的一个分支执行。选择结构有单选择、双选择和多选择三种形式。循环结构循环结构表示程序反复执行某个或某些操作，直到某条件为假（或为真）时才可终止循环。在循环结构中最主要的是：什么情况下执行循环？哪些操作需要循环执行？循环结构的基本形式有两种：当型循环和直到型循环。当型循环：表示先判断条件，当满足给定的条件时执行循环体，并且在循环终端处流程自动返回到循环入口；如果条件不满足，则退出循环体直接到达流程出口处。因为是当条件满足时执行循环，即先判断后执行，所以称为当型循环。直到型循环：表示从结构入口处直接执行循环体，在循环终端处判断条件，如果条件不满足，返回入口处继续执行循环体，直到条件为真时再退出循环到达流程出口处，是先执行后判断。因为是直到条件为真时为止，所以称为直到型循环。类和对象面向对象的程序设计过程中有两个重要的概念：类(class)和对象(Object)。什么是类？类是对现实生活中一类具有共同特征的事物的抽象，它是一个抽象的概念。比如小轿车、摩托、卡车、公交车，他们都有共同的特征，能够机动化的行走以及运载人或物品。所以我们可以把他们抽象为一个类：车。什么是对象？对象是类这个抽象概念的一个具体体现，比如有一个类叫“人”，而这个叫张三的人、那一个叫李四的人，都是“人”这个类的具体的体现，所以他们是对象。需要注意的是：对象一定具体到某个个体，张三不一定是一个对象，因为可以有很多个叫张三的，一定是“这一个张三”才是一个对象。如何定义类定义语法：[修饰符]class类名{//类的内容}如：publicclassPerson{    }我们定义了叫“Person”的一个类。因为Java语言是区分大小写的，所以需要注意关键字的大小写的问题，类名可以自己任意定义，建议起名要具有实际意义以及每个单词首字母大写。对于一个类而言，它包含三种最常见的成员：构造器、Field和方法。三个成员都可以定义0个或多个。构造器构造器是一个类创建对象的根本途径，如果一个类没有构造器，通常无法创建对象，所以系统会为每一个类默认定义一个构造器，在不明确定义的情况下，它是隐藏的，如果明确定义了，则不会默认定义。定义构造器的语法：[修饰符]类名(){  　　功能代码  }修饰符可以是public private protected 或者不写。例：publicclassPerson{publicPerson(){}  }Field（属性）Field用于定义该类或该类实例所包含的状态数据、描述对象的特征等，定义语法如下：[修饰符]数据类型属性名=值;例：publicclassPerson{publicStringname;publicintage;  }Person（人）这个类有两个Filed，分别用来描述姓名、年龄。上面这个例子中没有为其定义一个构造器，所以系统会为其默认一个构造器：public Person(){}方法方法用来定义该类或该类实例的行为特征或功能实现。语法如下：[修饰符]返回值方法名([形参参数名]){//功能代码}例：publicclassPerson{//定义一个Person类  publicStringname;//具有Field姓名(name)、年龄(age)  publicintage;publicPerson(){}//第一个构造方法    publicPerson(Stringn,inta){//第二个构造方法，有两个参数n和a，在创建对象是如果调用了该构造方法就会将name属性设置为传进来的n，age为a。  name=n;  age=a;  }publicvoideat(Strings){//方法，模拟吃东西的功能  System.out.println(name+在吃+s);  }publicvoidsleep(inthour){//方法，模拟睡觉功能  System.out.println(name+睡了+hour+个小时);  }  }对象的创建和使用前面已经说明过，创建对象的根本途径是构造器，通过new关键字调用该类的构造器来创建一个对象，如：上面我们已经定义了一个“人”类，我们通过它创建一个对象。Personp;//定义一个Person类型的变量p=newPerson();//通过new关键字Person类的第一个构造器，返回一个Person实例，也就是该对象。也可以这样：Personp=newPerson(张三,20);//我们将上面的两步简化为一步，并且调用第二个构造方法，传递两个参数，为这个对象设置了姓名和年龄。有了对象，我们就可以使用它了：使用对象：使用“.”进行以下操作　　给类的属性赋值：对象名.属性　　调用类的方法：对象名.方法名()System.out.println(p.name);//将这个对象的名称打印出来p.sleep(5);//调用睡觉的方法创建和使用对象在内存中的示例上面我们有这样一行代码：Person p = new Person(张三, 20);这行代码创建了一个Person对象，这个对象被赋值给p变量。这行代码中实际产生了四个东西，p变量和Person对象、张三对象、数字20当有等号时会先执行等号右边的代码new Person(张三, 20)，这句代码中调用的是public Person(String n, int a)构造方法，而我们发现，在这个方法中也有两个变量String类型的n和int类型的a，所以执行这句话时内存中是这样的：产生两个变量s和a，s是一个引用类型的变量，它在栈内存中存储的是一个堆内存中的内存地址，该地址指向堆内存中String类型的一个对象，啊变量是一个int类型数据，所以它的数值直接存储在栈内存中。调用构造方法首先会创建一个Person类型的对象，对象中有name和age两个属性：构造方法中有两句代码name = n; age = a;此时会将两个值赋给给对象name = n:指向同一个对象age = a:将值复制给age继续执行，构造方法结束，清除a变量和s变量，执行语句等号右边代码，创建一个Person类型变量p，该变量指向通过构造方法返回的Person对象            对象创建完成。谢谢大家阅读，如有错误之处，欢迎大家指正。( ^_^ )'>[Java入门笔记] 面向对象编程基础（一）：类和对象</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>8</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/AB8A0676-FBCD-480E-BF17-2C50640DFFC8.html' title='成员方法必须有返回类型即使是没有返回，也要写上void构造函数没有返回类型，而且和类名一样！一个类里面，一看就知道了譬如：public class Test{public Test(){} //构造函数public Test(int i)(){} //构造函数public void test(){}//public int test2(){}//方法！}'>JAVA构造函数与方法是啥意思</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>9</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/42F12A3E-945C-4FB1-8A09-31041C2884EF.html' title='com.chenyang.www.demo{  ([]numbers){  tempsize=numbers.(i=isize-i++){  (j=i+jsizej++){  (numbers[i]numbers[j]){temp=numbers[i]numbers[i]=numbers[j]numbers[j]=temp}  }  }  }  ([]numbersstartend){  (startend){  base=numbers[start]tempi=startj=end{  ((numbers[i]base)(iend))  i++((numbers[j]base)(jstart))  j--(i=j){  temp=numbers[i]numbers[i]=numbers[j]numbers[j]=tempi++j--}  }(i=j)(startj)  (numbersstartj)(endi)  (numbersiend)}  }  ([]numbers){  size=numbers.temp(i=isizei++){  k=i(j=size-jij--){  (numbers[j]numbers[k])k=j}  temp=numbers[i]numbers[i]=numbers[k]numbers[k]=temp}  }  ([]numbers){  size=numbers.tempj(i=isizei++){  temp=numbers[i](j=ijtempnumbers[j-]j--)  numbers[j]=numbers[j-]numbers[j]=temp}  }  ([]numbersleftright){  t=size=right-left+(tsize){  s=tt=*si=left(i+(t-)size){  (numbersii+(s-)i+(t-))i+=t}  (i+(s-)right)  (numbersii+(s-)right)}  }  ([]datapqr){  []B=[data.]s=pt=q+k=p(s=qt=r){  (data[s]=data[t]){  B[k]=data[s]s++}{  B[k]=data[t]t++}  k++}  (s==q+)  B[k++]=data[t++]B[k++]=data[s++](i=pi=ri++)  data[i]=B[i]}  {  (){  ()}  ([]numbers){  tempsize=numbers.(i=isize-i++){  (j=i+jsizej++){  (numbers[i]numbers[j]){temp=numbers[i]numbers[i]=numbers[j]numbers[j]=temp}}}}  ([]numbersstartend){  (startend){  base=numbers[start]tempi=startj=end{  ((numbers[i]base)(iend))  i++((numbers[j]base)(jstart))  j--(i=j){  temp=numbers[i]numbers[i]=numbers[j]numbers[j]=tempi++j--}  }(i=j)(startj)  (numbersstartj)(endi)  (numbersiend)}  }  ([]numbers){  size=numbers.temp(i=isizei++){  k=i(j=size-jij--){  (numbers[j]numbers[k])  k=j}  temp=numbers[i]numbers[i]=numbers[k]numbers[k]=temp}  }  ([]numbers){  size=numbers.tempj(i=isizei++){  temp=numbers[i](j=ijtempnumbers[j-]j--)  numbers[j]=numbers[j-]numbers[j]=temp}  }  ([]numbersleftright){  t=size=right-left+(tsize){  s=tt=*si=left(i+(t-)size){  (numbersii+(s-)i+(t-))i+=t}  (i+(s-)right)  (numbersii+(s-)right)}  }  ([]datapqr){  []B=[data.]s=pt=q+k=p(s=qt=r){  (data[s]=data[t]){  B[k]=data[s]s++}{  B[k]=data[t]t++}  k++}  (s==q+)  B[k++]=data[t++]B[k++]=data[s++](i=pi=ri++)  data[i]=B[i]}  }  }'>java常见五种排序方式</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>10</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/6315F714-532C-47D0-8AD3-6184EE8C377F.html' title='java 读写word java 动态写入 模板文件importjava.io.ByteArrayOutputStream;  importjava.io.File;  importjava.io.FileInputStream;  importjava.io.FileNotFoundException;  importjava.io.FileOutputStream;  importjava.io.IOException;  importjava.util.HashMap;  importjava.util.Iterator;  importjava.util.Map;    importorg.apache.poi.hwpf.HWPFDocument;  importorg.apache.poi.hwpf.model.FieldsDocumentPart;  importorg.apache.poi.hwpf.usermodel.Field;  importorg.apache.poi.hwpf.usermodel.Fields;  importorg.apache.poi.hwpf.usermodel.Paragraph;  importorg.apache.poi.hwpf.usermodel.Range;  importorg.apache.poi.hwpf.usermodel.Table;  importorg.apache.poi.hwpf.usermodel.TableCell;  importorg.apache.poi.hwpf.usermodel.TableIterator;  importorg.apache.poi.hwpf.usermodel.TableRow;/**  *@authorzhangchaochao  *@date2015-12-4上午10:30:59*/publicclassMSWordPoi4  {    /**  *@paramargs  */  publicstaticvoidmain(String[]args)  {  MapString,Stringmap=newHashMapString,String();  map.put(${sub},湖南大学);  map.put(${item2.school},湖南大学);  map.put(${item2.address},湖南);  //map.put(${item1.name},王五1);  //map.put(${item1.numberStudent},编号002);  //map.put(${item1.sex},男2);  //map.put(${item1.age},19);  StringsrcPath=D:\\铸造工艺卡.doc;  readwriteWord(srcPath,map);  }    /**  *实现对word读取和修改操作  *  *@paramfilePath  *word模板路径和名称  *@parammap  *待填充的数据，从数据库读取  */  publicstaticvoidreadwriteWord(StringfilePath,MapString,Stringmap)  {  //读取word模板  //StringfileDir=new  //File(base.getFile(),http://www.cnblogs.com/http://www.cnblogs.com/../doc/).getCanonicalPath();  FileInputStreamin=null;  try  {  in=newFileInputStream(newFile(filePath));  }  catch(FileNotFoundExceptione1)  {  e1.printStackTrace();  }  HWPFDocumenthdt=null;  try  {  hdt=newHWPFDocument(in);  }  catch(IOExceptione1)  {  e1.printStackTrace();  }  Fieldsfields=hdt.getFields();  IteratorFieldit=fields.getFields(FieldsDocumentPart.MAIN)  .iterator();  while(it.hasNext())  {  System.out.println(it.next().getType());  }    //读取word文本内容  Rangerange=hdt.getRange();  TableIteratortableIt=newTableIterator(range);  //迭代文档中的表格  intii=0;  while(tableIt.hasNext()){  Tabletb=(Table)tableIt.next();  ii++;  System.out.println(第+ii+个表格数据...................);  //迭代行，默认从0开始  for(inti=0;itb.numRows();i++){  TableRowtr=tb.getRow(i);  //只读前8行，标题部分  if(i=8)break;  //迭代列，默认从0开始  for(intj=0;jtr.numCells();j++){  TableCelltd=tr.getCell(j);//取得单元格  //取得单元格的内容  for(intk=0;ktd.numParagraphs();k++){  Paragraphpara=td.getParagraph(k);  Strings=para.text();  System.out.println(s);  }//endfor  }//endfor  }//endfor  }//endwhile  //System.out.println(range.text());    //替换文本内容  for(Map.EntryString,Stringentry:map.entrySet())  {  range.replaceText(entry.getKey(),entry.getValue());  }  ByteArrayOutputStreamostream=newByteArrayOutputStream();  StringfileName=+System.currentTimeMillis();  fileName+=.doc;  FileOutputStreamout=null;  try  {  out=newFileOutputStream(D:/+fileName,true);  }  catch(FileNotFoundExceptione)  {  e.printStackTrace();  }  try  {  hdt.write(ostream);  }  catch(IOExceptione)  {  e.printStackTrace();  }  //输出字节流  try  {  out.write(ostream.toByteArray());  }  catch(IOExceptione)  {  e.printStackTrace();  }  try  {  out.close();  }  catch(IOExceptione)  {  e.printStackTrace();  }  try  {  ostream.close();  }  catch(IOExceptione)  {  e.printStackTrace();  }  }  }'>java 读写word java 动态写入 模板文件</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>11</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/A5CB71BA-D38F-4180-AC42-45AE790384BB.html' title='在Java中，我们常常会看到一个类型：Class。并且在类似Person.class，cache.getClass()等代码中见到它的身影。众所周知，Class是用来描述一个类的类型，而Object是所有对象的最终父对象。那么就会引申出下边的两个结论：1、如果从对象的角度来看，那么肯定是先有Object对象，其次才有其派生的对象Class。2、Class表示的是类、对象，肯定是先有类这个概念，其次才有各个类型（抽象的、非抽象的），包括Object。这就会出现一个问题，到底是先有Class（鸡）还是先有Object（蛋）？好吧，此处先给出答案，是先有Object，然后才有Class的。原因是Object，是所有对象的最终父对象，而Class本身也是一个对象。所以是先有Object，然后才Class对象的。那么如何解释第二点呢？ 这是因为一个概念被混淆了。在Java中，所有的对象都派生自Object，而Class类（注意此处是大写也是一个类）所以他也继承自Object，这个我们可以在eclipse里边通过查看类的继承关系清楚的看到。在Java中，还有一个class（注意此处是小写）。他表示的是一个个(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )对象，也就是一个个类。Object是这些对象的其中之一。同时在这些对象中有一个对象，它的作用是用来识别标记其它对象的内容，这个类叫做Class（注意此处是大写）。 因此就会出现有一个class的名字叫做Class。而问题中将class等价于Class，很显然是不合理的。两者完全不在一个维度里。所以这样就可以很好的理解，JVM在启动后，会加载各个需要的class，其中包括Class。抛砖引玉----深入学习Class类了解了class，Object，Class的关系，我们接下来深入说说Class类。（这才是这篇博客的主要目的）一、背景知识类对象在使用之前都会被JVM加载（其实是经过加载、连接、初始化三个步骤对类完成初始化）。类加载指的就是JVM?玞lass文件读入内存，并为之创建一个Class对象。同时当一个类被加载后，再次使用时，就不会被重复加(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )载。这样新建的Class与加载的class就形成一一对应的关系。 通过该Class对象，就可以访问到对应的class。所以我们可以把Class理解为一个类的标识对象，它相当于是一个类的标签（铭牌）。拿到一个Class，我们就可以找到对应的类（class）。二、获取Class对象的方法在Java中我们可以使用三个方法拿到Class对象。其中两种是针对已经在家的类对象，去获得他对应的Class对象。剩余一种利用到了反射，根据提供的类名去寻找对应的class文件，进而找到Class对象。1Class.forName(StringclassName)//className表示完整的名称，包括该类的包名。如果无法找到，该方法会抛出一个2Person.class//Person代表的是一个类，class字段是其默认的属性3person.getClass()//getClass是Obj类的一个实例方法，所有的类都有该方法，包括Class类三、 从Class中可以获取到的信息系统可以通过Class对象，找到该对象对应的class.而Class对象包含了class的基本详细信息。这些信息可以分为以下四个方面： 1、获取到class所包含的构造器。 2、获取到class所包含的方法。 3、获取到class所包含的成员变量。 4、获取到class所包含的Annotation。 ps 很多小伙伴可能对Annotation不太熟悉，这里简单说下：Annotation翻译为注解，本身也是一个类，可以用来保存类的描述信息。 有兴趣的可以参考下面这篇文章：http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html四、在工作中Class类的使用用途在这里我总结了一下曾经遇到的使用情况，将其分为；两方面，如果有遗漏，大家可以补充。1、对对象类型的使用和校验有些时候，我们需要对传入对象的类型进行校验，判断传入的对象是否为我们需要的类型。if(para.getClass==Person.class)//如果这里使用instance关键字，则可能会受到Person类继承关系的干扰，导致无法进行正确的判断。2、反射1用字符串定义需要加载的类名，然后等到需要时候再加载。　　这样做有三个用途：　　（1）有时候并不知道此处需要加载的类型，需要在运行时才可能知道需要加载哪个class，譬如在运行的过程中，根据用户的手动设置，动态的选择接下来要加载的类。 　　（2）在编?胧币丫佬枰釉氐睦嗝巧形扌枰釉氐?class文件，需要在运行时，通过用户上传，或者后台到指定地址下载class文件。  插件化开发的实现就是使用这样一个原理。举两个例子：　　　　　　（α）用户在使用过滤时，需要自己来定义一套复杂的过滤机制，这时可能就无法通过界面简单的设置一下需要过滤的内容。可以由用户手动的上传自己的过滤算法的jar包，然后由后台动态的加载，使用该算法。　　　　　　（β）亦或者有时候在工作环境中，对于皮肤显示有一套默认的显示效果，同时也支持用户自己上传需要显示效果的jar包。后台拿到用户上传的jar包后，反射出需要用到的特效算法，形成动态的交互。　　（3）缩短编译时间，加快启动软件的速度（包括client 和server）　　在启动时，包含main方法的类被加载，同时它会加载(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )所自己需要的类。这些类再一次加载自己所需要的类。形成递推关系。但是对一个大应用程序来说，整个的启动（加载）过程耗费的时间，常常让用户无法忍受，甚至在还未加载完时就被强制关闭了。　　针对这种情况，我们就可以在mian方法类中加载一些最基本的类。诸如登录、验证等。当登录验证没有问题之后，需要进入业务操作时，才会根据用户的选择，  加载用户需要的类。从而提高软件整体的运行效率和用户体验。2对于工具的开发和使用当我们开发工具或脚本时，除了使用系统公开的API外，有时还需要用到原有代码中被私有化的一些变量和方法。这时仅仅使用继承是不够的，还需要反射出对象，拿到其中的变量或调用其中的方法。 比如平常使用的UT框架，有时为了测试效率，就提供了很多可以直接调用待测试类私有方法的API。'>Java中关于先有鸡还是先有蛋的问题----Class&Object</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>12</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/F944D9BC-6D53-4908-8C62-4C1BE5AE182A.html' title='服务器开发，高并发始终是一个不断追求的目标。若实现这个目标，将所有阻塞操作异步化是必不可少的。执行异步任务，最容易想到的是使用多线程，但线程不是多多益善，相反要控制在一定的数量。如何在多线程环境下，合理地进行任务派发，是这篇文章要讨论的。就像在概述中描述的，单个游戏服务器进程主要分三层：网络、逻辑和数据存取，下面将具体阐述。网络层使用Netty，将有若干worker线程收发网络消息，收到消息后如何处理呢？我见过一些服务器程序，直接在收发消息的回调函数里，执行逻辑，甚至进行数据存取，这显然是不合适的。网络线程应该专注于收发消息的操作。首先网络线程一般都是多线程，直接执行业务逻辑，即意味着业务逻辑在多线程环境下，数据同步等就成了必须解决的问题。其次一旦业务逻辑耗时较多，尤其进行数据存取操作，网络线程就会阻塞，这将严重影响网络通信进而降低并发。合适的做法是将网络消息放到逻辑线程队列，所有后续业务逻辑都交由逻辑线程处理。在Java中可以使用concurrent包提供的队列容器，比如：privateConcurrentLinkedQueueRequestActionrequestActionQueue=newConcurrentLinkedQueueRequestAction();逻辑线程依次从队列里取出消息并处理。这里有一个常见的困惑，逻辑线程该使用单线程还是多线程。事情不能一概而论，但大多数情况下，逻辑层是最耗CPU的，多线程并不能提高性能，并会带来数据同步等相关的问题。所以在不知道如何抉择时，单线程是更好的选择。逻辑单线程，就意味着不应该有任何阻塞操作，而业务逻辑不可避免地要进行数据存取。异步任务派发就是为了解决诸如数据存取等阻塞操作需求，同时需要回调在任务结束后执行后续业务逻辑。先看一个具体示例：publicclassRAUserLoginCLextendsRequestAction{    UserLoginCLreq=null;@Override  publicvoidsetRequest(Messagemsg){  req=(UserLoginCL)msg;  }@Override  publicvoidexecute(){finalStringusername=req.username;finalStringpassword=req.password;TaskLoadUsertask=newTaskLoadUser(session,req);Useruser=AppLogin.getLogicService().getUserManager().getUser(username);if(user!=null){  task.setUserData(user.getUserData());  }AppLogin.getLogicService().getTaskManager().pushTask(task);  }  }上面这段代码，即是用户登录消息的处理。UserLoginCL是登录消息包，网络IO线程收到该消息后，封装成RequestAction并push到逻辑线程消息队列。逻辑线程在逻辑循环中取到该消息，并调用execute()进行业务处理。这里将处理逻辑简化，简单说就是将请求信息再封装成TaskLoadUser任务，因为我们必须先要（从数据库）加载用户数据（UserData)到内存，才能进行密码验证等逻辑。这个任务依然会首先放到一个当前逻辑线程的任务队列，然后等待执行。publicclassTaskManager{    privateConcurrentLinkedQueueTasktaskQueue=newConcurrentLinkedQueueTask();  privateConcurrentHashMapInteger,TasktaskMap=newConcurrentHashMapInteger,Task();  privateAtomicIntegernextSeq=newAtomicInteger(1000);    publicvoidtick(longmilliseconds){while(!taskQueue.isEmpty()){Tasktask=taskQueue.poll();  task.execute();    putTask(task);  }IteratorMap.EntryInteger,Taskiterator=taskMap.entrySet().iterator();while(iterator.hasNext()){Map.EntryInteger,Taskentry=iterator.next();Tasktask=entry.getValue();  task.tick(milliseconds);if(task.isFinished()){  task.onFinish();iterator.remove();continue;  }if(task.isTimeout()){  task.onTimeout();iterator.remove();continue;  }  }  }  ...看这个任务代码：publicclassTaskLoadUserextendsTask{    privateTransmitSessionsessionIn=null;  privateUserLoginCLreqIn=null;    privateUserLoginLCrspOut=newUserLoginLC();    privatevolatileUserDatauserDataOut=null;    publicTaskLoadUser(TransmitSessionsessionIn,UserLoginCLreq){  this.sessionIn=sessionIn;  this.reqIn=req;  }    @Override  publicvoidexecute(){  setResult(UserLoginLC.SUCCESS);  incDesire();if(userDataOut!=null){  decDesire();return;  }DaoService.execute(()-{do{  finalStringusername=reqIn.username;UserDatauserData=DbUser.getUserDataByName(username);    //用户不存在if(userData==null){  setResult(UserLoginLC.ERROR_NOUSER);break;  }    userDataOut=userData;  }while(false);  decDesire();  });  }    @Override  publicvoidonFinish(){if(result!=UserLoginLC.SUCCESS){  rollback();  failResponse();return;  }    succeedResponse();  }    @Override  publicvoidonTimeout(){  setResult(UserLoginLC.TIMEOUT);  rollback();  failResponse();  }    publicvoidsetUserData(UserDatauserData){  this.userDataOut=userData;  }    privatevoidrollback(){  //Notingtodo  }    privatevoidsucceedResponse(){  //检查密码if(!reqIn.password.equals(userDataOut.password)){  rspOut.result=UserLoginLC.ERROR_WRONGPWD;  sessionIn.send(rspOut);return;  }  ...  rspOut.result=(byte)result;  rspOut.userId=userId;  rspOut.token=token;  sessionIn.send(rspOut);  }    privatevoidfailResponse(){  rspOut.result=(byte)result;  sessionIn.send(rspOut);  }  }上面两段代码是异步任务的核心。逻辑线程取到这个任务后，调用execute()，它会通过数据存取层从数据库中加载数据。execute()执行后，逻辑线程仍然继续检测这个任务，直到其完成或超时。如果完成会调用onFinish()执行后续逻辑，加载可能成功或失败，分别对应succeedResponse()和failResponse()，如果执行超时则执行onTimeout()。DaoService即对应数据存取层，实现上是一个线程池：publicclassDaoService{publicstaticfinalintIOTHREADNUMBER=Runtime.getRuntime().availableProcessors()*2;privatestaticfinalExecutorServiceexeSvc=Executors.newFixedThreadPool(IOTHREADNUMBER);publicstaticvoidexecute(RunnabledaoOperation){  exeSvc.execute(daoOperation);  }  }这就实现了多线程异步数据存取。代码很简短，不了解的可以查阅下Java线程池相关知识。逻辑线程使用数据存取层异步加载数据，加载完成与否，逻辑线程如何得知呢？incDesire()和decDesire()，就是用来解决这个问题，其类似引用计数。我们可以把所有阻塞操作分解成一个个可以用多线程去异步执行的子任务，先调用incDesire(N)增加计数，N即分解的子任务数，然后使用DaoService.execute()去依次并行执行这些子任务。每完成一个子任务调用一次decDesire(1)将计数减1，计数为0时，即表明所有异步子任务都已执行完毕。如过指定时间内计数仍然大于0，即超时。还有一个技巧是，每执行完一个子任务，设置一个数据或标志，那么在整个任务失败或超时时，就可以执行rollback()回退已完成的子任务。这里有个地方需要注意下。即使只有一个子任务，也应该先调用一次incDesire()。否则，因为初始任务计数为0，异步任务是多线程执行的，可能子任务还在执行中，逻辑线程就已经检测到任务计数为0而错误认为任务已经完成了。经过上述这些做法，消息收发、业务逻辑和数据存取实现了完全异步化，不再存在阻塞点。需要说明的是，异步任务并非是完美的，异步越多，响应延迟越大。高并发、低延时、易扩展，是一个需要综合权衡的目标。'>Java游戏服务器-多线程异步任务派发</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>13</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/AA822781-4E60-496F-AE7D-52F5921085FE.html' title='CAS，即Compare and Swap，中文翻译为“比较并交换”。对于JUC包中，CAS理论是实现整个java并发包的基石。从整体来看，concurrent包的实现示意图如下：i++是一个非常经典的操作，它几乎充斥着我们每个人编写的代码中。我们知道i++是可以分解的，它分解为getI()、i + 1 、setI三个步骤，所以它并不是原子操作。如果i==1，执行两次i++操作，我们期望的结果是3，但是结果有可能也是2：那么有什么办法解决这个问题呢？肯定有！使用锁即可：synchronized(this){  i++;  }诚然，在java中存在乐观锁、悲观锁两种锁。其中synchronized就是悲观锁，在前面我们了解synchronized也是独占锁，加入关键字synchronized的代码一般都是以单线程的形式在运行着，它会导致其他需要该资源的线程挂起直到前面的线程执行完毕释放资源，所以它的效率较为低下。而乐观锁则采用了一种较为高效的方式，它的操作与synchronized不同，synchronized采用加锁，而它则不采用加锁去执行某些操作，如果发生了冲突则失败并一直重试直到成功为止。而CAS就是一种乐观锁，它所采用的策略是当且仅当预期值A和存中的值V相同，则将内存V值修改为B，否则返回V。实现如下：for(;;){if(A==V){  V=B;  }  }当然在J.U.C中实现CAS没有这么简单。CASCAS，即一种对内存中的共享数据进行操作的指令，而且该操作是原子的读写操作。其过程如下：首先CPU将内存中的将要被修改的数据与预期的值进行比较，如果这两个值相等，CPU则会将内存中数值替换为新值，否则不做操作。最后，CPU会将旧值返回。在java中，CAS的含义就是“我认为的原本的值是什么，如果你是，则更换为新值，否则不做修改同时麻烦告诉我该值时多少”。在CAS中，总共存在三个操作数：预期值A、内存中的V、修改的值B。当且仅当预期值A和内存中的值V相同，则将内存V值修改为B，否则返回V。使用这种机制编写的算法也叫作非阻塞算法，标准定义了一个线程的失败或者挂起是不会影响其他线程的失败或者挂起。下面我们来已AtomicIneger的源码为例来看看CAS操作：publicfinalintgetAndAdd(intdelta){for(;;){intcurrent=get();intnext=current+delta;if(compareAndSet(current,next))returncurrent;  }  }这里很显然使用CAS操作（for(;;)里面），他每次都从内存中读取数据，+1操作，然后两个值进行CAS操作。如果成功则返回，否则失败重试，直到修改成功为止。上面源码最关键的地方有两个，一个for循环，它代表着一种宁死不屈的精神，不成功誓不罢休。还有就是compareAndSet：publicfinalbooleancompareAndSet(intexpect,intupdate){returnunsafe.compareAndSwapInt(this,valueOffset,expect,update);  }CAS的缺陷尽管CAS机制可以使我们不依赖与同步，不影响和挂起其他线程，它大大提升了运行的效率，但是它会导致一个ABA的问题，如下：加入有两个线程A、B，他们都读取内存中的数据V，假如这个时候线程A，先将V修改为V1，然后又修改为V，这个时候线程B的compareAndSet仍然能成功，对于线程B而言该值V并没有发生任何变化，而实际上它已经变化了，只不过最后又还原了而已。'>【Java并发编程实战】-----“J.U.C”：CAS操作</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>14</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/83D3B2CD-4E7D-41B8-95E1-B9F816058619.html' title='其语法如下：　　for(type element: array)　　{ 　　System.out.println(element);　　}例子　　其基本使用可以直接看代码：　　代码中首先对比了两种for循环；之后实现了用增强for循环遍历二维数组；最后采用三种方式遍历了一个List集合。importjava.util.ArrayList;importjava.util.Iterator;importjava.util.List;publicclassForeachTest  {publicstaticvoidmain(String[]args)  {int[]arr={1,2,3,4,5};    System.out.println(----------旧方式遍历------------);//旧式方式  for(inti=0;iarr.length;i++)  {  System.out.println(arr[i]);  }    System.out.println(---------新方式遍历-------------);  //新式写法,增强的for循环  for(intelement:arr)  {  System.out.println(element);  }    System.out.println(---------遍历二维数组-------------);  //遍历二维数组    int[][]arr2={{1,2,3},{4,5,6},{7,8,9}};  for(int[]row:arr2)  {for(intelement:row)  {  System.out.println(element);  }  }  //以三种方式遍历集合List  ListStringlist=newArrayListString();    list.add(a);  list.add(b);  list.add(c);    System.out.println(----------方式1-----------);//第一种方式，普通for循环  for(inti=0;ilist.size();i++)  {  System.out.println(list.get(i));    }    System.out.println(----------方式2-----------);//第二种方式，使用迭代器  for(IteratorStringiter=list.iterator();iter.hasNext();)  {  System.out.println(iter.next());  }  System.out.println(----------方式3-----------);//第三种方式，使用增强型的for循环  for(Stringstr:list)  {  System.out.println(str);    }  }    }For-Each循环的缺点：丢掉了索引信息。　　当遍历集合或数组时，如果需要访问集合或数组的下标，那么最好?褂镁墒降姆绞嚼词迪盅坊虮槔灰褂迷銮康膄or循环，因为它丢失了下标信息。'>增强For循环</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>15</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/B2CC05B8-A7DD-4744-BA52-55B8863A2559.html' title='一.servlet简介servlet(server applet)是sun公司提供的一门用于开发动态web资源的技术sun公司在其API中提供了servlet接口,如果用户想要开发web资源,需要：1.编写一个java类,实现servlet接口2.把开发好的java类部署到web服务器中二.servlet的运行过程servlet是由web服务器调用,web服务器收到客户端的servlet访问请求后：1.web服务器首先检查是否已经装载并创建了该servlet的实例对象　　是----执行第4步   不是--执行第2步2.装载并创建该servlet的一个实例对象3.调用servlet实例对象的init()方法4.创建一个用于封装http请求消息的HttpServletRequest对象和封装http响应消息的HttpServletResponse对象,然后调用servlet的service()方法,并将请求和响应作为参数传递进去5.web应用程序被停止或重新启动之前,servlet引擎将卸载Servlet,并在卸载之前Servlet的destory()方法与生命周期有关的方法可见Servlet的方法是与生命周期有关的方法,那么来看一下它的与生命周期有关的方法·public voidinit(ServletConfigconfig)throws ServletException多个客户请求Servlet时,引擎会为每个客户启动一个线程,所以Servlet类的成员变量被所有的线程共享(Servlet是单实例多线程)·public voidservice(HttpServletRequestrequest ,HttpServletResponseresponse)　　　　　　　　　　　　　　　　　　　　　　　　　　　　throw ServletException,IOException处理用户的请求和响应,每个用户的请求Servlet都会调用该方法,但是调用的时候在不同的线程中,所以互不干扰·publicdestory()当Servlet引擎终止服务时,比如关闭服务器,destory就会被执行,消灭servlet对象三.Servlet接口的实现类Servlet接口Sun公司定义了两个默认实现类GenericServlet(空实现)和HttpServlet(能够处理htpp请求的servlet)在开发中我们只需要继承HttpServlet类,再其service()方法中进行请求处理和数据相应四.访问开发好的Servlet资源由于客户端(浏览器)是通过URL地址访问web服务器中的资源,所以Servlet程序想要被访问就必须把Servlet映射到一个URL地址上·在web.xml中配置　　servlet元素用来注册Servlet,它包含有两个主要的子元素　　　　servlet-name注册名称　　　　servlet-class完整类名　　　　load-on-startup创建web应用程序的时候装载该Servlet　　　　init-param配置属性　　servlet　　　　servlet-nameServlet/servlet-name　　　　servlet-classcctv.Session.Servlet/servlet-class　　/servlet　　servlet-mapping元素用来映射一个已注册的Servlet的一个对外访问路径　　　　servlet-name注册名称　　　　url-pattern对外访问路径　　servlet-mapping　　　　servlet-nameServlet/servlet-name　　　　url-pattern/servlet/servlet/url-pattern　　/servlet-mapping五.Servlet的特点1.针对客户端的多次Servlet请求,服务器只会创建一个Servlet实例对象,也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁.2.在Servlet生命周期中init()方法只会调用一次,对于service()方法,每次请求都会去调用该方法并且实例请求响应对象六.线程安全(等待更新)实现SingleThreadModel接口七.Servlet的一些对象ServletConfig对象Config翻译过来是配置的意思，可想而知这个对象是用来配置文件的,那么它是如何来配置文件的？在web.xml文件中利用init-param为servlet配置一些初始化参数储存以键值对的形式进行init-param　　param-nameurl/param-name　　param-valuejdbc:mysql://localhost:3306/param-value/init-param通过该对象的getInitParameter(name)方法获取name的value,或者通过getInitParameterNames()方法获取枚举器然后进行迭代获取所有的name与valueServletContext对象Context翻译过来是上下文的意思,可想而知这个对象是用来代表这个web应用的'>servlet学习</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>16</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/6B43E253-1225-4B5D-8902-74151E7BFA59.html' title='热点随笔：·从.net转型，聊聊最近一些面试,薪资和想法（爱吃猫的鱼）·给Java程序猿们推荐一些值得一看的好书（五月的仓颉）·.Net缓存管理框架CacheManager（JustRun）·架构之路（六）：把框架拉出来（自由飞）·狗屎的Java规范（NewSea）·GitHub 上一份很受欢迎的前端代码优化指南-强烈推荐收藏（yonghu86）·VS快速生成JSON数据格式对应的实体（只喝牛奶的杀手）·京东咚咚架构演进（mindwind）·Asp.Net MVC+BootStrap+EF6.0实现简单的用户角色权限管理10（yjq_叶）·视错觉：从一个看似简单的自定义控件说起（青玉伏案）·领域驱动设计实战—基于DDDLite的权限管理OpenAuth.net（李玉宝）·深入CSS，让网页开发少点“坑”（葡萄城控件技术团队）热点新闻：·程序猿也疯狂：一款插件给写代码带来的超爽视觉震撼·63岁老人自学单片机 8年做出机器人：有图有真相·中国软件百强一丁集团破产 跑路老板：永远别跟银行借钱·凤姐加入“天使投资人”行列 公开约战董明珠·ASP.NET 5 and .NET Core RC准备投入使用·12.3日 PHP 7！鸟哥：写在PHP 7发布之际·北京一男子用100天收集雾霾 灰尘制成板砖·盖茨为90岁父亲庆生：他对我影响巨大·Visual Studio 2015 Update 1发布·程序员最恐怖的梦魇是什么？·4190元开售！微软首款Windows 10智能手机能秒变电脑·谷歌返华：谁会看好，谁在唱衰，谁会恐慌，谁又在期待'>JAVA开发中遇到的问题和解答汇总</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>17</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/430A3944-3EE9-49E1-9CA6-8BBE54A85876.html' title='publicstaticvoidmain(String[]args){  ReaderMyXmlreader=newReaderMyXml();  HashMapString,Stringhm=newHashMapString,String();  Stringn=System.getProperty(user.dir);//获取当前工程真实路径  //System.out.println(n);  Stringpath=n+\\src\\students.xml;  //System.out.println(path);  reader.toReaderXml(path,hm);  System.out.println(hm.size());  System.out.println(--------------------------------------------);  System.out.println(姓名\t年龄\t性别\t电话);  /*  *for(inti=0;ihm.size()/4-1;i++){  *System.out.print(hm.get(stuname:+(i+1))+\t);  *System.out.print(hm.get(stuage:+(i+1))+\t);  *System.out.print(hm.get(sex:+(i+1))+\t);  *System.out.print(hm.get(phone:+(i+1))+\t);System.out.println();  *}  */  for(inti=0;ihm.size();i+=5){  intits=i/5+1;  System.out.print(hm.get(stuname:+(its))+\t);  System.out.print(hm.get(stuage:+(its))+\t);  System.out.print(hm.get(sex:+(its))+\t);  System.out.print(hm.get(phone:+(its))+\t);  System.out.println();  }  System.out.println(--------------------------------------------);  }  }  */  @SuppressWarnings(unchecked)  publicvoidtoReaderXml(StringfileName,HashMapString,Stringhm){  //创建Dom4J的一个对象  SAXReadersaxReader=newSAXReader();  //创建File类，xml是一个文件，所以要得到这个文件  FilexmlFile=newFile(fileName);    intnum=0;  try{  //装载到Dom4J中  Documentdocument=saxReader.read(xmlFile);  //获取xml的根节点,对我我们当前的XML文件，跟节点是：students  Elementroot=document.getRootElement();  //获取到根节点之后就可以根据根节点获取其下所有的子节点  for(IteratorElementitera=root.elementIterator();itera.hasNext();){  //读取二级节点  ElementsecondNode=itera.next();  num++;  AttributeidAttr=secondNode.attribute(id);  if(idAttr!=null){  hm.put(idAttr.getName()+:+num,idAttr.getValue());  }  //System.out.println(idAttr.getName()+、+num+:+idAttr.getValue());    for(IteratorElementiteraInner=secondNode.elementIterator();iteraInner.hasNext();){  //读取三级节点  ElementthirdNode=iteraInner.next();  //System.out.println(thirdNode.getText());  hm.put(thirdNode.getName()+:+num,thirdNode.getText());  }  //System.out.println(-----------------------------------------);  }  }catch(DocumentExceptione){  //TODOAuto-generatedcatchblock  e.printStackTrace();  }    }    }35--------------------------------------------姓名 年龄 性别 电话孙悟空 26 男 15989562589 牛魔王 28 男 13956892578 猪悟能 27 男 13856230589 嫦娥 22 女 18956877852 铁扇公主 23 女 15802563215 白骨精 23 女 13756983698 女儿国王 21 女 18256892306'>j解析xml</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>18</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/A51D3633-7EFD-48AE-BD2A-8CCE78D5A649.html' title='本文列举了是十个免费工具，可以用来进行Web的负载/压力测试的。这样你就可以知道你的服务器以及你的WEB应用能够扛得住多少的并发量，以及网站性能。0.Grinder– Grinder是一个开源的JVM负载测试框架，它通过很多负载注射器来为分布式测试提供了便利。 支持用于执行测试脚本的Jython脚本引擎HTTP测试可通过HTTP代理进行管理。根据项目网站的说法，Grinder的 主要目标用户是“理解他们所测代码的人——Grinder不仅仅是带有一组相关响应时间的‘黑盒’测试。由于测试过程可以进行编码——而不是简单地脚本 化，所以程序员能测试应用中内部的各个层次，而不仅仅是通过用户界面测试响应时间。1.Pylot-Pylot 是一款开源的测试web service性能和扩展性的工具，它运行HTTP 负载测试，这对容量计划，确定基准点，分析以及系统调优都很有用处。Pylot产生并发负载（HTTP Requests），检验服务器响应，以及产生带有metrics的报表。通过GUI或者shell/console来执行和监视test suites。2.Web Capacity Analysis Tool (WCAT)– 这是一种轻量级负载生成实用工具，不仅能够重现对 Web 服务器（或负载平衡服务器场）的脚本 HTTP 请求，同时还可以收集性能统计数据供日后分析之用。WCAT 是多线程应用程序，并且支持从单个源控制多个负载测试客户端，因此您可以模拟数千个并发用户。该实用工具利用您的旧机器作为测试客户端，其中每个测试客户 端又可以产生多个虚拟客户端（最大数量取决于客户端机器的网络适配器和其他硬件）。您可以选择使用 HTTP 1.0 还是 HTTP 1.1 请求，以及是否使用 SSL。并且，如果测试方案需要，您还可以使用脚本执行的基本或 NTLM 身份验证来访问站点的受限部分。（如果您的站点使用 cookie、表单或基于会话的身份验证，那您可以创建正确的 GET 或 POST 请求来对测试用户进行身份验证。）WCAT 还可管理您站点可能设置的任何 cookie，所以配置文件和会话信息将永久保存。3.fwptt– fwptt 也是一个用来进行WEB应用负载测试的工具。它可以记录一般的请求，也可以记录Ajax请求。它可以用来测试asp.net， jsp， php 或是其它的Web应用。4.JCrawler– JCrawler是一个开源(CPL) 的WEB应用压力测试工具。通过其名字，你就可以知道这是一个用Java写的像网页爬虫一样的工具。只要你给其几个URL，它就可以开始爬过去了，它用一 种特殊的方式来产生你WEB应用的负载。这个工具可以用来测试搜索引擎对你站点产生的负载。当然，其还有另一功能，你可以建立你的网站地图和再点击一下， 将自动提交Sitemap给前5名的搜索引擎！5.Apache JMeter– Apache JMeter是一个专门为运行和服务器装载测试而设计的、100％的纯Java桌面运行程序。原先它是为Web/HTTP测试而设计的，但是它已经扩展以 支持各种各样的测试模块。它和用于HTTP和SQL数据库（使用JDBC）的模块一起运送。它可以用来测试静止资料库或者活动资料库中的服务器的运行情 况，可以用来模拟对服务器或者网络系统加以重负荷以测试它的抵抗力，或者用来分析不同负荷类型下的所有运行情况。它也提供了一个可替换的界面用来定制数据 显示，测试同步及测试的创建和执行。6.Siege-Siege（英文意思是围攻）是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每 个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。Siege 支持基本的认证，cookies， HTTP 和 HTTPS 协议。7.http_load– http_load 以并行复用的方式运行，用以测试web服务器的吞吐量与负载。但是它不同于大多数压力测试工具，它可以以一个单一的进程运行，一般不会把客户机搞死。可以可以测试HTTPS类的网站请求。8.Web Polygraph– Web Polygraph这个软件也是一个用于测试WEB性能的工具，这个工具是很多公司的标准测试工具，包括微软在分析其软件性能的时候，也是使用这个工具做为基准工具的。很多招聘测试员的广告中都注明需要熟练掌握这个测试工具。9.OpenSTA– OpenSTA是一个免费的、开放源代码的web性能测试工具，能录制功能非常强大的脚本过程，执行性能测试。例如虚拟多个不同的用户同时登陆被测试网 站。其还能对录制的测试脚本进行,按指定的语法进行编辑。在录制完测试脚本后，可以对测试脚本进行编辑，以便进行特定的性能指标分析。其较为丰富的图形化 测试结果大大提高了测试报告的可阅读性。OpenSTA基于CORBA的结构体系，它通过虚拟一个proxy，使用其专用的脚本控制语言，记录通过 proxy的一切HTTP/S traffic。通过分析OpenSTA的性能指标收集器收集的各项性能指标，以及HTTP数据，对系统的性能进行分析。欢迎您留下你认为不错的WEB应用性能测试的工具。　　前两天在一群里看见有人推荐一个app叫问啊，就可以发题答题那种的，感觉就跟uber滴滴打车似的，一般这种软件一上来就砸钱给红包啥的，哥之前刷过uber的单有经验！试验了几次应该可以刷，把注册红包和之前领的红包钱套现，目前我提了五十多，目测还能刷更多。ps，但是尽量要问技术相关的问题，不然容易被封。　　有技术的可以自己试，不会的可以q我：QQ群290551701 聚集很多互联网精英，技术总监，架构师，项目经理！开源技术研究，欢迎业内人士，大牛及新手有志于从事IT行业人员进入！'>十个免费的 Web 压力测试工具</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>19</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/6170518B-31ED-448A-9E6B-C24F881E5CB8.html' title='1. 简介  在上一篇介绍Java GC - 垃圾回收机制，本文将介绍如何监控 Javc GC 行为，同时涉及一些GUI工具的使用(虽然有些已经很老并不再更新)，监控GC在于判断JVM是否在良好高效地工作并且是否需要投入性能调优(主要包括应用程序优化与JVM参数优化)，关注的数据大概有：  1. Mirror GC频率、持续时间以及回收内存量。  2. Major GC频率、持续时间、回收内存量以及 stop-the-world 耗时。  3. Heap 对象分配(导出.hprof文件分析，通常比较大)2. GC LOG 及Collector行为分析  LOG分析包含前面文章所介绍的各个GC collector的行为分析。通过加入-XX:+PrintGCDetails 参数则可以打印详细GC信息至控制台。参数-verbose:gc也是可以，但不够详细。通过加入-XX:+PrintGCDateStamps则可以记录GC发生的详细时间。通过加入-Xloggc:/home/XX/gc/app_gc.log 可以把GC输出至文件，这对长时间服务器GC监控很有帮助。以下列出一些参数大致打印的信息如下：1.-verbose:gc：[GC 72104K-9650K(317952K), 0.0130635 secs]2.-XX:+PrintGCDetails:[GC [PSYoungGen: 142826K-10751K(274944K)] 162800K-54759K(450048K), 0.0609952 secs] [Times: user=0.13 sys=0.02, real=0.06 secs]3.-XX:+PrintGCDetails 加上-XX:+PrintGCDateStamps 参数则打印如下：2015-12-06T12:32:02.890+0800: [GC [PSYoungGen: 142833K-10728K(142848K)] 166113K-59145K(317952K), 0.0792023 secs] [Times: user=0.22 sys=0.00, real=0.08 secs]可以看出，如果是想监控详细信息与GC发生时间，加上-XX:+PrintGCDateStamps -XX:+PrintGCDetails 参数会是一个比较好的选择。首先来说明一段在各个GC中通用的字段含义说明：1、142826K-10751K(274944K) 分别代表回收前、回收后以及总内存大小。2、Times: user=0.46 sys=0.05, real=0.07 secs： user代表GC 需要的各个CPU总时间(各个CPU时间相加)，sys代表回收器自身的行为所占用CPU时间，real则代表本次GC所耗费的真正耗时(在多核CPU中并行回收，它通常小于user) 。2.1 Serial GC (-XX:+UseSerialGC)下面是一段的Serial GC日志含义依次分解：---------------------------[GC[DefNew: 78656K-8704K(78656K), 0.0487492 secs] 135584K-80553K(253440K), 0.0488309 secs] [Times: user=0.05 sys=0.00, real=0.05 secs][Full GC[Tenured: 62546K-60809K(174784K), 0.1600120 secs] 85931K-60809K(253440K), [Perm : 38404K-38404K(65536K)], 0.1600814 secs] [Times: user=0.16 sys=0.00, real=0.16 secs]---------------------------1. 其中的DefNew代表单线程回收yong generation。2. 紧跟后面的78656K-8704K(78656K)中的78656K代表young generation 回收前大小，8704K代表回收后大小，括号中的78656K代表young generation总大小(包含2个survivor)。3.135584K-80553K(253440K) 则代表整个Heap(young+old)的变化与总量，含义参照前面所述(Perm也一样)。4. Full GC 即代表 major GC,Tenured: 62546K-60809K(174784K)则表示 old generation变化及总量2.2 Parallel GC  Paralle GC 通过加入参数-XX:+UseParallelGC 来指定(很多服务器默认不需?诱獠问湍鲜褂酶肎C collector -- 通过判断配置来决定)，通过再加入-XX:+UseParallelOldGC 使得 Full GC也启用并行，但在(http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html)有如下介绍：-XX:-UseParallelGC：Use parallel garbage collection for scavenges. (Introduced in 1.4.1)-XX:-UseParallelOldGC：Use parallel garbage collection for the full collections. Enabling this option automatically sets -XX:+UseParallelGC. (Introduced in 5.0 update 6.)如想详细查询是否真正自动启用(还是不加入-XX:+UseParallelOldGC有什么细微区别) 则可查看 Open JDK 参考实现来确定，本文不做详细分析，所以加上-XX:+UseParallelGC -XX:+UseParallelOldGC 会是个保险的选择。下面附上一段Open JDK 7的路径为：hotspot/src/share/vm/runtime/arguments.cpp 部分源码，估计会有些帮助:void Arguments::set_parallel_gc_flags() {　　assert(UseParallelGC || UseParallelOldGC, Error);　　// If parallel old was requested, automatically enable parallel scavenge.　　if (UseParallelOldGC  !UseParallelGC  FLAG_IS_DEFAULT(UseParallelGC)) {　　　　FLAG_SET_DEFAULT(UseParallelGC, true);　　}　　// If no heap maximum was requested explicitly, use some reasonable fraction　　// of the physical memory, up to a maximum of 1GB.　　if (UseParallelGC) {　　　　FLAG_SET_ERGO(uintx, ParallelGCThreads,　　　　Abstract_VM_Version::parallel_worker_threads());　　　　// If InitialSurvivorRatio or MinSurvivorRatio were not specified, but the　　　　// SurvivorRatio has been set, reset their default values to SurvivorRatio +　　　　// 2. By doing this we make SurvivorRatio also work for Parallel Scavenger.　　　　// See CR 6362902 for details.　　　　if (!FLAG_IS_DEFAULT(SurvivorRatio)) {　　　　　　if (FLAG_IS_DEFAULT(InitialSurvivorRatio)) {　　　　　　　　FLAG_SET_DEFAULT(InitialSurvivorRatio, SurvivorRatio + 2);　　　　　　}　　　　　　if (FLAG_IS_DEFAULT(MinSurvivorRatio)) {　　　　　　　　FLAG_SET_DEFAULT(MinSurvivorRatio, SurvivorRatio + 2);　　　　　　}　　　　}　　　　if (UseParallelOldGC) {　　　　　　// Par compact uses lower default values since they are treated as　　　　　　// minimums. These are different defaults because of the different　　　　　　// interpretation and are not ergonomically set.　　　　　　if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {　　　　　　　　FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);　　　　　　}　　　　　　if (FLAG_IS_DEFAULT(PermMarkSweepDeadRatio)) {　　　　　　　　FLAG_SET_DEFAULT(PermMarkSweepDeadRatio, 5);　　　　　　}　　　　}　　}　　if (UseNUMA) {　　　　if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {　　　　　　FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);　　　　}　　}}--------------------------[GC [PSYoungGen: 88524K-10728K(274944K)] 133505K-61187K(450048K), 0.0374438 secs] [Times: user=0.08 sys=0.00, real=0.04 secs][Full GC [PSYoungGen: 10728K-0K(274944K)] [ParOldGen: 50459K-50210K(175104K)] 61187K-50210K(450048K) [PSPermGen: 38656K-38643K(77312K)], 0.3787131 secs] [Times: user=0.98 sys=0.02, real=0.38 secs]--------------------------1.PSYoungGen 代表并行回收 young generation2. ParOldGen 代表并行回收 old generation.3.PSPermGen 代表并行回收 Permanentgeneration. 其他的参数与前面解释的类似。2.3 CMS GC  CMS GC相对来说比较复杂，通过使用-XX:+UseConcMarkSweepGC 参数在指定，但是一般情况需要更多的其他参数来保证它能比较好地达到我们的低延时目的，下面就部分常用参数做介绍：-XX:+CMSIncrementalMode   采用增量式的标记方式，减少标记时应用停顿时间-XX:+CMSParallelRemarkEnabled   启用并行标记-XX:CMSInitiatingOccupancyFraction=70   Old generation消耗比例达到多少时进行回收，通常配置60-80之间-XX:CMSFullGCsBeforeCompaction=1   多少次Full GC 后压缩old generation一次-XX:+UseCMSInitiatingOccupancyOnly -XX:+ScavengeBeforeFullGC       Old generation GC前对young generation GC一次，默认开启。-XX:+CMSScavengeBeforeRemark   CMS remark之前进行一次young generation GC关于CMSFullGCsBeforeCompaction 的参数影响在Open JDK中如下判断：*should_compact =UseCMSCompactAtFullCollection ((_full_gcs_since_conc_gc = CMSFullGCsBeforeCompaction) ||GCCause::is_user_requested_gc(gch-gc_cause()) ||gch-incremental_collection_will_fail(true /* consult_young */));关于UseCMSInitiatingOccupancyOnly 参数的详细解释如下:-XX:+UseCMSInitiatingOccupancyOnly instructs the HotSpot VM to always usethe -XX:CMSInitiatingOccupancyFraction as the occupancy of the old generationspace to initiate a CMS cycle.If -XX:+UseCMSInitiatingOccupancyOnlyis not used, the HotSpot VM uses the -XX:CMSInitiatingOccupancyFractionas the occupancy percentage to start only the first CMS cycle. It then attempts toadaptively adjust when to start the CMS cycle for subsequent CMS cycles, that is,it no longer uses the specified -XX:CMSInitiatingOccupancyFraction after thefirst CMS cycle下面为一个可参考的CMS GC配置，根据应用的不同用途做相应修改(下面打印了GC LOG)：------------------------------------------------------JAVA_OPTS=-DappName=XXX-server-Xms10g -Xmx10g-XX:NewSize=4g -XX:MaxNewSize=4g-XX:PermSize=256m -XX:MaxPermSize=256m-XX:+UseConcMarkSweepGC-XX:+CMSIncrementalMode -XX:+CMSParallelRemarkEnabled-XX:CMSInitiatingOccupancyFraction=70 -XX:CMSFullGCsBeforeCompaction=1-XX:+UseCMSInitiatingOccupancyOnly-XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark-XX:+PrintGCDateStamps -verbose:gc -XX:+PrintGCDetails -Xloggc:/home/XX/gc/XX_gc.log-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=10M-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/XX/dump_OOME.hprof-XX:+DisableExplicitGC-----------------------------------------------------下面使用一段LOG 作为 CMS GC行为：--------------------------------[GC [ParNew: 5033216K-629120K(5662336K), 19.9680140 secs] 5033216K-2091720K(11953792K), 19.9682480 secs] [Times: user=119.82 sys=14.07, real=19.97 secs][GC [1 CMS-initial-mark: 1462600K(6291456K)] 4404491K(11953792K), 3.6824630 secs] [Times: user=3.67 sys=0.01, real=3.69 secs][CMS-concurrent-mark-start][[ParNew: 5662336K-629120K(5662336K), 6.8885140 secs] 7124936K-4366353K(11953792K), 6.8886670 secs] [Times: user=136.94 sys=0.92, real=6.89 secs][CMS-concurrent-mark: 2.053/75.039 secs] [Times: user=192.12 sys=3.19, real=75.04 secs][CMS-concurrent-preclean-start][CMS-concurrent-preclean: 6.159/6.274 secs] [Times: user=7.53 sys=0.30, real=6.28 secs][CMS-concurrent-abortable-preclean-start][CMS-concurrent-abortable-preclean: 10.680/10.681 secs] [Times: user=12.77 sys=0.43, real=10.68 secs][GC[YG occupancy: 3043648 K (5662336 K)] [GC [ParNew: 3043648K-629120K(5662336K), 1.5345480 secs] 6780882K-4985422K(11953792K), 1.5346490 secs] [Times: user=30.72 sys=0.27, real=1.53 secs][Rescan (parallel) , 0.1900960 secs] [weak refs processing, 0.0000460 secs] [scrub string table, 0.0008680 secs] [1 CMS-remark: 4356302K(6291456K)] 4985422K(11953792K), 1.7259240 secs] [Times: user=34.88 sys=0.27, real=1.72 secs][CMS-concurrent-sweep-start][CMS-concurrent-sweep: 3.379/3.380 secs] [Times: user=4.05 sys=0.13, real=3.38 secs][CMS-concurrent-reset-start][CMS-concurrent-reset: 0.030/0.030 secs] [Times: user=0.02 sys=0.01, real=0.03 secs]---------------------------------默认情况下Full GC之前会进行一次 Mirror GC，日志中的第一行则是，含义和前面的描述一样，不再赘述。其他的则是CMS GC 的各个周期(在前一篇文章中有描述)，其中只在 CMS-remark阶段应用暂停时间最长，但相对Parallel GC来说它相对会短些。3. GC监控工具  GC 监控工具有JDK自带的工具和第三方分析工具，同时包含命令行与GUI工具附：jstack命令可以查询当前应用线程状态，可用于判断是否存在死锁、线程等待原因等问题。3.1 jmap  jmap 有几项参数，直接执行jmap命令可打印这些选项，下面列出 -heap 参数打印情况(关键点粗体字标出)：--------------------------------Server compilerdetected.JVM version is 24.79-b02using parallel threads in the new generation.using thread-local object allocation.Concurrent Mark-Sweep GCHeap Configuration:MinHeapFreeRatio= 40MaxHeapFreeRatio= 70MaxHeapSize= 2147483648 (2048.0MB)NewSize= 1310720 (1.25MB)MaxNewSize= 348913664 (332.75MB)OldSize= 5439488 (5.1875MB)NewRatio= 2SurvivorRatio= 8PermSize= 67108864 (64.0MB)MaxPermSize= 268435456 (256.0MB)G1HeapRegionSize = 0 (0.0MB)Heap Usage:New Generation (Eden + 1 Survivor Space):capacity = 80543744 (76.8125MB)used = 13761040 (13.123550415039062MB)free = 66782704 (63.68894958496094MB)17.08517547930228% usedEden Space:capacity = 71630848 (68.3125MB)used = 4848144 (4.6235504150390625MB)free = 66782704 (63.68894958496094MB)6.768234825308783% usedFrom Space:capacity = 8912896 (8.5MB)used = 8912896 (8.5MB)free = 0 (0.0MB)100.0% usedTo Space:capacity = 8912896 (8.5MB)used = 0 (0.0MB)free = 8912896 (8.5MB)0.0% usedconcurrent mark-sweep generation:capacity = 178978816 (170.6875MB)used = 54910688 (52.366912841796875MB)free = 124068128 (118.32058715820312MB)30.679992876922373% usedPerm Generation:capacity = 67108864 (64.0MB)used = 37996544 (36.236328125MB)free = 29112320 (27.763671875MB)56.6192626953125% used17968 interned Stringsoccupying 2174744 bytes.--------------------------------下面dump一份heap分配情况：jmap -dump:format=b,file=d:/test.hprof 7880其中 7880为 PID，导出的文件可使用Memory Analyzer, jvisualvm, jprofile等工具打开3.2 jhat  如果你导出的 hprof 文件很大不方便下载本地分析，可以使用 jhat 启动HTTP Server的后可以使用浏览器访问,例如：执行jhatd:/test.hprof 后开启 7000 端口提供HTTP服务，使用浏览器即可访问:---------------------------Snapshot read, resolving...Resolving 2049558 objects...Chasing references, expect 409 dots...................................Eliminating duplicate references......................................Snapshot resolved.Started HTTP server on port 7000Server is ready.---------------------------注：如果导出的文件很大，则需要开启更多的内存空间，使用 -J-Xmx5g 命令则开启最大5G。3.3 jstat (jstatd)  jvisualvm  jstat用于实时监测 GC情况，如PID为7880的应用监测，每 1000毫秒打印一次：---------------------------jstat -gc 7880 1000S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT8704.0 8704.0 8704.0 0.0 69952.0 14761.0 277100.0 181950.8 65536.0 37705.5 60 2.946 35 1.285 4.2318704.0 8704.0 8704.0 0.0 69952.0 14763.0 277100.0 181950.8 65536.0 37705.5 60 2.946 35 1.285 4.231---------------------------如果开启 jstatd 则可远程使用 jvisualvm 的图形化监控.1.首先需要配置一个policy文件，内容如下( 假设名称为 tools.policy，根据安装路径不一进行相应修改 )：grant codebase file:/usr/java/jdk1.7.0_79/lib/tools.jar {permission java.security.AllPermission;};2.然后启动jstatd服务，后面的IP地址为该服务绑定的地址：jstatd -J-Djava.security.policy=/home/XXX/tools.policy -J-Djava.rmi.server.hostname=192.168.X.X3.在jvisualvm中添加 Remote，输入IP新建主机后右键添加 jstatd connection，稍等片刻即可连接，如下图：注：需要在 TOOLS-PLUGINs 中安装一些插件，如visual GC等才能查看一些更好的信息，如下图：4. jconsole  jps  jconsole大部分功能在jvisualvm中存在，所以使用的概率相对较小。jps 则是打印目前主机中正在启动的JAVA应用的PID。<p style="margin: 10px auto; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 25.2px; white-space: normal; background-color: rgb(255,'>Java GC - 监控回收行为与日志分析</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>20</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/89E38D59-AFD5-4A73-B3C8-CC91F08A907E.html' title='学习过java的都知道，在java中，不是直观的表示负数，而是采用补码的形式表示负数。这是为了硬件操作的方便，把减法也转换成加法来运算。那补码是怎样表示的呢？为了得到补码，我们引入了反码。对于正数来讲，它的反码补码都为本身，如果不明白为什么，我们可以这样理解：引入反码补码的原因就是为了解决减法的问题，换句话数就是解决java中负数的问题，正数不存在这些问题，所以它的反码补码就是它本身。在有符号的基本数据类型中，最高位0表示正数，最高位1表示负数。 对于负数来讲，它的反码就是除去符号位取反，然后加1就得到了它的补码。这里举个简单的例子，一个byte型数据，它在计算机中占8位，-7可以表示为10000111，最高位的1代表负号，它的反码是除去符号位各位取反为11111000，然后加1得到补码11111001。8的二进制表示为00001000，现在我们运算8 - 7，在计算机并不是用8减去7，而是用8 + (-7)，也就是用00001000加上-7的补码11111001，两个有符号数相加，如果符号位相加有近位就删去符号位的进位，得到00000001，也就是1.java中我们经常也会遇到不同数据类型的转换，这是最容易出错的地方。首先我们了解一下什么是符号扩展，对于正数来讲，在前面补0； 负数时在前面补1。比如8位的二进制数10000111扩展为16位，我们在前面加上8个1，1111111110000111；如果是正数，则在前面补0。这样进行扩展后，符号和数值的大小都不变。接下来我们我们看一下不同类型之间是怎样转换的，首先我们要知道这些基本类型各自占几位。 有符号型： byte = 8  int = 32  short = 16 long = 64  float = 32  double = 64  *boolean 只占一位，用0和1代表false和true。无符号型： char = 161. byte型转为char型 因为byte是有符号类型，再转成char型时需要进行符号位扩展，如果是正数就在前面不上8个0， 如果是负数就在前面补上8个1。例如11111111（0xff）左边连续补上8个1结果是0xffff。因为char是无符号类型，所以0xffff表示的十进制数是65535。2. char型转为int型 因为char是无符号类型，转换成int型时进行在前面补上16个0，用十进制表示结果为结果0x0000ffff,对应的十进制数是65535。3. int型转为byte型 因为int是32位，而byte类型值只占8位，直接截取最后8位。例如-1的补码为0xffffffff，转换为byte型后为0xff，值为-1。总结：如果最初的数值类型是有符号的，那么就执行符号扩展；如果是char类型，那么不管它要被转换成什么类型，都执行零扩展。还有另外一条规则也需要记住，如果目标类型的长度小于源类型的长度，则直接截取目标类型的长度。例如将int型转换成byte型，直接截取int型的右边8位'>Java中负数以及类型转换问题</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li>
                        </ul>
                        <br /><hr />
                    </div>
                </div>
                <div id="footerInnerSeparator"></div>
            </div>
        </div>
        <div id="footerOuterSeparator"></div>
    </div>
    <br /><br /><br />
    <script src="../../js/jquery-1.9.1.js"></script>
</body>
</html>