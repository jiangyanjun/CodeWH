<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="Language" content="zh-CN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../images/kebue.ico">
    <link rel="icon" href="../../images/kebue.ico">
    <meta name="description" content=Oracle>
    <meta name="keywords" content=Oracle>
    <title>Oracle</title>

    <link href="../../template/scripts/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="../../template/styles/custom.css" rel="stylesheet" />

</head>
<body id="pageBody">
    <div id="divBoxed" class="container">
        <div class="transparent-bg" style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;z-index: -1;zoom: 1;"></div>
        <div class="divPanel notop nobottom">
            <div class="row-fluid">
                <div class="span12">
                    <div id="divLogo">
                        <a href="../../../Home/Index" id="divSiteTitle">科布尔 kebue</a><br />
                        <a href="../../../Home/Index" id="divTagLine">开发者用代码改变世界从科布尔开始</a>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="divMenuRight" class="pull-right">
                        <div class="navbar">
                            <button type="button" class="btn btn-navbar-highlight btn-large btn-primary" data-toggle="collapse" data-target=".nav-collapse">
                                NAVIGATION <span class="icon-chevron-down icon-white"></span>
                            </button>
                            <div class="nav-collapse collapse">
                                <ul class="nav nav-pills ddmenu">
                                    <li class="dropdown glyphicon glyphicon-arrow-left"><a href='javascript:window.history.back()'>后退</a></li>
                                    <li class="dropdown active"><a href="http://www.kebue.com/">Home</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="contentInnerSeparator"></div>
                </div>
            </div>
        </div>
        <div class="contentArea">
            <div class="divPanel notop page-content">
                <div class="breadcrumbs">
                    <a href="../../../Home/Index">Home</a> &nbsp;/&nbsp; <span>Oracle</span>
                </div><br /><hr />
                <div class="row-fluid">
                    <div class="span12" id="Article-type">
                        <ul>
                            <li><span>1</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/065F44FF-B25F-411E-B1E5-0FF813498A73.html' title='Oracle创建用户设置权限（转：http://www.cnblogs.com/yangy608/archive/2011/08/22/2148893.html）create user TEST identified by TEST --创建TEST用户default tablespace USERStemporary tablespace TEMPprofile DEFAULT;grant connect,create view ,resource to TEST;grant unlimited tablespace to TEST;--管理员授权　　grant create session to TEST;--授予TEST用户创建session的权限，即登陆权限　　grant unlimited session to TEST;--授予TEST用户使用表空间的权限　　grant create table to TEST;--授予创建表的权限　　grant drop table to TEST;--授予删除表的权限　　grant insert table to TEST;--插入表的权限　　grant update table to TEST;--修改表的权限　　grant all to public;--这条比较重要，授予所有权限(all)给所有用户(public)--oralce对权限管理比较严谨，普通用户之间也是默认不能互相访问的　　grant select on tablename to TEST;--授予TEST用户查看指定表的权限　　grant drop on tablename to TEST;--授予删除表的权限　　grant insert on tablename to TEST;--授予插入的权限　　grant update on tablename to TEST;--授予修改表的权限　　grant insert(id) on tablename to TEST;　　grant update(id) on tablename to TEST;--授予对指定表特定字段的插入和修改权限，注意，只能是insert和update--撤销权限　　基本语法同grant,关键字为revoke--查看权限　　select * from user_sys_privs;--查看当前用户所有权限　　select * from user_tab_privs;--查看所用用户对表的权限--操作表的用户的表　　/*需要在表名前加上用户名，如下*/--权限传递　 即用户A将权限授予B，B可以将操作的权限再授予C，命令如下：　　grant alert table on tablename to TEST with admin option;--关键字 with admin option　　grant alert table on tablename to TEST with grant option;--关键字 with grant option效果和admin类似--角色　　角色即权限的集合，可以把一个角色授予给用户　　create role myrole;--创建角色　　grant create session to myrole;--将创建session的权限授予myrole　　grant myrole to TEST;--授予TEST用户myrole的角色　　drop role myrole;删除角色　　/*但是有些权限是不能授予给角色的，比如unlimited tablespace和any关键字*/'>Oracle创建用户设置权限</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>2</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/35D3C2DA-E272-4844-8BEA-EE2CBE5E5083.html' title='sql 连接操作 汇总连接条件可在FROM或WHERE子句中指定，建议在FROM子句中指定连接条件。WHERE和HAVING子句也可以包含搜索条件，以进一步筛选连接条件所选的行。 连接可分为以下几类：内连接。（典型的连接运算，使用像  =  或    之类的比较运算符）。包括相等连接和自然连接。 内连接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索  students  和  courses  表中学生标识号相同的所有行。外连接。外连接可以是左向外连接、右向外连接或完整外部??em style="background-color: inherit;">。 在FROM子句中指定外连接时，可以由下列几组关键字中的一组指定：LEFT  JOIN  或  LEFT  OUTER  JOIN。左向外连接的结果集包括LEFTOUTER子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。RIGHTJOIN或RIGHT  OUTER  JOIN。 右向外连接是左向外连接的反向连接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 FULL  JOIN  或  FULL  OUTER  JOIN。完整外部连接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 交叉连接。交叉连接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉连接也称作笛卡尔积。例如，下面的内连接检索与某个出版商居住在相同州和城市的作者：   USE  pubs  SELECT  a.au_fname,  a.au_lname,  p.pub_name  FROM  authors  AS  a  INNER  JOIN  publishers  AS  p     ON  a.city  =  p.city     AND  a.state  =  p.state  ORDER  BY  a.au_lname  ASC,  a.au_fname  ASC FROM  子句中的表或视图可通过内连接或完整外部连接按任意顺序指定；但是，用左或右向外连接指定表或视图时，表或视图的顺序很重要。有关使用左或右向外连接排列表的更多信息，请参见使用外连接。例子：  a表   id  name   b表   id  job  parent_id        1  张3          1   23   1        2  李四  2   34   2        3  王武         3   34   4   a.id同parent_id  存在关系内连接 select  a.*,b.*  from  a  inner  join  b   on  a.id=b.parent_id   结果是   1  张3          1   23   1  2 李四 2   34   2左连接 select  a.*,b.*  from  a  left  join  b   on  a.id=b.parent_id   结果是   1  张3          1   23   1  2  李四         2   34   2  3  王武         null右连接 select  a.*,b.*  from  a  right  join  b   on  a.id=b.parent_id   结果是   1  张3          1   23   1  2  李四         2   34   2  null         3   34   4完全连接 select  a.*,b.*  from  a  full  join  b   on  a.id=b.parent_id 结果是   1  张3          1   23   1  2  李四         2   34   2  null         3   34   4  3  王武         nullSQL codeDECLARE@TATABLE(IDAINT,VAVARCHAR(10))DECLARE@TBTABLE(IDBINT,VBVARCHAR(10))INSERTINTO@TASELECT1,AAUNIONSELECT2,BCUNIONSELECT3,CCCINSERTINTO@TBSELECT1,2UNIONSELECT3,58UNIONSELECT4,67--内联接简单写法SELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAA,@TBBWHEREA.IDA=B.IDB--内联接SELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAAINNERJOIN@TBBONA.IDA=B.IDBSELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAAJOIN@TBBONA.IDA=B.IDB--左外联接SELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAALEFTJOIN@TBBONA.IDA=B.IDBSELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAALEFTOUTERJOIN@TBBONA.IDA=B.IDB--右外联接SELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAARIGHTJOIN@TBBONA.IDA=B.IDBSELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAARIGHTOUTERJOIN@TBBONA.IDA=B.IDB--完整外联接SELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAAFULLJOIN@TBBONA.IDA=B.IDBSELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAAFULLOUTERJOIN@TBBONA.IDA=B.IDB--交叉联接SELECTA.IDA,A.VA,B.IDB,B.VBFROM@TAACROSSJOIN@TBB--自联接SELECTA.IDA,A.VA,B.IDA,B.VAFROM@TAA,@TABWHEREA.IDA=B.IDA+1查询分析器中执行：--建表table1,table2：createtabletable1(idint,namevarchar(10))createtabletable2(idint,scoreint)insertintotable1select1,leeinsertintotable1select2,zhanginsertintotable1select4,wanginsertintotable2select1,90insertintotable2select2,100insertintotable2select3,70如表-------------------------------------------------table1|table2|-------------------------------------------------idname|idscore|1lee|190|2zhang|2100|4wang|370|-------------------------------------------------以下均在查询分析器中执行  一、外连接1.概念：包括左向外联接、右向外联接或完整外部联接2.左连接：leftjoin或leftouterjoin(1)左向外联接的结果集包括LEFTOUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。  (2)sql语句select*fromtable1leftjointable2ontable1.id=table2.id-------------结果-------------idnameidscore------------------------------1lee190  2zhang2100  4wangNULLNULL------------------------------注释：包含table1的所有子句，根据指定条件返回table2相应的字段，不符合的以null显示3.右连接：rightjoin或rightouterjoin(1)右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。  (2)sql语句select*fromtable1rightjointable2ontable1.id=table2.id-------------结果-------------idnameidscore------------------------------1lee190  2zhang2100  NULLNULL370------------------------------注释：包含table2的所有子句，根据指定条件返回table1相应的字段，不符合的以null显示4.完整外部联接:fulljoin或fullouterjoin(1)完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。  (2)sql语句select*fromtable1fulljointable2ontable1.id=table2.id-------------结果-------------idnameidscore------------------------------1lee190  2zhang2100  4wangNULLNULL  NULLNULL370------------------------------注释：返回左右连接的和（见上左、右连接）  二、内连接1.概念：内联接是用比较运算符比较要联接列的值的联接2.内连接：join或innerjoin3.sql语句select*fromtable1jointable2ontable1.id=table2.id-------------结果-------------idnameidscore------------------------------1lee190  2zhang2100------------------------------注释：只返回符合条件的table1和table2的列4.等价（与下列执行效果相同）  A:selecta.*,b.*fromtable1a,table2bwherea.id=b.id  B:select*fromtable1crossjointable2wheretable1.id=table2.id(注：crossjoin后加条件只能用where,不能用on)  三、交叉连接(完全)1.概念：没有WHERE子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）2.交叉连接：crossjoin(不带条件where...)3.sql语句select*fromtable1crossjointable2-------------结果-------------idnameidscore------------------------------1lee190  2zhang190  4wang190  1lee2100  2zhang2100  4wang2100  1lee370  2zhang370  4wang370------------------------------注释：返回3*3=9条记录，即笛卡尔积4.等价（与下列执行效果相同）  A:select*fromtable1,table2'>sql 连接操作 汇总</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>3</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/B6146FAC-8CA4-4438-931A-D5A7461C032B.html' title='select * from SYS_CONFIGselect count(1) from SYS_CONFIG--查看表里数据select count(1) from SYS_CONFIG where tmp_col=TYPE--检查数据是否全部复制过来alter table SYS_CONFIG add(tmp_col VARCHAR2(1));--添加临时列update SYS_CONFIG set tmp_col = to_number(TYPE); --把数据复制到临时列上update SYS_CONFIG set TYPE = null; --此处要小心啊，原数据全没了，一定要保证上一步正确执行update SYS_CONFIG set TYPE = tmp_col;--在恢复到原来的列上面ALTER TABLE SYS_CONFIG MODIFY (TYPE VARCHAR2(1))---更改表类型'>Oracle  更改列类型需要清空  建立临时列</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>4</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/45F73817-E320-42B6-949A-9524281450E8.html' title=' SELECT  CASE CTYPE   WHEN 1 THEN 半成品   WHEN 2 THEN 成品   when 3 then 其他   when 0 then 原材料   ELSE 未知  end FROM BASE_PART GROUP BY CTYPE;select CTYPE,decode(CTYPE, 1, 成品, 2, 半成品, 3,原材料,0,其他)from  BASE_PART group by CTYPE;Oracle CASE WHEN 用法介绍1. CASE WHEN 表达式有两种形式  sex              sex  sex2. CASE WHEN 在语句中不同位置的用法2.1SELECTCASE WHEN 用法grade,(sex    )男生数,  (sex    )女生数  studentsgrade;2.3WHERECASE WHEN 用法T2.,T1.  T1,T2  (T2.COMPARE_TYPE  T1.SOME_TYPE    T2.COMPARE_TYPE  T1.SOME_TYPE      )2.4GROUP BYCASE WHEN 用法  salary  salarysalary  salarysalary  salarysalary  salary_class,()  Table_A    salary  salarysalary  salarysalary  salarysalary  ;3.关于IF-THEN-ELSE的其他实现3.1 DECODE() 函数decode(sex,,,,,)  employees;貌似只有Oracle提供该函数，而且不支持ANSI SQL，语法上也没CASE WHEN清晰，个人不推荐使用。3.2 在WHERE中特殊实现T2.,T1.  T1,T2  (T2.COMPARE_TYPET1.SOME_TYPE)    (T2.COMPARE_TYPET1.SOME_TYPE)'>Oracle CASE WHEN 用法介绍</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>5</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/AE399E08-E71D-4163-853E-80F2BFEE3CC4.html' title=':new.字段 是新值:old.字段 是旧值'>oracle insert触发器获取新插入的列值</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>6</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/9C9300BC-8168-4745-A587-B4FF71A3C47A.html' title='-- drop sequence seq_AutoInBillSn                 create sequence seq_AutoInBillSn minvalue 1000000maxvalue 9000000start with 1000000increment by 1cycle;     --SELECT to_char(systimestamp,YYMMDDHH24MIff3)||round (dbms_random.value(1,9999999),0) into T_SN FROM DUAL;   SELECT to_char(systimestamp,YYMMDDHH24MIff3)||seq_AutoInBillSn.Nextval into T_SN FROM DUAL; '>创建7位自增长序列</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>7</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/851FE90D-4282-4100-B2F1-D7D41BFC03D4.html' title='oracle使用dblink跨库查询的例子发表于10个月前(2014-11-07 14:12) 阅读（1161）|评论（0）0人收藏此文章,我要收藏赞09月19日成都 OSC 源创会正在报名，送机械键盘和开源无码内裤本文介绍了oracle数据库使用dblink进行跨库查询的方法，oracle dblink跨库查询教程，需要的朋友参考下。oracle dblink跨库查询方法一：首先，创建数据库链接:复制代码代码示例:CREATE PUBLIC DATABASE LINK 数据链名称 CONNECT TO 登陆用户名 IDENTIFIED BY 密码 USING (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 对方Oracle服务器的IP地址)(PORT = 端口号)) ) (CONNECT_DATA =(SERVICE_NAME = 对方Oracle服务器服务名) ))其中 数据链名称 为添加到本地Oracle数据库控制台(Oracle Enterprise Manager Console)树节点的服务名要查询对方数据库的表TableName语句如下:复制代码代码示例:SELECT 字段名 FROM TableName@数据链名称;方法二：在目前绝大部分数据库有分布式查询的需要。下面简单的介绍如何在oracle中配置实现跨库访问。比如现在有2个数据库服务器，安装了2个数据库。数据库server A和B。现在来实现在A库中访问B的数据库。第一步、配置A服务器端的tnsnames.ora文件（TNSNAMES.ORA Network Configuration File），该文件存放的位置为：$ORACLE_HOME/network/admin/tnsnames.ora需要在该文件中增加对B库的配置项，格式如下复制代码代码示例:ZBCDB3 =(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 10.1.50.6)(PORT = 1523)) ) (CONNECT_DATA = (SERVICE_NAME = zbcdb3) ))若在A库的另外一台客户端来访问B的数据库的话，同时也应该修改客户端的相应的文件。第二步、在A服务器的一个库中建立B的一个数据的DBLINK。语法如下：（www.jbxue.com脚本学堂）create database link dcmdb connect to dcmdb identified by dcmoptr using zbcdb3 ;然后可以实现分布式查询：select * from tabname@dcmdb where 1=1;（可以为tabname@dcmdb创建同义词）复制表数据：复制代码代码示例:insert into 表名（字段名） （SELECT 字段名 FROM TableName@数据链名称）;--------------------------------------------------------select * from user_db_links; --用户 DB Linkselect * from dba_db_links; --dba DB Linkselect * from v$dblink; --当前DB LinkDrop database link MYDBLINK1;如果是相同实例，不同用户，可以用如下方法查询：复制代码代码示例:select * from 用户名.表名以上就是oracle中使用dblink跨库查询的实例介绍，希望对大家有所帮助。'>oracle使用dblink跨库查询的例子</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>8</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/28DBA27B-42F6-4D9E-BDFC-E158283CEB6C.html' title='对于rownum来说它是oracle系统顺序分配为从查询返回的行的编号，返回的第一行分配的是1，第二行是2，依此类推，这个伪字段可以用于限制查询返回的总行数，且rownum不能以任何表的名称作为前缀。(1) rownum对于等于某值的查询条件如果希望找到学生表中第一条学生的信息，可以使用rownum=1作为条件。但是想找到学生表中第二条学生的信息，使用rownum=2结果查不到数据。因为rownum都是从1开始，但是1以上的自然数在rownum做等于判断是时认为都是false条件，所以无法查到rownum = n（n1的自然数）。SQL select rownum,id,name from student where rownum=1;（可以用在限制返回记录条数的地方，保证不出错，如：隐式游标）SQL select rownum,id,name from student where rownum =2; ROWNUM ID NAME---------- ------ ---------------------------------------------------（2）rownum对于大于某值的查询条件如果想找到从第二行记录以后的记录，当使用rownum2是查不出记录的，原因是由于rownum是一个总是从1开始的伪列，Oracle认为rownum n(n1的自然数)这种条件依旧不成立，所以查不到记录。查找到第二行以后的记录可使用以下的子查询方法来解决。注意子查询中的rownum必须要有别名，否则还是不会查出记录来，这是因为rownum不是某个表的列，如果不起别名的话，无法知道rownum是子查询的列还是主查询的列。SQLselect * from(select rownum no ,id,name from student) where no2; NO ID NAME---------- ------ --------------------------------------------------- 3 200003李三 4 200004赵四（3）rownum对于小于某值的查询条件rownum对于rownumn（(n1的自然数）的条件认为是成立的，所以可以找到记录。SQL select rownum,id,name from student where rownum 3; ROWNUM ID NAME---------- ------ --------------------------------------------------- 1 200001张一 2 200002王二查询rownum在某区间的数据，必须使用子查询。例如要查询rownum在第二行到第三行之间的数据，包括第二行和第三行数据，那么我们只能写以下语句，先让它返回小于等于三的记录行，然后在主查询中判断新的rownum的别名列大于等于二的记录行。但是这样的操作会在大数据集中影响速度。SQL select * from (selectrownum no,id,name from student where rownum=3 ) where no =2; NO ID NAME---------- ------ --------------------------------------------------- 2 200002王二 3 200003李三（4）rownum和排序Oracle中的rownum的是在取数据的时候产生的序号，所以想对指定排序的数据去指定的rowmun行数据就必须注意了。SQL select rownum ,id,name from student order by name; ROWNUM ID NAME---------- ------ --------------------------------------------------- 3 200003李三 2 200002王二 1 200001张一 4 200004赵四可以看出，rownum并不是按照name列来生成的序号。系统是按照记录插入时的顺序给记录排的号，rowid也是顺序分配的。为了解决这个问题，必须使用子查询；SQL select rownum ,id,name from (select * from student order by name); ROWNUM ID NAME---------- ------ --------------------------------------------------- 1 200003李三 2 200002王二 3 200001张一 4 200004赵四这样就成了按name排序，并且用rownum标出正确序号（有小到大）笔者在工作中有一上百万条记录的表，在jsp页面中需对该表进行分页显示，便考虑用rownum来作，下面是具体方法(每页显示20条)：“select * from tabname where rownum20 order by name但却发现oracle却不能按自己的意愿来执行，而是先随便取20条记录，然后再order by，后经咨询oracle,说rownum确实就这样，想用的话，只能用子查询来实现先排序，后rownum，方法如下：select * from (select * from tabname order by name) where rownum20,但这样一来，效率会低很多。后经笔者试验，只需在order by的字段上加主键或索引即可让oracle先按该字段排序，然后再rownum；方法不变： “select * from tabname where rownum20 order by name取得某列中第N大的行select column_name from(select table_name.*,dense_rank() over (order by column desc) rank from table_name)where rank = N；　假如要返回前5条记录：select * from tablename where rownum6;(或是rownum = 5或是rownum != 6)假如要返回第5-9条记录：select * from tablenamewhere …and rownum10minusselect * from tablenamewhere …and rownum5order by name选出结果后用name排序显示结果。(先选再排序)注意：只能用以上符号(、=、!=)。select * from tablename where rownum != 10;返回的是前９条记录。不能用：,=,=,Between...and。由于rownum是一个总是从1开始的伪列，Oracle认为这种条件不成立。另外，这个方法更快：select * from (select rownum r,a from yourtablewhere rownum = 20order by name)where r  10这样取出第11-20条记录!(先选再排序再选)要先排序再选则须用select嵌套：内层排序外层选。rownum是随着结果集生成的，一旦生成，就不会变化了；同时,生成的结果是依次递加的，没有1就永远不会有2!rownum是在查询集合产生的过?讨胁奈绷校⑶胰绻?span lang="EN-US" style="background-color: inherit;">where条件中存在rownum条件的话，则:1： 假如判定条件是常量，则：只能rownum = 1, =大于1的自然数，=大于1的数是没有结果的；大于一个数也是没有结果的即当出现一个rownum不满足条件的时候则查询结束this is stop key（一个不满足，系统将该记录过滤掉，则下一条记录的rownum还是这个，所以后面的就不再有满足记录，this is stop key）；2： 假如判定值不是常量，则：若条件是= var ,则只有当var为1的时候才满足条件，这个时候不存在stop key ,必须进行full scan ,对每个满足其他where条件的数据进行判定，选出一行后才能去选rownum=2的行……以下摘自《中国IT实验室》1.在ORACLE中实现SELECT TOP N由于ORACLE不支持SELECT TOP语句，所以在ORACLE中经常是用ORDER BY跟ROWNUM的组合来实现SELECT TOP N的查询。简单地说，实现方法如下所示：SELECT　列名１．．．列名ｎ　FROM (SELECT　列名１．．．列名ｎ　FROM表名ORDER BY列名１．．．列名ｎ) WHERE ROWNUM = N（抽出记录数）ORDER BY ROWNUM ASC下面举个例子简单说明一下。顾客表customer(id,name)有如下数据：ID NAME 01 first 02 Second 03 third 04 forth 05 fifth 06 sixth 07 seventh 08 eighth 09 ninth 10 tenth 11 last则按NAME的字母顺抽出前三个顾客的SQL语句如下所示：SELECT * FROM (SELECT * FROM CUSTOMER ORDER BY NAME) WHERE ROWNUM = 3 ORDER BY ROWNUM ASC输出结果为：ID NAME 08 eighth 05 fifth 01 first2.在TOP N纪录中抽出第M（M<span lang="EN-US" style="background-color: '>(Oracle)rownum用法详解</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>9</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/3A0C25D2-D6CB-4327-954D-B6E0EA37561B.html' title='select blocker(||lb.sid||:||sb.username||)-sql:|| qb.sql_text blockers,waiter (||lw.sid||:||sw.username||)-sql:|| qw.sql_text waitersfrom v$lock lb,v$lock lw,v$session sb,v$session sw,v$sql qb,v$sql qwwhere lb.sid=sb.sidand lw.sid=sw.sidand sb.prev_sql_addr=qb.addressand sw.sql_address=qw.addressand lb.id1=lw.id1and sw.lockwait is not nulland sb.lockwait is nulland lb.block=1 ;'>查询锁表SQL</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>10</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/2E75BFF2-4FE7-44C0-B96A-B5F8CE162417.html' title='CREATE OR REPLACE Function Fun_Get_Splitstr(P_Input   in varchar2, --拆分字符串                      P_Delimiter in varchar2, --拆分定义符                      P_BZ    in number --0 输入获取表 1 直接获取                      ) return str_split_m --返回数据表 pipelined as --管道函数 -------------------------------------------------------------------- --功能：根据拆分定义符拆分字符串 --创建时间：2015-1-9 15:45:58 --创建人： --表结构多个参数 /*--------------------------------------- --创建类型方法 create or replace type obj_table as object (  id    varchar2(50),  merge_erp varchar2(200),  erpcode  varchar2(50) ); create or replace type str_split_m is table of obj_table; --查询语句： P_BZ = 0 select * from table(Fun_Get_Splitstr(25468,24325,425234,456,5464,,,0)) t P_BZ = 1 select * from table(Fun_Get_Splitstr) t -----------------------------------------*/ -------------------------------------------------------------------- v_length number; v_start number; v_index number; P_String varchar2(200); --拆分字符串 -- P_Delimiter varchar2(200); --拆分定义符 v_obj_table obj_table;begin if (P_BZ = 0) then  --输入字符串，拆分定义符，获取数据表  if (1 = 1) then   P_String := P_Input;   v_length := length(P_String);   v_start := 1;   --当开始的位置小于等于长度   while (v_start = v_length) loop    --返回拆分定义符的位置    v_index := instr(P_String, P_Delimiter, v_start);    if v_index = 0 then     --返回集合的单个元素（截取开始位置之后的所有字符串）     v_obj_table := obj_table(null, null, substr(P_String, v_start));     pipe row(v_obj_table);     v_start := v_length + 1;    else     --返回集合的单个元素（截取开始位置之后的 固定长度（开始至）字符串）     v_obj_table := obj_table(null,                 null,                 substr(P_String,                     v_start,                     v_index - v_start));     pipe row(v_obj_table);     v_start := v_index + 1;    end if;   end loop;  end if; elsif (P_BZ = 1) then --获取合并超发回调单中的数据表  if (1 = 1) then   for ii in (select te.id, te.merge_erp         from allocate te         where te.special = 1          and te.is_merge = 1) loop    p_string := ii.merge_erp;    -- P_Delimiter := ,;    v_length := length(p_string);    v_start := 1;    --当开始的位置小于等于长度    while (v_start = v_length) loop     --返回拆分定义符的位置     v_index := instr(P_String, P_Delimiter, v_start);     if v_index = 0 then      --返回集合的单个元素（截取开始位置之后的所有字符??/p>      v_obj_table := obj_table(ii.id,                  ii.merge_erp,                  substr(P_String, v_start));      pipe row(v_obj_table);      v_start := v_length + 1;     else      --返回集合的单个元素（截取开始位置之后的 固定长度（开始至）字符串）      v_obj_table := obj_table(ii.id,                  ii.merge_erp,                  substr(P_String,                      v_start,                      v_index - v_start));      pipe row(v_obj_table);      v_start := v_index + 1;     end if;    end loop;   end loop;  end if; end if; return;end Fun_Get_Splitstr;'>Oracle返回Databale类型</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>11</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/8C5E4C48-E9ED-43B5-B867-F7E5EDE8B288.html' title='oracle中的2种临时表，会话级和事务级临时表的用法临时表分两种类型的临时表：1． 会话级临时表2． 事物级临时表临时表：顾明思义，存在该表的数据是临时的。会话临时表：该临时表肯定与会话有关。会话在不退出时，则些临时表中的数据存在，会话退出，该临时表中的数据也会随之消失。在多用户操作的情况下，一个会话从来不阻塞另一个会话使用临时表。即使锁定临时表，一个会话也不会阻塞其他会话使用临时表。其语法为：Create global temporary table table_name(col1 type1, col2 type2 …)On commit preserve rows;事务临时表：指该临时表与事务相关，当进行事务提交或者事务回滚的时候，临时表中的数据将自行被截断，其他的内容和会话级的临时表的一致（包括退出SESSION的时候，事务级的临时表也会被自动截断）。语法为：Create global temporary table table_name(col1 type1, col2 type2 …)On commit delete rows;'>oracle中的2种临时表，会话级和事务级临时表的用法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>12</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/1E18E7F9-8426-4D17-8C00-FE3B632B2F15.html' title='Oracle临时表说明实例说明：需要存储多个以上字段的集合数据，数据类型自定义。1、创建package，type类型的record和table。create or replace package PKG_SortTable istype TableData1 is record(position varchar2(60),qty number);type SortData is table of TableData1;end PKG_SortTable;2、引用，包名.type名srPKG_SortTable.SortData;3、赋值首先初始化：sr:= PKG_SortTable.SortData();赋值可直接进行索引赋值，或者通过for游标进行赋值sr(1).position=’DFD093’;sr(1).qty=200;'>Oracle 临时表变量声明调用</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>13</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/6A4D998B-7BA0-4227-909F-FEB2CB2824BE.html' title='SELECT t1 表空间,z 总表空间,z-s 已用表空间,s 剩余表空间,ROUND((z-s)/z*100,2) 使用率%   From （Select tablespace_name t1,Sum(bytes) s       From DBA_FREE_SPACE Group by tablespace_name),      (Select tablespace_name t2,Sum(bytes) z    From DBA_DATA_FILES Group by tablespace_name) Where t1=t2;         select username,default_tablespace from dba_users;   select a.tablespace_name,a.bytes/1024/1024 Sum MB,(a.bytes-b.bytes)/1024/1024 used MB,b.bytes/1024/1024 free MB,round(((a.bytes-b.bytes)/a.bytes)*100,2) percent_usedfrom(select tablespace_name,sum(bytes) bytes from dba_data_files group by tablespace_name) a,(select tablespace_name,sum(bytes) bytes,max(bytes) largest from dba_free_space group by tablespace_name) b--查询表空间使用情况SELECTUpper(F.TABLESPACE_NAME)表空间名,  D.TOT_GROOTTE_MB表空间大小(M),  D.TOT_GROOTTE_MB-F.TOTAL_BYTES已使用空间(M),  To_char(Round((D.TOT_GROOTTE_MB-F.TOTAL_BYTES)/D.TOT_GROOTTE_MB*100,2),990.99)||%使用比,  F.TOTAL_BYTES空闲空间(M),  F.MAX_BYTES最大块(M)FROM(SELECTTABLESPACE_NAME,Round(Sum(BYTES)/(1024*1024),2)TOTAL_BYTES,Round(Max(BYTES)/(1024*1024),2)MAX_BYTESFROMSYS.DBA_FREE_SPACEGROUPBYTABLESPACE_NAME)F,  (SELECTDD.TABLESPACE_NAME,Round(Sum(DD.BYTES)/(1024*1024),2)TOT_GROOTTE_MBFROMSYS.DBA_DATA_FILESDDGROUPBYDD.TABLESPACE_NAME)DWHERED.TABLESPACE_NAME=F.TABLESPACE_NAMEORDERBY1--查询表空间的freespaceselecttablespace_name,count(*)ASextends,round(sum(bytes)/1024/1024,2)ASMB,sum(blocks)ASblocksfromdba_free_spacegroupBYtablespace_name;--查询表空间的总容量selecttablespace_name,sum(bytes)/1024/1024asMBfromdba_data_filesgroupbytablespace_name;--查询表空间使用率SELECTtotal.tablespace_name,Round(total.MB,2)ASTotal_MB,Round(total.MB-free.MB,2)ASUsed_MB,Round((1-free.MB/total.MB)*100,2)||%ASUsed_PctFROM(SELECTtablespace_name,Sum(bytes)/1024/1024ASMBFROMdba_free_spaceGROUPBYtablespace_name)free,  (SELECTtablespace_name,Sum(bytes)/1024/1024ASMBFROMdba_data_filesGROUPBYtablespace_name)totalWHEREfree.tablespace_name=total.tablespace_name;上述语句查询结果如下图所示：参考2：SELECTa.tablespace_name表空间名,  total表空间大小,  free表空间剩余大小,  (total-free)表空间使用大小,Round((total-free)/total,4)*100使用率%FROM(SELECTtablespace_name,Sum(bytes)freeFROMDBA_FREE_SPACEGROUPBYtablespace_name)a,  (SELECTtablespace_name,Sum(bytes)totalFROMDBA_DATA_FILESGROUPBYtablespace_name)bWHEREa.tablespace_name=b.tablespace_name查询结果参考3SELECTTABLESPACE_NAME表空间,  To_char(Round(BYTES/1024,2),99990.00)||实有,  To_char(Round(FREE/1024,2),99990.00)||G现有,  To_char(Round((BYTES-FREE)/1024,2),99990.00)||G使用,  To_char(Round(10000*USED/BYTES)/100,99990.00)||%比例FROM(SELECTA.TABLESPACE_NAMETABLESPACE_NAME,Floor(A.BYTES/(1024*1024))BYTES,Floor(B.FREE/(1024*1024))FREE,Floor((A.BYTES-B.FREE)/(1024*1024))USEDFROM(SELECTTABLESPACE_NAMETABLESPACE_NAME,Sum(BYTES)BYTESFROMDBA_DATA_FILESGROUPBYTABLESPACE_NAME)A,  (SELECTTABLESPACE_NAMETABLESPACE_NAME,Sum(BYTES)FREEFROMDBA_FREE_SPACEGROUPBYTABLESPACE_NAME)BWHEREA.TABLESPACE_NAME=B.TABLESPACE_NAME)--WHERETABLESPACE_NAMELIKECDR%--这一句用于指定表空间名称ORDERBYFloor(10000*USED/BYTES)DESC;查询结果selecttablespace_name,  max_gb,  used_gb,round(100*used_gb/max_gb)pct_usedfrom(selecta.tablespace_nametablespace_name,round((a.bytes_alloc-nvl(b.bytes_free,0))/power(2,30),2)used_gb,round(a.maxbytes/power(2,30),2)max_gbfrom(selectf.tablespace_name,sum(f.bytes)bytes_alloc,sum(decode(f.autoextensible,YES,  f.maxbytes,NO,  f.bytes))maxbytesfromdba_data_filesfgroupbytablespace_name)a,  (selectf.tablespace_name,sum(f.bytes)bytes_freefromdba_free_spacefgroupbytablespace_name)bwherea.tablespace_name=b.tablespace_name(+)unionallselecth.tablespace_nametablespace_name,round(sum(nvl(p.bytes_used,0))/power(2,30),2)used_gb,round(sum(decode(f.autoextensible,YES,  f.maxbytes,NO,  f.bytes))/power(2,30),2)max_gbfromv$temp_space_headerh,v$temp_extent_poolp,dba_temp_filesfwherep.file_id(+)=h.file_idandp.tablespace_name(+)=h.tablespace_nameandf.file_id=h.file_idandf.tablespace_name=h.tablespace_namegroupbyh.tablespace_name)orderby4;'>Oracle 查询表空间</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>14</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/850DBCA3-39CE-45E2-B1B7-0090B61A745D.html' title='sql查询重复记录的方法发表于6天前(2015-08-21 11:40) 阅读（33）|评论（0）10人收藏此文章,我要收藏赞0sql1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断select*frompeoplewherepeopleIdin(selectpeopleIdfrompeoplegroupbypeopleIdhavingcount(peopleId)1)2、查找表中多个字段的重复记录select*fromvitaeawhere(a.peopleId,a.seq)in(selectpeopleId,seqfromvitaegroupbypeopleId,seqhavingcount(*)1)3、查某一列(或多列)的重复值(只可以查出重复记录的值，不能查出整个记录的信息)查找stuid，stuname重复的记录selectstuid，stunamefromstuinfogroupbystuid，stunamehaving(count(*))1'>sql查询重复记录的方法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>15</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/1FA0A34A-98F6-4468-9EE0-029BE0BCED43.html' title='oracle 表误更新 （flashback ）闪回操作--oracle 表误更新 闪回操作 测试环境--select * from v$database;--select * from v$version;操作第一步1.如下命令启用行迁移alter table test_a enable row movement;2.如下命令闪回到某时间点flashback table test_a to timestamp to_timestamp(2012-05-31 16:20:30, yyyy-mm-dd hh24:mi:ss);3如下命令查询sql操作日志 可以查看执行的语句执行的时间select * from v$sql order by FIRST_LOAD_TIME desc;　　select * from v$sql (#查看最近所作的操作)　　select * from v$sqlarea（#查看最近所作的操作）'>oracle 表误更新 （flashback ）闪回操作</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>16</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/3B4B9BE0-102F-4115-A3F8-058E89F8E1AB.html' title='监控oracle性能的一些常用查询1.查看临时表空间使用情况Selectf.tablespace_name,sum(f.bytes_free + f.bytes_used)/1024/1024/1024 total GB,sum((f.bytes_free + f.bytes_used) - nvl(p.bytes_used, 0))/1024/1024/1024 Free GB,sum(nvl(p.bytes_used, 0))/1024/1024/1024 Used GBfrom sys.v_$temp_space_header f, dba_temp_files d, sys.v_$temp_extent_pool pwhere f.tablespace_name(+) = d.tablespace_nameand f.file_id(+) = d.file_idand p.file_id(+) = d.file_idgroup byf.tablespace_name2.查看使用临时表空间的SQLSelect se.username, se.sid, su.extents, su.blocks * to_number(rtrim(p.value)) as Space, tablespace, segtype, sql_text from v$sort_usage su, v$parameter p, v$session se, v$sql swhere p.name = db_block_size and su.session_addr = se.saddr and s.hash_value = su.sqlhash and s.address = su.sqladdrorder by se.username, se.sid3.收缩临时表空间alter tablespace temp shrink space;alter tablespace temp shrink tempfile 4.重建索引alter index PK_CROSSRELATION rebuild;5.查看表空间使用情况SELECT UPPER(F.TABLESPACE_NAME) 表空间名,D.TOT_GROOTTE_MB 表空间大小(M),D.TOT_GROOTTE_MB - F.TOTAL_BYTES 已使用空间(M),TO_CHAR(ROUND((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,2),990.99) || % 使用比,F.TOTAL_BYTES 空闲空间(M),F.MAX_BYTES 最大块(M)FROM (SELECT TABLESPACE_NAME,ROUND(SUM(BYTES) / (1024 * 1024), 2) TOTAL_BYTES,ROUND(MAX(BYTES) / (1024 * 1024), 2) MAX_BYTESFROM SYS.DBA_FREE_SPACEGROUP BY TABLESPACE_NAME) F,(SELECT DD.TABLESPACE_NAME,ROUND(SUM(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MBFROM SYS.DBA_DATA_FILES DDGROUP BY DD.TABLESPACE_NAME) DWHERE D.TABLESPACE_NAME = F.TABLESPACE_NAMEORDER BY 1;6.查询表空间的总容量select tablespace_name, sum(bytes) / 1024 / 1024 as MBfrom dba_data_filesgroup by tablespace_name;7.查询表空间使用率select total.tablespace_name,round(total.MB, 2) as Total_MB,考试大论坛round(total.MB - free.MB, 2) as Used_MB,round((1 - free.MB / total.MB) * 100, 2) || % as Used_Pctfrom (select tablespace_name, sum(bytes) / 1024 / 1024 as MBfrom dba_free_spacegroup by tablespace_name) free,(select tablespace_name, sum(bytes) / 1024 / 1024 as MBfrom dba_data_filesgroup by tablespace_name) totalwhere free.tablespace_name = total.tablespace_name;8.查找当前表级锁的SQL如下：select sess.sid, sess.serial#, lo.oracle_username, lo.os_user_name, ao.object_name, lo.locked_mode from v$locked_object lo, dba_objects ao, v$session sess where ao.object_id = lo.object_id and lo.session_id = sess.sid;杀掉锁表进程： alter system kill session 436,35123;9.监控当前数据库谁在运行什么SQL语句select osuser, username, sql_textfrom v$session a, v$sqltext bwhere a.sql_address =b.address order by address, piece;10.找使用CPU多的用户session select a.sid,spid,status,substr(a.program,1,40) prog, a.terminal,osuser,value/60/100 value from v$session a,v$process b,v$sesstat c where c.statistic#=12 and c.sid=a.sid and a.paddr=b.addr order by value desc;11.查看死锁信息SELECT (SELECT username FROM v$session WHERE SID = a.SID) blocker, a.SID, is blocking, (SELECT username FROM v$session WHERE SID = b.SID) blockee, b.SID FROM v$lock a, v$lock bWHERE a.BLOCK = 1 AND b.request  0 AND a.id1 = b.id1 AND a.id2 = b.id2;12.具有最高等待的对象SELECT o.OWNER,o.object_name, o.object_type, a.event, SUM (a.wait_time + a.time_waited) total_wait_time FROM v$active_session_history a, dba_objects o WHERE a.sample_time BETWEEN SYSDATE - 30 / 2880 AND SYSDATE AND a.current_obj# = o.object_idGROUP BY o.OWNER,o.object_name, o.object_type, a.eventORDER BY total_wait_time DESC;13.查看具有最高等待的对象SELECT a.session_id, s.osuser, s.machine, s.program, o.owner, o.object_name, o.object_type, a.event, SUM (a.wait_time + a.time_waited) total_wait_time FROM v$active_session_history a, dba_objects o, v$session s WHERE a.sample_time BETWEEN SYSDATE - 30 / 2880 AND SYSDATE AND a.current_obj# = o.object_id AND a.session_id = s.SIDGROUP BY o.owner, o.object_name, o.object_type, a.event, a.session_id, s.program, s.machine, s.osuserORDER BY total_wait_time DESC;14.查看等待最多的SQLSELECT a.program, a.session_id, a.user_id, d.username, s.sql_text, SUM (a.wait_time + a.time_waited) total_wait_time FROM v$active_session_history a, v$sqlarea s, dba_users d WHERE a.sample_time BETWEEN SYSDATE - 30 / 2880 AND SYSDATE AND a.sql_id = s.sql_id AND a.user_id = d.user_idGROUP BY a.program, a.session_id, a.user_id, s.sql_text, d.username;15.显示正在等待锁的所有会话 SELECT * FROM DBA_WAITERS'>监控oracle性能的一些常用查询</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>17</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/32F52B97-76C3-40DB-87DA-05FE5CA17066.html' title='--查询当前正在执行的sqlselect a.EVENT, a.SQL_ID, a.MACHINE, b.SQL_TEXT, b.SQL_FULLTEXT,b.FIRST_LOAD_TIME,b.LAST_LOAD_TIME,b.LAST_ACTIVE_TIME from v$session a, v$sql bwhere a.SQL_ID = b.SQL_ID and a.USERNAME is not null and a.STATUS = ACTIVE--查看正在执行的sql执行计划--display_cursor   为第一步查出来的SQL_IDselect * from table(dbms_xplan.display_cursor(2wm9taucgwnkt))--运行效率SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY)'>--查看sql运行效率</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>18</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/E5FE1DD9-D42A-4278-B1DC-1208A031BDBE.html' title='select LPAD(decode(count(cerpcode),0,1,max(to_number(cerpcode)+1)),6,0) from BASE_PART where cerpcode in 279960含义解释：decode(条件,值1,返回值1,值2,返回值2,...值n,返回值n,缺省值)该函数的含义如下：IF 条件=值1 THEN　　　　RETURN(翻译值1)ELSIF 条件=值2 THEN　　　　RETURN(翻译值2)　　　　......ELSIF 条件=值n THEN　　　　RETURN(翻译值n)ELSE　　　　RETURN(缺省值)END IFdecode(字段或字段的运算，值1，值2，值3） 这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回值3当然值1，值2，值3也可以是表达式，这个函数使得某些sql语句简单了许多使用方法：1、比较大小selectdecode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1例如：变量1=10，变量2=20则sign(变量1-变量2)返回-1，decode解码结果为“变量1”，达到了取较小值的目的。2、此函数用在SQL语句中，功能介绍如下：Decode函数与一系列嵌套的 IF-THEN-ELSE语句相似。base_exp与compare1,compare2等等依次进行比较。如果base_exp和 第i 个compare项匹配，就返回第i 个对应的value 。如果base_exp与任何的compare值都不匹配，则返回default。每个compare值顺次求值，如果发现一个匹配，则剩下的compare值（如果还有的话）就都不再求值。一个为NULL的base_exp被认为和NULL compare值等价。如果需要的话，每一个compare值都被转换成和第一个compare 值相同的数据类型，这个数据类型也是返回值的类型。Decode函数在实际开发中非常的有用结合Lpad函数，如何使主键的值自动加1并在前面补0select LPAD(decode(count(记录编号),0,1,max(to_number(记录编号)+1)),14,0) 记录编号 from tetdmiseg:select decode(dir,1,0,1) from a1_intervaldir 的值是1变为0，是0则变为1比如我要查询某班男生和女生的数量分别是多少?通常我们这么写:select count(*) from 表 where 性别 ＝ 男；select count(*) from 表 where 性别 ＝ 女；要想显示到一起还要union一下，太麻烦了用decode呢，只需要一句话select decode(性别，男，1，0），decode(性别，女，1，0） from 表3，order by对字符列进行特定的排序大家还可以在Order by中使用Decode。例：表table_subject，有subject_name列。要求按照：语、数、外的顺序进行排序。这时，就可以非常轻松的使用Decode完成要求了。select * from table_subject order by decode(subject_name, 语文, 1, 数学, 2, , 外语,3)'>自增长函数  decode</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>19</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/09D88400-24C5-4F88-A6FE-138AC80DEFD3.html' title='--锁表查询SQLSELECT object_name, machine, s.sid, s.serial#FROM gv$locked_object l, dba_objects o, gv$session sWHERE l.object_id　= o.object_idAND l.session_id = s.sid;--查看连接的进程SELECT sid, serial#, username, osuser FROM v$session;--找到被锁定的表，解锁--释放SESSION SQL:--alter system kill session sid, serial#;ALTER system kill session 23, 1647;'>表锁 解锁</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>20</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/9AAE2E1B-8108-46A2-84EA-2C4BA948340D.html' title='select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1'>Oracle比较两个数的大小</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>21</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/06C429E7-4777-4D6D-AFBC-1CDB98218437.html' title='路径：/hkey_local_machine/software/oracle/key_oraclient11g_home1项NLS_LANGTRADITIONAL CHINESE_CHINA.ZHS16GBK显示乱码 添加系统变量变量：NLS_LANG值：TRADITIONAL CHINESE_CHINA.ZHS16GBK1修改注册表运行 cmd 》》 regedit'>链接Oracle数据库网页正文字符显示乱码解决方法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>22</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/CCF2FAEA-EA5B-49C4-841B-318770F6A464.html' title='grant all privileges TO RIGHTSUSER2319 赋予任何主机访问数据的权grant connect,resource,dba toWMS2319      赋权DBA'>Oracle 权限不足</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>23</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/D42C8A1B-E392-4730-8019-3322EAEB8D2C.html' title='select file_name,file_id,tablespace_name,bytes/1024/1024 from dba_data_files order by file_name;--创建表空间CREATE TABLESPACE WMSV6LOGGINGDATAFILE D:\APP\DREAMTEK02\ORADATA\ORCL\WMSV601.DBF SIZE 512MEXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;--创建用户create user wmsdb01 identified by 1 default tablespace WMSV6;--用户权限grant dba, connect, resource to wmsdb01;--备份创建表空间CREATE TABLESPACE WMS_BAKLOGGINGDATAFILE D:\APP\DREAMTEK02\ORADATA\ORCL\WMSBAK01.DBF SIZE 500MEXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;--创建用户create user wmsbak identified by 1 default tablespace WMS_BAK;--用户权限grant dba, connect, resource to wmsbak;--权限创建表空间CREATE TABLESPACE RIGHTSUSERLOGGINGDATAFILE D:\APP\DREAMTEK02\ORADATA\ORCL\RIGHTSUSER01.DBF SIZE 500MEXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;--创建用户create user rightsuser identified by 1 default tablespace RIGHTSUSER;--用户权限grant dba, connect, resource to rightsuser;--在权限用户下grant dba, connect, resource to wmsdb01;'>创建表空间</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>24</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/2BE55A09-C6ED-467E-B0A0-34C13ABEA64E.html' title='本机安装了oracle并创建了库，一直正常使用，突然有天数据不能连接了，plsql登陆时报错：ora-12528 TNS:监听程序：所有适用例程都无法建立连接[@more@]本机WINDOWS系统，在服务里重启了数据库实例和监听，然后重新连接，错误依旧。然后通过sqlplus连接到数据库，进行重启，日志如下：SQL shutdown immediate;ORA-01507: ??????ORACLE 例程已经关闭。SQL startup;ORACLE 例程已经启动。Total System Global Area 612368384 bytesFixed Size 1250428 bytesVariable Size 205523844 bytesDatabase Buffers 398458880 bytesRedo Buffers 7135232 bytesORA-00214: ???? D:ORACLEPRODUCT10.2.0ORADATAORCLCONTROL01.CTL ?? 1330??? D:ORACLEPRODUCT10.2.0ORADATAORCLCONTROL02.CTL ?? 1324 ???请教了一位DBA朋友，告诉我说是控制文件出错了，需要替换一下，然后执行：ALTER SYSTEM SET CONTROL_FILES=D:ORACLEPRODUCT10.2.0ORADATAORCLCONTROL03.CTL SCOPE=SPFILE再次重启后正常。网上关于这个问题的帖子很多，可能出现的情况也很多，本次遇到的可能是情况之一，问题解决了就记录一下备查。'>连接ORACLE报错：ORA-12528</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>25</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/38A7EC62-C3B2-45D1-BBE7-4438B92638C2.html' title='CREATE OR REPLACE TRIGGER trigger_AutoOutBillSnBEFORE INSERT OR UPDATE ON outbill_D  for each rowdeclareT_SN VARCHAR2(400);T_DATECODE VARCHAR2(400);T_ID VARCHAR2(400);T_IDS VARCHAR2(400);T_CINVCODE VARCHAR2(400);T_QUANTITY VARCHAR2(400);T_cOUNT NUMBER;BEGIN SELECT count(1) into T_cOUNT FROM OUTBILL_D WHERE CPOSITIONCODE IN (01-CK-AH45);  IF T_cOUNT 0 THEN SELECT ID,IDS,CINVCODE,IQUANTITY into T_ID,T_IDS, T_CINVCODE,T_QUANTITY FROM OUTBILL_D WHERE CPOSITIONCODE IN (01-CK-AH45); T_cOUNT:=0; SELECT COUNT(1) INTO T_cOUNT FROM outbill_d_sn A WHERE A.OUTBILL_ID=T_ID AND A.OUTBILL_D_IDS=T_IDS;--此条数据不存在SN表  IF (T_cOUNT1 ) THEN  SELECT to_char(TO_DATE(to_char(sysdate, YYYYMMDD), YYYYMMDD), yyyyiw) into T_DATECODE from dual;  SELECT to_char(systimestamp,DDHH24MIff3)||-||to_char(systimestamp,YYMM)||round (dbms_random.value(1,999999),0) into T_SN FROM DUAL;  insert into outbill_d_sn (ID, OUTBILL_ID, OUTBILL_D_IDS, SN_CODE, DATECODE, CINVCODE, QUANTITY, WORKTYPE, CREATETIME, CREATEOWNER)   values (sys_guid(), T_ID,T_IDS,T_SN, T_DATECODE, T_CINVCODE,T_QUANTITY, 0,SYSDATE, SYSTEM);   END IF;END IF;END;'>我写的第一个Oracle触发器</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>26</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/CBC92D93-2B4F-4F02-9213-7DDD7EF1176E.html' title='浅谈sql中的in与not in,exists与not exists的区别sqlexistsin1、in和existsin是把外表和内表作hash连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询，一直以来认为exists比in效率高的说法是不准确的。如果查询的两个表大小相当，那么用in和exists差别不大；如果两个表中一个较小一个较大，则子查询表大的用exists，子查询表小的用in；例如：表A(小表)，表B(大表)select*fromAwhereccin(selectccfromB)　　--效率低，用到了A表上cc列的索引；select*fromAwhereexists(selectccfromBwherecc=A.cc)　　--效率高，用到了B表上cc列的索引。相反的：select*fromBwhereccin(selectccfromA)　　--效率高，用到了B表上cc列的索引select*fromBwhereexists(selectccfromAwherecc=B.cc)　　--效率低，用到了A表上cc列的索引。2、not in 和not existsnot in 逻辑上不完全等同于not exists，如果你误用了not in，小心你的程序存在致命的BUG，请看下面的例子：createtable#t1(c1int,c2int);createtable#t2(c1int,c2int);insertinto#t1values(1,2);insertinto#t1values(1,3);insertinto#t2values(1,2);insertinto#t2values(1,null);    select*from#t1wherec2notin(selectc2from#t2);　　--执行结果：无select*from#t1wherenotexists(select1from#t2where#t2.c2=#t1.c2)　　--执行结果：1　　3正如所看到的，not in出现了不期望的结果集，存在逻辑错误。如果看一下上述两个select 语句的执行计划，也会不同，后者使用了hash_aj，所以，请尽量不要使用not in(它会调用子查询)，而尽量使用not exists（它会调用关联子查询）。如果子查询中返回的任意一条记录含有空值，则查询将不返回任何记录。如果子查询字段有非空限制，这时可以使用not in，并且可以通过提示让它用hasg_aj或merge_aj连接。如果查询语句使用了not in，那么对内外表都进行全表扫描，没有用到索引；而not exists的子查询依然能用到表上的索引。所以无论哪个表大，用not exists都比not in 要快。3、in 与 = 的区别selectnamefromstudentwherenamein(zhang,wang,zhao);与selectnamefromstudentwherename=zhangorname=wangorname=zhao的结果是相同的。'>浅谈sql中的in与not in,exists与not exists的区别</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>27</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/A09C6B18-BEF0-401D-9DAB-478C63513CB4.html' title='Oracle 日期查询转自:http://hi.baidu.com/fengboy_7334/blog/item/b0aa60035f36a1e809fa935d.html例如:select * from c where cdate=to_date(2010-10-14 14:00:00,yyyy-mm-dd hh24:mi:ss)select * from mytable where to_char(install_date,YYYYMMDD)  20050101select * from mytable where install_date  to_date(20050101,yyyymmdd);取得当前日期是本月的第几周SQL select to_char(sysdate,YYYYMMDD W HH24:MI:SS) from dual;  TO_CHAR(SYSDATE,YY ------------------- 20080327 4 18:16:09  SQL select to_char(sysdate,W) from dual; T - 4№2:取得当前日期是一个星期中的第几天,注意星期日是第一天SQL select sysdate,to_char(sysdate,D) from dual; SYSDATE T --------- - 27-MAR-08 5类似:select to_char(sysdate,yyyy) from dual; --当前年 select to_char(sysdate,Q from dual; --当前季度 select to_char(sysdate,mm) from dual; --当前月 select to_char(sysdate,dd) from dual; --当前日 ddd 年中的第几天 WW 年中的第几个星期 W 该月中第几个星期DAY 周中的星期几 D 今天对映的NUMBER1,星期日, 2,星期一, 3,星期二, 4,星期三, 5,星期四, 6,星期五, 7,星期六 hh 小时(12) hh24 小时(24) Mi 分 ss 秒№3:取当前日期是星期几的中文显示:SQL select to_char(sysdate,day) from dual; TO_CHAR(SYSDATE,DAY) ---------------------- 星期四№4:如果一个表在一个date类型的字段上面建立了索引，如何使用alter session set NLS_DATE_FORMAT=YYYY-MM-DD HH24:MI:SS№5: 得到当前的日期 select sysdate from dual;№6: 得到当天凌晨0点0分0秒的日期 select trunc(sysdate) from dual;-- 得到这天的最后一秒 select trunc(sysdate) + 0.99999 from dual;-- 得到小时的具体数值 select trunc(sysdate) + 1/24 from dual;select trunc(sysdate) + 7/24 from dual;№7:得到明天凌晨0点0分0秒的日期select trunc(sysdate+1) from dual;select trunc(sysdate)+1 from dual;№8: 本月一日的日期 select trunc(sysdate,mm) from dual;№9:得到下月一日的日期 select trunc(add_months(sysdate,1),mm) from dual;№10:返回当前月的最后一天? select last_day(sysdate) from dual; select last_day(trunc(sysdate)) from dual; select trunc(last_day(sysdate)) from dual; select trunc(add_months(sysdate,1),mm) - 1 from dual;№11: 得到一年的每一天 select trunc(sysdate,yyyy)+ rn -1 date0 from (select rownum rn from all_objects where rownum366);№12:今天是今年的第N天 SELECT TO_CHAR(SYSDATE,DDD) FROM DUAL;№13:如何在给现有的日期加上2年 select add_months(sysdate,24) from dual;№14:判断某一日子所在年分是否为润年 select decode(to_char(last_day(trunc(sysdate,y)+31),dd),29,闰年,平年) from dual;№15:判断两年后是否为润年 select decode(to_char(last_day(trunc(add_months(sysdate,24),y)+31),dd),29,闰年,平年) from dual;№16:得到日期的季度select ceil(to_number(to_char(sysdate,mm))/3) from dual;select to_char(sysdate, Q) from dual;No17:返回某个月的最后一天select to_char(last_day(sysdate),dd) from dual参数传递,Number型插入空值 昨天在程序中遇到一个数据类型转换的问题，在传递参数时，往Number类型中插入空值出现的问题：例如：string cskzcxcl ;para[0] = new OracleParameter(:cskzcxcl, OracleType.Number, 9);para[0].Value = cskzcxcl;总是报错，说是数据类型的问题; 经过本人今天在朋友的帮助下，总算找到了解决办法:para[0].Value =DBNull.Value;这样再插入空字符串时就不会出错;Oracle中LPAD和RPAD的用法 LPAD和RPAD的用法 SELECT LPAD(B,10,-) || 字段名 FROM 表1;在 B 的左边插入10个 - 字符.SELECT RPAD(B,10,-) || 字段名 FROM 表1;在 B 的右边插入10个 - 字符.Hi，Im Cortana,Can I help you? wechat：Excel_Cortana;QQ群: 303625469'>Oracle 日期查询</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>28</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/BBEDDE0E-638B-4D87-ABA6-492F16F4065D.html' title='create public database link DBLINK2315 connect to 用户 identified by 密码 using DB源服务名;Oracle中创建dblink的方法发布时间　　当用户要跨本地数据库，访问另外一个数据库表中的数据时，本地数据库中必须创建了远程数据库的dblink,通过dblink本地数据库可以像访问本地数据库一样访问远程数据库表中的数据。下面讲介绍如何在本地数据库中创建dblink.　　创建dblink一般有两种方式，不过在创建dblink之前用户必须有创建dblink的权限。想知道有关dblink的权限，以sys用户登录到本地数据库：　　select*fromuser_sys_privst　　wheret.privilegelikeupper(%link%);　　1SYSCREATEDATABASELINKNO　　2SYSDROPPUBLICDATABASELINKNO　　3SYSCREATEPUBLICDATABASELINKNO　　可以看出在数据库中dblink有三种权限CREATEDATABASELINK(所创建的dblink只能是创建者能使用，别?挠没褂貌涣?，CREATEPUBLICDATABASELINK(public表示所创建的dblink所有用户都可以使用)，DROPPUBLICDATABASELINK。　　在sys用户下，把CREATEPUBLICDATABASELINK，DROPPUBLICDATABASELINK权限授予给你的用户　　grantCREATEPUBLICDATABASELINK，DROPPUBLICDATABASELINKtoscott;　　然后以scott用户登录本地数据库　　1.创建dblink的第一种方式，是在本地数据库tnsnames.ora文件中配置了要远程访问的数据库。　　createpublicdatabaselink　　to_bylwconnecttoscottidentifiedbytigerusingbylw;　　其中to_bylw是你创建的dblink名字，bylw是远程数据库的实例名，scott/tiger是登录到远程数据库的用户/密码。然后在本地数据库中通过dblink访问远程数据库bylw中scott.tb_test表，sql语句如下所示　　select*fromscott.tb_test@to_bylw;　　2.创建dblink的第二种方式，是在本地数据库tnsnames.ora文件中没有配置要访问的远程数据库，　　createdatabaselinkto_test　　connecttoscottidentifiedbytiger　　using(DESCRIPTION=　　(ADDRESS_LIST=　　(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.1.5)(PORT=1521))　　)　　(CONNECT_DATA=　　(SERVER=DEDICATED)　　(SERVICE_NAME=bylw)　　)　　);　　第二种是把第一种配置在tnsnames.ora文件中的信息，直接放在创建dblink语句后面。第一种情况tnsnames.ora文件中信息如下：　　bylw=　　(DESCRIPTION=　　(ADDRESS_LIST=　　(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.1.5)(PORT=1521))　　)　　(CONNECT_DATA=　　(SERVER=DEDICATED)　　(SERVICE_NAME=bylw)　　)　　)原文出自【比特网】，转载请保留原文链接：http://soft.chinabyte.com/database/290/12218290.shtml'>创建DBLink方法  Oracle中创建dblink的方法发布时间</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>29</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/0ABF8B73-7CF5-4650-9963-4E7C6B8FEC56.html' title='显示乱码 环境变量设置添加系统变量变量：NLS_LANG值：TRADITIONAL CHINESE_CHINA.ZHS16GBK如果不ok按照下面路径修改注册表修改注册表：路径：/hkey_local_machine/software/oracle/key_oraclient11g_home1项：NLS_LANG值：TRADITIONAL CHINESE_CHINA.ZHS16GBK'>Oracle中文乱码</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>30</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/E6E1AE06-D1A3-4C27-ADF6-BA669EFFB895.html' title='我们都比较熟悉windows中的回收站,文件删除后放到回收站里还可以再复原.Oracle回收站的原理完全一样,只是实现的细节方面有些差异.另外回收站中只能回收表和相关的对象包括索引、约束、触发器、嵌套表、大的二进制对象（LOB）段和LOB索引段.从Orace 10g开始有回收站的功能.1.回收站启动和关闭回收站默认是开启的.不过我们可以通过参数recyclebin来关闭和开启.如果只是针对每个session可以通过alter session set recyclebin=off; 和 alter session set recyclebin=on;来关闭和开启如果是针对所有session可以通过修改系统参数recyclebin来实现,不过这里要注意10g和11g有点不一样,它们的参数类型不同10g可以用:alter system set recyclebin=off; 和alter system set recyclebin=on;来关闭和开启11g可以用:alter system set recyclebin=off deferred; 和alter system set recyclebin=on deferred;来关闭和开启补充:我们来简单的了解下Oracle参数类型Oracle参数信息可以通过视图v$parameter查看,其中有一列issys_modifiable表示参数类型,有immediate,false,deferred三种,其中false表示是静态参数,只要当instance重新启动时才会生效,其他两种是动态参数,immediate表示修改参数后立即生效,deferred表示修改后要等下一个session才能生效,修改时已经连接的session是不会生效的.在用alter修改参数时如果是false或immediate一般可以不写,如果是deferred则要写10g: select ISSYS_MODIFIABLE from v$parameter where name = recyclebin;的结果是immediate11g: select ISSYS_MODIFIABLE from v$parameter where name = recyclebin;的结果是deferred2.查看回收站内容select * from user_recyclebin;或select * from recyclebin;查看当前用户所drop的对象(里面有对象之前的名字和drop之后的名字)select * from dba_recyclebin;查看所有用户drop掉的对象其实当一个对象drop后,并且开启了回收站功能.它并没有真正被删除,实际上只是修改了一下名字,我们用select * from user_objects where type= TABLE还能查到.只是它的名字有点怪,例如BIN$qAUuckGyd3TgQKjAFAFTAg==$0,它的命名规范是BIN$unique_id$version 其中BIN代表RecycleBin, unique_id是数据库中该对象的唯一标志，26个字符长度 ,version表示该对象的版本号.3.还原回收站内容假如有表test被drop,drop后的object_name是BIN$qAUuckGyd3TgQKjAFAFTAg==$0可以用flashback table BIN$qAUuckGyd3TgQKjAFAFTAg==$0 to before drop ;(记得名字加双引号)或者flashback table test to before drop;来还原.不过假如drop掉一个表test,再新建一个表test,然后再drop.那么flashback table test to before drop只能还原最后被drop掉的表test.最先drop掉的表还原时会出错,因为表名不能重名.所以必须改名flashback table test to before drop rename to test24.清空回收站如果一次只清空一个表,可以用PURGE table test 或PURGE table BIN$qAUuckGyd3TgQKjAFAFTAg==$0;如果一次清空所有的可以用PURGE recyclebin 或者PURGE dba_recyclebin还原时是只能一次还原一个表,不能像清空一样一次还原所有表5,注意事项如果表是在system表空间下面则不能使用回收站的功能,不知道为啥有这限制啊如果表空间快满时系统会自动的去清空回收站中一部分内容,先清空最早drop的对象如果删除表时候不想放在回收站，彻底删除 使用 drop table table-namepurge'>oracle 11g 回收站(recyclebin)的使用</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>31</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/833636C6-179D-48AA-BBC0-641982AC8177.html' title='SELECT object_name, machine, s.sid, s.serial#FROM gv$locked_object l, dba_objects o, gv$session sWHERE l.object_id　= o.object_idAND l.session_id = s.sid;--alter system kill session sid, serial#;ALTER system kill session 473,59577;'>oracle  表死锁 解锁</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>32</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/27E3ADC4-3E7B-4E54-8983-648A5FAB2D78.html' title='创建dblinkcreate database link dbl_test connect totest identified byoracle using lwl;dbl_test:dblink的名字test:要连接的数据库的用户名oracle:要连接的数据库的密码lwl:本地建立的连接到远程数据库的服务名SQL select * fromdual@dbl_test;如果返回结果如下就说明建立成功了'>创建dblink</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>33</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/B0DCE4C6-C550-4BA0-B00D-69F83240E9F5.html' title='语法delete from aatruncate table aa区别1.delete from后面可以写条件，truncate不可以。2.delete from记录是一条条删的，所删除的每行记录都会进日志，而truncate一次性删掉整个页，因此日至里面只记录页释放，简言之，delete from更新日志，truncate基本不，所用的事务日志空间较少。3.delete from删空表后，会保留一个空的页，truncate在表中不会留有任何页。4.当使用行锁执行 DELETE 语句时，将锁定表中各行以便删除。truncate始终锁定表和页，而不是锁定各行。5.如果有identity产生的自增id列，delete from后仍然从上次的数开始增加，即种子不变，而truncate后，种子会恢复初始。6.truncate不会触发delete的触发器，因为truncate操作不记录各个行删除。总结1.truncate和 delete只删除数据不删除表的结构(定义) drop语句将删除表的结构被依赖的约束(constrain),触发器(trigger),索引(index); 依赖于该表的存储过程/函数将保留,但是变为invalid状态。2.delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发 truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger。3.delete语句不影响表所占用的extent, 高水线(high watermark)保持原位置不动 显然drop语句将表所占用的空间全部释放 truncate 语句缺省情况下见空间释放到 minextents个 extent,除非使用reuse storage; truncate会将高水线复位(回到最开始)。4.速度,一般来说: drop truncate  delete。5.安全性:小心使用drop 和truncate,尤其没有备份的时候.否则哭都来不及。6.使用上,想删除部分数据行用delete,注意带上where子句. 回滚段要足够大. 想删除表,当然用drop想保留表而将所有数据删除. 如果和事务无关,用truncate即可. 如果和事务有关,或者想触发trigger,还是用delete如果是整理表内部的碎片,可以用truncate跟上reuse stroage,再重新导入/插入数据。'>详解Oracle DELETE和TRUNCATE 的区别</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>34</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/D1222700-7A0C-4755-9B6B-95BCFE6C11BE.html' title='Oracle分页语句通用的Oracle分页sqlSELECT*FROM  (SELECTA.*,rownumrFROM--這裡的SQL可以改成你真正要執行的SQL  (SELECT*FROMArticlesORDERBYPubTimeDESC  )A----用上面的SQL得回來的集合,使用rownum去比對,這樣rownum就會從這  個集合的第一筆資料開始往下計算,所以這邊是抓取前100筆WHERErownum=100  )B  --B集合總共有A集合和r(rownum)的資料,這裡是抓取大於第90筆的WHEREr90;'>Oracle分页语句  通用的Oracle分页sql</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>35</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/BCEFF37A-48DF-4DF9-BF03-7BF93EA88A47.html' title='Oracle截取字符串的函数substrsubstrOracle中的截取字符串函数。　　语法如下：　　substr( string, start_position, [ length ] )　　参数分析：　　string　　字符串值　　start_position　　截取字符串的初始位置， Number型，start_position为负数时，表示从字符串右边数起。　　length　　截取位数，Number型　　其中，length为可选，如果length为空(即不填)则返回start_position后面的所有字符。　　意思就是：　　从start_position开始,取出length个字符并返回取出的字符串。　　具体参考示例。　　示例：　　SELECT substr(This is a test, 6, 2) FROM dual 返回 is　　substr(SyranMo have a dream, -8, 2)'>Oracle截取字符串的函数substr</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>36</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/57502581-AACA-4C74-BF8C-872380C140AD.html' title='MERGE INTOOracle9i引入了MERGE命令,你能够在一个SQL语句中对一个表同时执行inserts和updates操作. MERGE命令从一个或多个数据源中选择行来updating或inserting到一个或多个表.Oracle 10g中MERGE有如下一些改进：1、UPDATE或INSERT子句是可选的2、UPDATE和INSERT子句可以加WHERE子句3、ON条件中使用常量过滤谓词来insert所有的行到目标表中,不需要连接源表和目标表4、UPDATE子句后面可以跟DELETE子句来去除一些不需要的行首先创建示例表：create table PRODUCTS  (  PRODUCT_ID INTEGER,  PRODUCT_NAME VARCHAR2(60),  CATEGORY VARCHAR2(60)  );  insert into PRODUCTS values (1501, VIVITAR 35MM, ELECTRNCS);  insert into PRODUCTS values (1502, OLYMPUS IS50, ELECTRNCS);  insert into PRODUCTS values (1600, PLAY GYM, TOYS);  insert into PRODUCTS values (1601, LAMAZE, TOYS);  insert into PRODUCTS values (1666, HARRY POTTER, DVD);  commit;  create table NEWPRODUCTS  (  PRODUCT_ID INTEGER,  PRODUCT_NAME VARCHAR2(60),  CATEGORY VARCHAR2(60)  );  insert into NEWPRODUCTS values (1502, OLYMPUS CAMERA, ELECTRNCS);  insert into NEWPRODUCTS values (1601, LAMAZE, TOYS);  insert into NEWPRODUCTS values (1666, HARRY POTTER, TOYS);  insert into NEWPRODUCTS values (1700, WAIT INTERFACE, BOOKS);  commit;1、可省略的UPDATE或INSERT子句在Oracle 9i, MERGE语句要求你必须同时指定INSERT和UPDATE子句.而在Oracle 10g, 你可以省略UPDATE或INSERT子句中的一个. 下面的例子根据表NEWPRODUCTS的PRODUCT_ID字段是否匹配来updates表PRODUCTS的信息:SQL MERGE INTO products p  2 USING newproducts np  3 ON (p.product_id = np.product_id)  4 WHEN MATCHED THEN  5 UPDATE  6 SET p.product_name = np.product_name,  7 p.category = np.category;  3 rows merged.  SQL SELECT * FROM products;  PRODUCT_ID PRODUCT_NAME CATEGORY  ---------- -------------------- ----------  1501 VIVITAR 35MM ELECTRNCS  1502 OLYMPUS CAMERA ELECTRNCS  1600 PLAY GYM TOYS  1601 LAMAZE TOYS  1666 HARRY POTTER TOYS  SQL  SQL ROLLBACK;  Rollback complete.  SQL在上面例子中, MERGE语句影响到是产品id为1502, 1601和1666的行. 它们的产品名字和种 类被更新为表newproducts中的值. 下面例子省略UPDATE子句, 把表NEWPRODUCTS中新的PRODUCT_ID插入到表PRODUCTS中, 对于在两个表中能够匹配上PRODUCT_ID的数据不作任何处理. 从这个例子你能看到PRODUCT_ID=1700的行被插入到表PRODUCTS中.SQL MERGE INTO products p  2 USING newproducts np  3 ON (p.product_id = np.product_id)  4 WHEN NOT MATCHED THEN  5 INSERT  6 VALUES (np.product_id, np.product_name,  7 np.category);  1 row merged.  SQL SELECT * FROM products;  PRODUCT_ID PRODUCT_NAME CATEGORY  ---------- -------------------- ----------  1501 VIVITAR 35MM ELECTRNCS  1502 OLYMPUS IS50 ELECTRNCS  1600 PLAY GYM TOYS  1601 LAMAZE TOYS  1666 HARRY POTTER DVD  1700 WAIT INTERFACE BOOKS2、带条件的Updates和Inserts子句你能够添加WHERE子句到UPDATE或INSERT子句中去, 来跳过update或insert操作对某些行的处理. 下面例子根据表NEWPRODUCTS来更新表PRODUCTS数据, 但必须字段CATEGORY也得同时匹配上:SQL MERGE INTO products p  2 USING newproducts np  3 ON (p.product_id = np.product_id)  4 WHEN MATCHED THEN  5 UPDATE  6 SET p.product_name = np.product_name  7 WHERE p.category = np.category;  2 rows merged.  SQL SELECT * FROM products;  PRODUCT_ID PRODUCT_NAME CATEGORY  ---------- -------------------- ----------  1501 VIVITAR 35MM ELECTRNCS  1502 OLYMPUS CAMERA ELECTRNCS  1600 PLAY GYM TOYS  1601 LAMAZE TOYS  1666 HARRY POTTER DVD  SQL  SQL rollback;在这个例子中, 产品ID为1502,1601和1666匹配ON条件但是1666的category不匹配. 因此MERGE命令只更新两行数据. 下面例子展示了在Updates和Inserts子句都使用WHERE子句:SQL MERGE INTO products p  2 USING newproducts np  3 ON (p.product_id = np.product_id)  4 WHEN MATCHED THEN  5 UPDATE  6 SET p.product_name = np.product_name,  7 p.category = np.category  8 WHERE p.category = DVD  9 WHEN NOT MATCHED THEN  10 INSERT  11 VALUES (np.product_id, np.product_name, np.category)  12 WHERE np.category != BOOKS  SQL /  1 row merged.  SQL SELECT * FROM products;  PRODUCT_ID PRODUCT_NAME CATEGORY  ---------- -------------------- ----------  1501 VIVITAR 35MM ELECTRNCS  1502 OLYMPUS IS50 ELECTRNCS  1600 PLAY GYM TOYS  1601 LAMAZE TOYS  1666 HARRY POTTER TOYS  SQL注意由于有WHERE子句INSERT没有插入所有不匹配ON条件的行到表PRODUCTS.3、无条件的Inserts你能够不用连接源表和目标表就把源表的数据插入到目标表中. 这对于你想插入所有行到目标表时是非常有用的. Oracle 10g现在支持在ON条件中使用常量过滤谓词. 举个常量过滤谓词例子ON (1=0). 下面例子从源表插入行到表PRODUCTS, 不检查这些行是否在表PRODUCTS中存在:SQL MERGE INTO products p  2 USING newproducts np  3 ON (1=0)  4 WHEN NOT MATCHED THEN  5 INSERT  6 VALUES (np.product_id, np.product_name, np.category)  7 WHERE np.category = BOOKS  SQL /  1 row merged.  SQL SELECT * FROM products;  PRODUCT_ID PRODUCT_NAME CATEGORY  ---------- -------------------- ----------  1501 VIVITAR 35MM ELECTRNCS  1502 OLYMPUS IS50 ELECTRNCS  1600 PLAY GYM TOYS  1601 LAMAZE TOYS  1666 HARRY POTTER DVD  1700 WAIT INTERFACE BOOKS  6 rows selected.  SQL4、新增加的DELETE子句Oracle 10g中的MERGE提供了在执行数据操作时清除行的选项. 你能够在WHEN MATCHED THEN UPDATE子句中包含DELETE子句. DELETE子句必须有一个WHERE条件来删除匹配某些条件的行.匹配DELETE WHERE条件但不匹配ON条件的行不会被从表中删除.下面例子验证DELETE子句. 我们从表NEWPRODUCTS中合并行到表PRODUCTS中, 但删除category为ELECTRNCS的行.SQL MERGE INTO products p  2 USING newproducts np  3 ON (p.product_id = np.product_id)  4 WHEN MATCHED THEN  5 UPDATE  6 SET p.product_name = np.product_name,  7 p.category = np.category  8 DELETE WHERE (p.category = ELECTRNCS)  9 WHEN NOT MATCHED THEN  10 INSERT  11 VALUES (np.product_id, np.product_name, np.category)  SQL /  4 rows merged.  SQL SELECT * FROM products;  PRODUCT_ID PRODUCT_NAME CATEGORY  ---------- -------------------- ----------  1501 VIVITAR 35MM ELECTRNCS  1600 PLAY GYM TOYS  1601 LAMAZE TOYS  1666 HARRY POTTER TOYS  1700 WAIT INTERFACE BOOKS  SQL产品ID为1502的行从表PRODUCTS中被删除, 因为它同时匹配ON条件和DELETE WHERE条件. 产品ID为1501的行匹配DELETE WHERE条件但不匹配ON条件, 所以它没有被删除. 产品ID为1700 的行不匹配ON条件, 所以被插入表PRODUCTS. 产品ID为1601和1666的行匹配ON条件但不匹配DELETE WHERE条件, 所以被更新为表NEWPRODUCTS中的值.'>MERGE INTO</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>37</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/ADA2431F-5CB5-457A-95EE-A17761EDFB6E.html' title='Oracle生日提醒sql语句写法今天想做个员工生日提醒的模块，突然发现语句还不好写，于是百度总结了一下，呵呵。SELECT * from 表名 where HUMANSTATE=正常在职 AND(TO_NUMBER(TO_CHAR((DATEOFBIRTH),MM)) = TO_NUMBER(TO_CHAR((sysdate),MM))) AND (TO_NUMBER(TO_CHAR((DATEOFBIRTH),DD)) BETWEEN TO_NUMBER(TO_CHAR((sysdate),DD)) AND TO_NUMBER(TO_CHAR((sysdate),DD))+7)红色部分为提醒条件，最后一个7是提前7天提醒，你可以随便改。'>Oracle生日提醒sql语句写法</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>38</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/67BE10B8-E3A9-4E15-BD09-ABB9F65F68B9.html' title='ORACLE]数据库之间复制表数据库之间复制表数据的方法汇总:1.EXP/IMP [plain]view plaincopyprint?C:\DocumentsandSettings\AdministratorEXPGW/***@R5DEV_223FILE=C:\TEST1.DUMPTABLES=(admin_changelog)GRANTS=NExport:Release11.2.0.1.0-Productionon星期五10月1113:27:112013Copyright(c)1982,2009,Oracleand/oritsaffiliates.Allrightsreserved.EXP-00056:遇到ORACLE错误28002ORA-28002:thepasswordwillexpirewithin7days连接到:OracleDatabase11gEnterpriseEditionRelease11.2.0.2.0-64bitProductionWiththePartitioning,OLAP,DataMiningandRealApplicationTestingoptions已导出ZHS16GBK字符集和AL16UTF16NCHAR字符集注:将不导出对表/视图/序列/角色的授权即将导出指定的表通过常规路径.....正在导出表ADMIN_CHANGELOG导出了28行成功终止导出,没有出现警告。C:\DocumentsandSettings\AdministratorEXPGW/***@R5DEV_223FILE=C:\TEST1.DUMPTABLES=(admin_changelog)GRANTS=N    Export:Release11.2.0.1.0-Productionon星期五10月1113:27:112013    Copyright(c)1982,2009,Oracleand/oritsaffiliates.Allrightsreserved.      EXP-00056:遇到ORACLE错误28002  ORA-28002:thepasswordwillexpirewithin7days  连接到:OracleDatabase11gEnterpriseEditionRelease11.2.0.2.0-64bitProduction  WiththePartitioning,OLAP,DataMiningandRealApplicationTestingoptions  已导出ZHS16GBK字符集和AL16UTF16NCHAR字符集  注:将不导出对表/视图/序列/角色的授权    即将导出指定的表通过常规路径...  ..正在导出表ADMIN_CHANGELOG导出了28行  成功终止导出,没有出现警告。[plain]view plaincopyprint?C:\DocumentsandSettings\AdministratorIMPcry/cryFROMUSER=CRYTOUSER=SCOTTFILE=C:\TEST1.DUMPTABLES=(admin_changelog)IGNORE=YImport:Release11.2.0.1.0-Productionon星期五10月1113:33:412013Copyright(c)1982,2009,Oracleand/oritsaffiliates.Allrightsreserved.连接到:OracleDatabase11gEnterpriseEditionRelease11.2.0.1.0-ProductionWiththePartitioning,OLAP,DataMiningandRealApplicationTestingoptions经由常规路径由EXPORT:V11.02.00创建的导出文件警告:这些对象由GW导出,而不是当前用户已经完成ZHS16GBK字符集和AL16UTF16NCHAR字符集中的导入.正在将GW的对象导入到SCOTT..正在导入表ADMIN_CHANGELOG导入了28行成功终止导入,没有出现警告。C:\DocumentsandSettings\AdministratorIMPcry/cryFROMUSER=CRYTOUSER=SCOTTFILE=C:\TEST1.DUMPTABLES=(admin_changelog)IGNORE=Y    Import:Release11.2.0.1.0-Productionon星期五10月1113:33:412013    Copyright(c)1982,2009,Oracleand/oritsaffiliates.Allrightsreserved.      连接到:OracleDatabase11gEnterpriseEditionRelease11.2.0.1.0-Production  WiththePartitioning,OLAP,DataMiningandRealApplicationTestingoptions    经由常规路径由EXPORT:V11.02.00创建的导出文件    警告:这些对象由GW导出,而不是当前用户    已经完成ZHS16GBK字符集和AL16UTF16NCHAR字符集中的导入  .正在将GW的对象导入到SCOTT  ..正在导入表ADMIN_CHANGELOG导入了28行  成功终止导入,没有出现警告。注意导出角色和导入角色最好一致,不然需要使用DBA角色,然后加FROMUSER、TOUSER参数来实现导出或导入。2. 使用DBLINK[sql]view plaincopyprint?13:41:11SCOTT@orclcreatedatabaselinkTEST_LINKCONNECTTOGWIDENTIFIEDBY******USINGR5DEV_223;数据库链接已创建。已用时间:00:00:00.0713:41:36SCOTT@orclCREATETABLEadmin_changelogASSELECT*FROMadmin_changelog@TEST_LINK;表已创建。已用时间:00:00:00.8113:41:11SCOTT@orclcreatedatabaselinkTEST_LINKCONNECTTOGWIDENTIFIEDBY******USINGR5DEV_223;    数据库链接已创建。    已用时间:00:00:00.07  13:41:36SCOTT@orclCREATETABLEadmin_changelogASSELECT*FROMadmin_changelog@TEST_LINK;    表已创建。    已用时间:00:00:00.813. SQLPLUS的COPY命令[sql]view plaincopyprint?13:42:16SCOTT@orclcopyfromGW/******@R5DEV_223toSCOTT/TIGER@ORCLREPLACEadmin_changelogUSINGSELECT*FROMadmin_changelog;数组提取/绑定大小为15。(数组大小为15)将在完成时提交。(提交的副本为0)最大long大小为100000。(long为100000)表ADMIN_CHANGELOG已删除。表ADMIN_CHANGELOG已创建。28行选自GW@R5DEV_223。28行已插入ADMIN_CHANGELOG。28行已提交至ADMIN_CHANGELOG(位于SCOTT@ORCL)。13:42:16SCOTT@orclcopyfromGW/******@R5DEV_223toSCOTT/TIGER@ORCLREPLACEadmin_changelogUSINGSELECT*FROMadmin_changelog;    数组提取/绑定大小为15。(数组大小为15)  将在完成时提交。(提交的副本为0)  最大long大小为100000。(long为100000)  表ADMIN_CHANGELOG已删除。    表ADMIN_CHANGELOG已创建。    28行选自GW@R5DEV_223。  28行已插入ADMIN_CHANGELOG。  28行已提交至ADMIN_CHANGELOG(位于SCOTT@ORCL)。注:REPLACE是先删除再创建,CREATE直接创建,如存在该对象则会报错:ORA-00955: 名称已由现有对象使用'>ORACLE]数据库之间复制表</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>39</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/68C03E81-35B5-456A-A76F-CC9010463BC3.html' title='不安装Oracle客户端也能使用PL/SQL解压缩instantclient_12_1 到D:\Oracle\instantclient_12_1在文件夹内建立目录,/NETWORK/ADMIN在该目录下，新建文件tnsnames.oraadamdb=  (DESCRIPTION=  (ADDRESS_LIST=  (ADDRESS=(PROTOCOL=TCP)(HOST=192.168.1.7)(PORT=1521))  )  (CONNECT_DATA=  (SID=adamdb)  )  )添加环境变量【ORACLE_HOME】  D:\Oracle\instantclient_12_1    【TNS_ADMIN】  D:\Oracle\instantclient_12_1\NETWORK\ADMIN    【NLS_LANG】  AMERICAN_AMERICA.UTF8启动PL/SQL Developer，在登录窗口界面,点击取消按钮就可以进行主界面,点击Tools-Preferences，在Connection中需要配置如下两个参数Oracle Home：D:\Oracle\instantclient_12_1OCI Library：D:\Oracle\instantclient_12_1\oci.dll至此配置完成,现在就可以正常使用pl/sql developer了'>不安装Oracle客户端也能使用PL/SQL</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li><li><span>40</span>&nbsp;&nbsp;<a class='btn btn-link' style='color: blue' href='../../../../../Artlcle/vip/8BA5BF7A-D540-4C4A-9E5D-CD96FDA8977B.html' title='/// summary    /// 键值对SQL    /// /summary 日期格式参考 diction.Add(DCREATETIME, to_date(system,yyyy-mm-dd));    /// param name=diction插入的列和值/param    /// param name=Table表/param    /// returns/returns    public string MthReturnSql(Dictionaryobject, object diction,string Table)    {      string _sk = insert into  + Table +  (;      string _sV = null;      foreach (object k in diction.Keys)      {        _sk += k + ,;      }      foreach (object v in diction.Values)      {        _sV +=  + v + ,;      }      string sk = _sk.Remove(_sk.Length - 1);      sk += ) values (;      string sv = _sV.Remove(_sV.Length - 1);      sv += );;      string sql = sk + sv;      return sql.ToUpper();    }/// summary    /// 修改sql    /// /summary    /// param name=diction修改列和值/param    /// param name=where条件列和值，只能有一个条件/param    /// param name=Table操作的表/param    /// returns/returns    public string Mth_update(Dictionaryobject,object diction,Dictionaryobject,object where,string Table)    {      string up = UPDATE  + Table +  SET ;      foreach (var item in diction)      {        up += item.Key.ToString() + = + item.Value.ToString() + ,;      }      string wh = null;      foreach (var item in where)      {        wh += item.Key.ToString() + = + item.Value.ToString() + ;      }      string str = up.Remove(up.Length - 1, 1)+ where +wh;      return str.ToUpper();    }'>键Dictionary 值对SQL</a>&nbsp;&nbsp;&nbsp;&nbsp;<span>15-12-7 上午 12:00:00</span></li>
                        </ul>
                        <br /><hr />
                    </div>
                </div>
                <div id="footerInnerSeparator"></div>
            </div>
        </div>
        <div id="footerOuterSeparator"></div>
    </div>
    <br /><br /><br />
    <script src="../../js/jquery-1.9.1.js"></script>
</body>
</html>