<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="Language" content="zh-CN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../images/kebue.ico">
    <link rel="icon" href="../../images/kebue.ico">
    <meta name="description" content=部分面试知识点（web前端工程师）>
    <meta name="keywords" content=部分面试知识点（web前端工程师）JavaScript的类型转换JavaScript是一种无类型语言，类型转换分为显式转换和隐式转换隐式转换通过运算符进行转换，在一些运算中，Javascript也会进行自动类型转换显式转换通过手动进行类型转换，Javascript提供了以下转型函数：转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(stri>
    <title>部分面试知识点（web前端工程师）</title>

    <link href="../../template/scripts/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="../../template/styles/custom.css" rel="stylesheet" />
</head>
<body id="pageBody">
    <div id="divBoxed" class="container">
        <div class="transparent-bg" style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;z-index: -1;zoom: 1;"></div>
        <div class="divPanel notop nobottom">
            <div class="row-fluid">
                <div class="span12">
                    <div id="divLogo">
                        <a href="../../../Home/Index" id="divSiteTitle">科布尔 kebue</a><br />
                        <a href="../../../Home/Index" id="divTagLine">开发者用代码改变世界从科布尔开始</a>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="divMenuRight" class="pull-right">
                        <div class="navbar">
                            <button type="button" class="btn btn-navbar-highlight btn-large btn-primary" data-toggle="collapse" data-target=".nav-collapse">
                                NAVIGATION <span class="icon-chevron-down icon-white"></span>
                            </button>
                            <div class="nav-collapse collapse">
                                <ul class="nav nav-pills ddmenu">
                                    <li class="dropdown glyphicon glyphicon-arrow-left"><a href='javascript:window.history.back()'>后退</a></li>
                                    <li class="dropdown active"><a href="http://www.kebue.com/">Home</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row-fluid">
                <div class="span12">
                    <div id="contentInnerSeparator"></div>
                </div>
            </div>
        </div>
        <div class="contentArea">
            <div class="divPanel notop page-content">
                <div class="breadcrumbs">
                    <a href="../../../Home/Index">Home</a> &nbsp;/&nbsp; <span><a href='../../../../../Artlcle/ArticleType/9D69FD3D-028F-4239-89F1-BAC91B1DFF4A.html' title='JavaScript'>JavaScript</a></span>
                </div>
                <div class="row-fluid">
                    <div class="span12" id="divMain">
                        <h1>部分面试知识点（web前端工程师）</h1>
                        <pre>
                        <code>
                            <h1 style="font-family: 微软雅黑; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><a href="http://www.cnblogs.com/zzy9669/p/4764469.html" style="background-color: inherit; cursor: pointer;">部分面试知识点（web前端工程师）</a></h1><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">JavaScript</strong><strong style="background-color: inherit;">的类型转换</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">JavaScript是一种无类型语言，类型转换分为显式转换和隐式转换</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">隐式转换</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">通过运算符进行转换，在一些运算中，Javascript也会进行自动类型转换</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">显式转换</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">通过手动进行类型转换，Javascript提供了以下转型函数：</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)<br style="background-color: inherit;"/>转换为字符串类型：toString(radix)、String(mix)<br style="background-color: inherit;"/>转换为布尔类型：Boolean(mix)</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">JavaScript</strong><strong style="background-color: inherit;">的原型与继承</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">Js所有的函数都有一个prototype属性，这个属性引用了一个对象，简称原型，javascript中的继承是通过原型链来体现的，访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">B.prototype = new A();，此时B.prototype.constructor就是构造对象A，随后使用B.prototype.constructor = B;将B原型的构造器重新指向B构造函数在进行原型继承后，要进行修正操作。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">JavaScript</strong><strong style="background-color: inherit;">的闭包</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">闭包函数类似于Java等OO语言中的getter和setter函数，即因为变量作用域的原因，在函数外部无法读取函数内的局部变量。闭包就是能够读取其他函数内部变量的函数。父对象的所有变量，对子对象都是可见的，反之则不成立。闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 &nbsp;&nbsp;闭包会在父函数外部，改变父函数内部变量的值。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">HTTP</strong><strong style="background-color: inherit;">中</strong><strong style="background-color: inherit;">Get</strong><strong style="background-color: inherit;">和</strong><strong style="background-color: inherit;">Post</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">get是从服务器上获取数据，post是向服务器传送数据。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">即GET请求的数据会暴露在地址栏中，而POST请求则不会。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。数据量不能大于2KB</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，理论上，IIS4中最大量为80KB，IIS5中为100KB。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">POST的安全性比GET的高。在FORM提交的时候，如果不指定Method，则默认为GET。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">JavaScript</strong><strong style="background-color: inherit;">事件绑定</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">IE的attachEvent()</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">elemObject.attachEvent(&quot;eventName&quot;,&nbsp;functionReference);</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">eventName&nbsp;参数的值是表示事件名称的字符串，比如onclick（含on）。functionReference&nbsp;参数是一个不带括号的函数引用</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">W3C DOM 的addEventListener()</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">nodeReference.addEventListener(&quot;eventType&quot;, listenerReference, captureFlag);</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">用 W3C DOM 规范中的行话来说，addEventListener()&nbsp;方法为指定的结点注册了一个事件，表示该结点希望处理相应的事件。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">第一个参数是一个声明事件类型的字符串，比如click，mousedown。（不含on）</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">第二个参数可以和早些时候描述过的函数引用同样对待。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">第三个参数则是一个Boolean值，指明该结点是否以DOM中的捕捉模式来侦听事件。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">JavaSciprt</strong><strong style="background-color: inherit;">事件冒泡以及目标元素</strong><strong style="background-color: inherit;">。</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">事件冒泡: 当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">目标元素: 任何一个事件的目标元素都是最开始的那个元素，并且它在我们的元素对象中以属性的形式出现。使用事件代理的话我们可以把事件处理器添加到一个元素上，等待一个事件从它的子级元素里冒泡上来，并且可以很方便地得知这个事件是从哪个元素开始的。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">JavaScript</strong><strong style="background-color: inherit;">图片轮播</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1.全局变量等</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">定义初始index，图片总数</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2.自动切换定时器处理</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">设置自动切换时间，自动切换后修改index</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3.为左右箭头添加事件处理</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">滑入清除定时器，滑出则重置定时器，根据curIndex进行上/下一个图片处理</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">4.为右下角的li 按钮绑定事件处理</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">用css来隐藏img，用siblings而不是先hide全部在fadein，使用siblings来处理这样的情况速度会比较快。简单来讲siblings就是除开当前显示的这个以外的所有统计图片全部fadeOut</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">JavaScript</strong><strong style="background-color: inherit;">网页前进和后退的代码</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">前进: history.forward();=history.go(1);</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">后退: history.back();=history.go(-1);</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">cookie</strong><strong style="background-color: inherit;">和</strong><strong style="background-color: inherit;">session</strong><strong style="background-color: inherit;">的区别</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">CSS&nbsp;</strong><strong style="background-color: inherit;">优先级法则</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1.、 选择器都有一个权值，权值越大越优先，当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2、 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3、继承的CSS 样式不如后来指定的CSS 样式，在同一组属性设置中标有“!important”规则的优先级最大</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">CSS</strong><strong style="background-color: inherit;">选择器</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">浏览器兼容性问题</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">javascript</strong><strong style="background-color: inherit;">兼容性问题</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1、在标准的事件绑定中绑定事件的方法函数为 addEventListener,而IE使用的是attachEvent</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2、事件处理中非常有用的event属性获得亦不相同，标准浏览器是作为参数带人，而ie是window.event方式获得，获得目标元素ie为e.srcElement 标准浏览器为e.target</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3、然后在ie中是不能操作tr的innerHtml</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">4、然后ie日期函数处理与其它浏览器不大一致，比如： var year= new Date().getYear(); 在IE中会获得当前年，但是在firefox中则会获得当前年与1900的差值。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">5、获得DOM节点的方法有所差异，其获得子节点方法不一致。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">css</strong><strong style="background-color: inherit;">兼容性问题</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1、不同浏览器的标签默认的外补丁和内补丁不同，解决方案：用通配符*来设置各个标签的内外补丁是0。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2、div的垂直居中问题 vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3、margin加倍的问题 设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上 display:inline;&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">Ajax</strong><strong style="background-color: inherit;">是什么</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">ajax是异步的 JavaScript 和 XML。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">Ajax</strong><strong style="background-color: inherit;">的交互模型</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;1--启动 &nbsp;获取XMlHttpRequest对象<br style="background-color: inherit;"/>&nbsp;2--open 打开url通道，并设置异步传输&nbsp;<br style="background-color: inherit;"/>3--send 发送数据到服务器</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">4--服务器接受数据并处理，处理完成后返回结果&nbsp;<br style="background-color: inherit;"/>5--客户端接收服务器端返回</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">同步和异步的区别</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">同步：脚本会停留并等待服务器发送回复然后再继续</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">异步：脚本允许页面继续其进程并处理可能的回复</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">Ajax</strong><strong style="background-color: inherit;">跨域的解决方法</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">如果在A网站中，我们希望使用Ajax来获得B网站中的特定内容，如果A网站与B网站不在同一个域中，那么就出现了跨域访问问题。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">IE对于跨域访问的处理是，弹出警告框，提醒用户。如果用户将该网站纳入可信任网站，或者调低安全级别，那么这个问题IE就不会在提醒你。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">FireFox等其它非微软的浏览器遇到跨域访问，则解决方案统一是拒绝访问</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">几个可行的方案：</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1、Web代理的方式。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2、on-Demand方式</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3、iframe方式。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">4、用户本地转储方式</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">什么是</strong><strong style="background-color: inherit;">PHP</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">超级文本预处理语言 Hypertext PreProcessor，是一种用来开发动态网站的服务器端脚本语言。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">PHP</strong><strong style="background-color: inherit;">字符串翻转</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">echo strrev($a);</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">PHP</strong><strong style="background-color: inherit;">支持多</strong><strong style="background-color: inherit;"><a href="http://www.php100.com/html/dujia/2015/0107/8290.html" target="_blank" style="background-color: inherit; cursor: pointer;">继承</a></strong><strong style="background-color: inherit;">吗？</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">不支持。PHP中只允许单继承，父类可以被一个子类用关键字“extends”继承。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">echo(),print(),print_r()</strong><strong style="background-color: inherit;">的区别</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">echo是PHP语句, print和print_r是函数,语句没有返回值,函数可以有返回值</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">echo输出一个或者多个字符串</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">print()只能打印出简单类型变量的值(如int,string)&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">print_r() &nbsp;可以打印出复杂类型变量的值(如数组,对象)&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">在</strong><strong style="background-color: inherit;">PHP</strong><strong style="background-color: inherit;">中如何定义常量</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">?褂胐efine&nbsp;()&nbsp;来定义常量，比如define&nbsp;(“Newconstant”,&nbsp;30);</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">语句</strong><strong style="background-color: inherit;">include</strong><strong style="background-color: inherit;">和</strong><strong style="background-color: inherit;">require</strong><strong style="background-color: inherit;">的区别，如何避免多次包含同一文件</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">require是无条件包含，也就是如果一个流程里加入require,无论条件成立与否都会先执行require&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">include有返回值，而require没有(可能因为如此require的速度比include快)&nbsp;包含文件不存在或者语法错误的时候require是致命的,include不是</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">使用&nbsp;<strong style="background-color: inherit;">require_once</strong>() 和&nbsp;<strong style="background-color: inherit;">include_once</strong>()可以避免多次包含同一文件以避免函数重定义，变量重新赋值等问题。&nbsp;返回值和include() 相同。如果文件已被包含，本函数返回 TRUE。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">HTTP</strong><strong style="background-color: inherit;">协议</strong><strong style="background-color: inherit;">1.0</strong><strong style="background-color: inherit;">及</strong><strong style="background-color: inherit;">1.1</strong><strong style="background-color: inherit;">的区别，并简单说下</strong><strong style="background-color: inherit;">HTTP</strong><strong style="background-color: inherit;">协议</strong><br style="background-color: inherit;"/>HTTP，超文本传输协议。它定义了浏览器和服务器的通信规则。HTTP协议是基于TCP/IP的TCP协议上，现在万维网使用的是HTTP1.1版本，其特点包括，C/S模式，请求简单(GET/POST/HEAD),灵活(可以传输任何类型的数据HTML、XML、JSON、自定义等)，无连接(每次连接只处理一个请求，从发出请求到收到200状态为止断开连接)，无状态。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">HTTP协议主要包括，响应消息格式、请求消息格式、状态码知识点。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">什么是</strong><strong style="background-color: inherit;">MVC</strong><strong style="background-color: inherit;">？</strong><br style="background-color: inherit;"/>MVC，即Model（数据层），View（视图层），Controller（控制层）。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">PHP中的MVC模型是一种有效将代码分成三层的管理办法，</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">Model表示着应用中的数据信息</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">View负责将应用中的数据信息展现出来</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">Controller控制着如何将数据信息读出。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">Spring MVC</strong><strong style="background-color: inherit;">工作原理</strong><br style="background-color: inherit;"/>1. 客户端请求提交到DispatcherServlet<br style="background-color: inherit;"/>2. 由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller<br style="background-color: inherit;"/>3. DispatcherServlet将请求提交到Controller<br style="background-color: inherit;"/>4. Controller调用业务逻辑处理后，返回ModelAndView<br style="background-color: inherit;"/>5. DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图<br style="background-color: inherit;"/>6. 视图负责将结果显示到客户端</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">为什么要用</strong><strong style="background-color: inherit;">Spring&nbsp;</strong><br style="background-color: inherit;"/>1、Spring能很好的与各大框架进行集成<br style="background-color: inherit;"/>2、创建对象时，如果我们不用spring需要用工厂模式来创建，这个spring相当于工厂模式已经帮我们做了创建对象的功能(IOC、依赖注入)。<br style="background-color: inherit;"/>3、在用Hibernate的时候，如果不用spring每次都要写事务的提交代码，有了spring可以通过AOP帮助我们管理事务&nbsp;<br style="background-color: inherit;"/>4、面向切面编程（AOP）在要记录日志的时候添加一条记录后需要在数据里同时添加一条添加成功了或失败的记录，那么就可以用Spring的Aop来处理，虽然不用Aop也能做但是不用Spring的Aop就会写很多重复的代码。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">Spring</strong><strong style="background-color: inherit;">中的</strong><strong style="background-color: inherit;">IOC</strong><strong style="background-color: inherit;">和</strong><strong style="background-color: inherit;">AOP</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">IOC依赖注入，即用接口编程，在程序中不出现new关键字，用接口来命名引用，然后通过某种方式把接口的某个实现类的实例注入到引用里，从而实现接口与具体实现类的松耦合。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">AOP面向方面的编程，即，是一种编程技术，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP&nbsp;的核心构造是方面，它将那些影响多个类的行为封装到可重用的模块中。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">Spring bean</strong><strong style="background-color: inherit;">生命周期</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">实例化——填充属性——</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用BeanNameAware的setBeanName()方法</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用BeanFactoryAware的setBeanFactory()方法</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用ApplicationContextAwar的setApplicationContext()方法</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用BeanPostprocessore的预初始化方法</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用InitialzingBean的afterPropertiesSet()方法</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用定制的初始化方法——调用Beanprocessors的后初始化方法——</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">bean可以使用——容器关闭——</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用DisposableBean的destroy()方法——</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">调用定制的销毁方法——结束</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1.&nbsp;&nbsp;&nbsp;&nbsp;BeanFactoyPostProcessor实例化</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2.&nbsp;&nbsp;&nbsp;&nbsp;Bean实例化，然后通过某些BeanFactoyPostProcessor来进行依赖注入</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3.&nbsp;&nbsp;&nbsp;&nbsp;BeanPostProcessor的调用.Spring内置的BeanPostProcessor负责调用Bean实现的接口: BeanNameAware, BeanFactoryAware, ApplicationContextAware等等，等这些内置的BeanPostProcessor调用完后才会调用自己配置的BeanPostProcessor</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bean销毁阶段</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">SSH</strong><strong style="background-color: inherit;">整合</strong><strong style="background-color: inherit;">&nbsp;</strong><br style="background-color: inherit;"/>SSH：Struts（表示层）+Hibernate（持久层）+Spring（业务层）<br style="background-color: inherit;"/>Struts是一个表示层框架，主要作用是界面展示，接收请求，分发请求。<br style="background-color: inherit;"/>Hibernate是一个持久层框架，它只负责与关系数据库的操作。<br style="background-color: inherit;"/>Spring是一个业务层框架，是一个整合的框架，能够很好地黏合表示层与持久层。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">Spring</strong><strong style="background-color: inherit;">的事务管理</strong><strong style="background-color: inherit;">&nbsp;</strong><br style="background-color: inherit;"/>事务就是对一系列的数据库操作进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">数据库连接池</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">开源数据库连接池主要有c3p0、dbcp、proxool三种</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">DBCP是Apache上的一个 java连接池项目，也是 tomcat使用的连接池组件。由于建立数据库连接是一个非常耗时耗资源的行为，所以通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去。dbcp没有自动的去回收空闲连接的功能。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">各种排序算法的比较</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">二叉树</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1.在二叉树的第I层上至多有2i-1个结点。<br style="background-color: inherit;"/>2.深度为k的二叉树至多有2k-1个结点(k&gt;=1)<br style="background-color: inherit;"/>3.在任意一个二叉树中，度为0的结点总是比度为2的结点多一个；<br style="background-color: inherit;"/>4.具有n 个结点的二叉树，其深度至少为[log2n]+1。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);"><strong style="background-color: inherit;">B</strong><strong style="background-color: inherit;">树</strong><strong style="background-color: inherit;">平衡多路查找树</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2.所有结点存储一个关键字；</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">4.所有的叶子结点都位于同一层。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">搜索：从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">右儿子<br style="background-color: inherit;"/><strong style="background-color: inherit;">Dijkstra&nbsp;</strong><strong style="background-color: inherit;">算法</strong></p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">在<a href="http://baike.baidu.com/view/93110.htm" target="_blank" style="background-color: inherit; cursor: pointer;">无向图</a>&nbsp;G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短值。</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">把顶点集合V分成两组：</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1.S：已求出的顶点的集合（初始时只含有源点V0）</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2.V-S=T：尚未确定的顶点集合</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">将T中顶点按递增的次序加入到S中，保证：</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">1.从源点V0到S中其他各顶点的长度都不大于从V0到T中任何顶点的最短路径长度</p><p style="font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);">2.每个顶点对应一个距离值</p><p><br/></p>
                        </code>
                        </pre>
                        <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone"></a><a href="#" class="bds_tsina" data-cmd="tsina"></a><a href="#" class="bds_tqq" data-cmd="tqq"></a><a href="#" class="bds_renren" data-cmd="renren"></a><a href="#" class="bds_weixin" data-cmd="weixin"></a></div>
                        <!-- UY BEGIN -->
                        <div id="uyan_frame"></div>
                        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2113268"></script>
                        <!-- UY END -->
                    </div>
                </div>
                <div id="footerInnerSeparator"></div>
            </div>
        </div>
        <div id="footerOuterSeparator"></div>
    </div>
    <br /><br /><br />
    <script src="../../js/jquery-1.9.1.js"></script>
    <script>
        window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": $("#divMain pre code").text(), "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {}, "image": { "viewList": ["qzone", "tsina", "tqq", "renren", "weixin"], "viewText": "分享到：", "viewSize": "16" }, "selectShare": { "bdContainerClass": null, "bdSelectMiniList": ["qzone", "tsina", "tqq", "renren", "weixin"] } }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];
    </script>
</body>
</html>